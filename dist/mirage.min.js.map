{"version":3,"sources":["_version.ts","CornerRadius.ts","Enums.ts","core/LayoutNode.ts","mirage.js","Panel.ts","Grid.ts","IColumnDefinition.ts","IGridLength.ts","IRowDefinition.ts","Point.ts","Rect.ts","Size.ts","StackPanel.ts","Thickness.ts","core/ArrangeBinder.ts","core/Arranger.ts","core/DefaultLayoutTree.ts","core/LayoutFlags.ts","core/MeasureBinder.ts","core/Measurer.ts","core/util.ts","draft/ArrangeDrafter.ts","draft/Drafter.ts","draft/MeasureDrafter.ts","draft/SizeDrafter.ts","grid/GridArrangeOverride.ts","grid/GridMeasureOverride.ts","grid/design/Arrange.ts","grid/design/GridPlacement.ts","grid/design/GridShape.ts","grid/design/helpers.ts","grid/design/IGridDesign.ts","grid/design/Measure.ts","grid/design/MeasureOverridePass.ts","grid/design/Segment.ts"],"names":["mirage","mirage.CornerRadius","mirage.CornerRadius.constructor","mirage.CornerRadius.isEmpty","mirage.CornerRadius.isEqual","mirage.CornerRadius.clear","mirage.CornerRadius.copyTo","mirage.HorizontalAlignment","mirage.VerticalAlignment","mirage.Orientation","mirage.core","mirage.core.onNodeSizeInputsChanged","mirage.core.LayoutNode","mirage.core.LayoutNode.constructor","mirage.core.LayoutNode.init","mirage.core.LayoutNode.createInputs","mirage.core.LayoutNode.createState","mirage.core.LayoutNode.createTree","mirage.core.LayoutNode.createMeasurer","mirage.core.LayoutNode.createArranger","get","mirage.core.LayoutNode.visible","set","enumerable","configurable","mirage.core.LayoutNode.useLayoutRounding","mirage.core.LayoutNode.margin","mirage.core.LayoutNode.width","mirage.core.LayoutNode.height","mirage.core.LayoutNode.minWidth","mirage.core.LayoutNode.minHeight","mirage.core.LayoutNode.maxWidth","mirage.core.LayoutNode.maxHeight","mirage.core.LayoutNode.horizontalAlignment","mirage.core.LayoutNode.verticalAlignment","mirage.core.LayoutNode.getAttached","mirage.core.LayoutNode.setAttached","mirage.core.LayoutNode.setParent","mirage.core.LayoutNode.onDetached","mirage.core.LayoutNode.onAttached","mirage.core.LayoutNode.walkDeep","mirage.core.LayoutNode.walkDeep.step","mirage.core.LayoutNode.walkDeep.skipBranch","mirage.core.LayoutNode.invalidateMeasure","mirage.core.LayoutNode.doMeasure","mirage.core.LayoutNode.measure","mirage.core.LayoutNode.measureOverride","mirage.core.LayoutNode.invalidateArrange","mirage.core.LayoutNode.doArrange","mirage.core.LayoutNode.arrange","mirage.core.LayoutNode.arrangeOverride","mirage.core.LayoutNode.sizing","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","mirage.NewPanelTree","mirage.NewPanelTree.step","mirage.Panel","mirage.Panel.constructor","mirage.Panel.createTree","mirage.Panel.measureOverride","mirage.Panel.arrangeOverride","mirage.Panel.childCount","mirage.Panel.insertChild","mirage.Panel.prependChild","mirage.Panel.appendChild","mirage.Panel.removeChild","mirage.Panel.removeChildAt","mirage.Panel.getChildAt","mirage.invalidateCell","mirage.Grid","mirage.Grid.constructor","mirage.Grid.getColumn","mirage.Grid.setColumn","mirage.Grid.getColumnSpan","mirage.Grid.setColumnSpan","mirage.Grid.getRow","mirage.Grid.setRow","mirage.Grid.getRowSpan","mirage.Grid.setRowSpan","mirage.Grid.init","mirage.Grid.rowDefinitions","mirage.Grid.columnDefinitions","mirage.Grid.createInputs","mirage.Grid.createState","mirage.Grid.measureOverride","mirage.Grid.arrangeOverride","mirage.NewColumnDefinitions","mirage.NewColumnDefinition","mirage.NewColumnDefinition.getActualWidth","mirage.NewColumnDefinition.setActualWidth","mirage.parseGridLength","mirage.GridUnitType","mirage.NewRowDefinitions","mirage.NewRowDefinition","mirage.NewRowDefinition.getActualHeight","mirage.NewRowDefinition.setActualHeight","mirage.Point","mirage.Point.constructor","mirage.Point.isEqual","mirage.Point.copyTo","mirage.Point.round","mirage.RectOverlap","mirage.Rect","mirage.Rect.constructor","mirage.Rect.clear","mirage.Rect.getBottom","mirage.Rect.getRight","mirage.Rect.isEqual","mirage.Rect.isEmpty","mirage.Rect.copyTo","mirage.Rect.roundOut","mirage.Rect.roundIn","mirage.Rect.intersection","mirage.Rect.union","mirage.Rect.isContainedIn","mirage.Rect.containsPoint","mirage.Rect.extendTo","mirage.Rect.grow","mirage.Rect.shrink","mirage.Rect.rectIn","mirage.Size","mirage.Size.constructor","mirage.Size.copyTo","mirage.Size.isEqual","mirage.Size.isEmpty","mirage.Size.max","mirage.Size.min","mirage.Size.round","mirage.Size.isUndef","mirage.Size.clear","mirage.Size.undef","mirage.StackPanel","mirage.StackPanel.constructor","mirage.StackPanel.orientation","mirage.StackPanel.createInputs","mirage.StackPanel.measureOverride","mirage.StackPanel.measureVertical","mirage.StackPanel.measureHorizontal","mirage.StackPanel.arrangeOverride","mirage.StackPanel.arrangeVertical","mirage.StackPanel.arrangeHorizontal","mirage.Thickness","mirage.Thickness.constructor","mirage.Thickness.add","mirage.Thickness.copyTo","mirage.Thickness.isEmpty","mirage.Thickness.isEqual","mirage.Thickness.isBalanced","mirage.Thickness.shrinkSize","mirage.Thickness.shrinkRect","mirage.Thickness.shrinkCornerRadius","mirage.Thickness.growSize","mirage.Thickness.growRect","mirage.Thickness.growCornerRadius","mirage.core.NewArrangeBinder","last","state","layoutSlot","undefined","tree","parent","Rect","arranger","invalidateArrange","mirage.core.NewSpecialArrangeBinder","expandViewport","shiftViewport","mirage.core.NewArranger","inputs","visible","childRect","useLayoutRounding","x","Math","round","finalRect","y","width","height","copyTo","isFinite","isNaN","console","warn","flags","core","LayoutFlags","arrange","isEqual","Thickness","shrinkRect","margin","stretched","Size","coerceSize","framework","horizontalAlignment","HorizontalAlignment","stretch","max","verticalAlignment","VerticalAlignment","offer","hiddenDesire","arranged","override","constrained","min","as","arrangedSlot","Point","left","right","center","top","bottom","oldArrange","lastArranged","sizeHint","propagateFlagUp","mirage.core.DefaultLayoutTree","mirage.core.DefaultLayoutTree.applyTemplate","mirage.core.DefaultLayoutTree.propagateFlagUp","mirage.core.DefaultLayoutTree.walk","mirage.core.DefaultLayoutTree.walk.step","mirage.core.LayoutFlags","mirage.core.NewMeasureBinder","previousAvailable","isUndef","isLayoutContainer","Number","POSITIVE_INFINITY","success","old","desiredSize","measurer","invalidateMeasure","measure","mirage.core.NewMeasurer","availableSize","applyTemplate","pc","arrangeHint","framedSize","shrinkSize","desired","growSize","mirage.core.coerceSize","mirage.draft","mirage.draft.NewArrangeDrafter","mirage.draft.NewArrangeDrafter.flush","mirage.draft.NewArrangeDrafter.prepare","mirage.draft.NewArrangeDrafter.draft","mirage.draft.NewDrafter","mirage.draft.NewDrafter.runDraft","node","hints","updated","count","MAX_COUNT","runDraft","error","mirage.draft.NewMeasureDrafter","mirage.draft.NewMeasureDrafter.prepare","mirage.draft.NewMeasureDrafter.draft","mirage.draft.NewSizeDrafter","mirage.draft.NewSizeDrafter.flush","mirage.draft.NewSizeDrafter.prepare","mirage.draft.NewSizeDrafter.draft","mirage.draft.NewSizeDrafter.notify","mirage.grid","mirage.grid.NewGridArrangeOverride","des","init","arrangeSize","columnDefinitions","rowDefinitions","cr","walker","walk","step","child","current","calcChildRect","mirage.grid.NewGridMeasureOverride","constraint","overrideAutoAuto","overrideStarAuto","overrideAutoStar","overrideStarAuto2","overrideNonStar","overrideRemainingStar","finish","getDesired","mirage.grid.design","mirage.grid.design.NewGridArrangeDesign","mirage.grid.design.NewGridArrangeDesign.init","mirage.grid.design.NewGridArrangeDesign.calcChildRect","mirage.grid.design.originalToOffered","mirage.grid.design.NewGridPlacement","mirage.grid.design.NewGridPlacement.init","mirage.grid.design.NewGridPlacement.add","mirage.grid.design.NewGridPlacement.allocate","mirage.grid.design.NewGridShape","mirage.grid.design.GridChildShape","mirage.grid.design.GridChildShape.init","mirage.grid.design.GridChildShape.shouldMeasurePass","mirage.grid.design.GridChildShape.calcConstraint","mirage.grid.design.helpers","mirage.grid.design.helpers.expand","mirage.grid.design.helpers.assignSize","mirage.grid.design.helpers.calcDesiredToOffered","mirage.grid.design.NewGridDesign","mirage.grid.design.NewGridMeasureDesign","mirage.grid.design.NewGridMeasureDesign.init","mirage.grid.design.NewGridMeasureDesign.measureChild","mirage.grid.design.NewGridMeasureDesign.finishPass","mirage.grid.design.NewGridMeasureDesign.finish","mirage.grid.design.NewGridMeasureDesign.getDesired","mirage.grid.design.ensureMatrix","mirage.grid.design.prepareCols","mirage.grid.design.prepareRows","mirage.grid.design.allocateDesiredSizeFunc","mirage.grid.design.allocateDesiredSizeFunc.hasStarInSpan","mirage.grid.design.allocateDesiredSizeFunc.calcDesired","mirage.grid.design.allocateDesiredSizeFunc.allocSegments","allocSegments","rm","cm","design","helpers","calcDesiredToOffered","mirage.grid.design.NewMeasureOverridePass","i","measureChild","pass","finishPass","mirage.grid.design.MeasureOverridePass","mirage.grid.design.Segment","mirage.grid.design.Segment.constructor","mirage.grid.design.Segment.clamp","mirage.grid.design.Segment.init"],"mappings":"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","file":"mirage.min.js","sourcesContent":["module mirage {\r\n    export var version = '0.1.0';\r\n}","namespace mirage {\r\n    export interface ICornerRadius {\r\n        topLeft: number;\r\n        topRight: number;\r\n        bottomRight: number;\r\n        bottomLeft: number;\r\n    }\r\n\r\n    export class CornerRadius implements ICornerRadius {\r\n        topLeft: number;\r\n        topRight: number;\r\n        bottomRight: number;\r\n        bottomLeft: number;\r\n\r\n        constructor (topLeft?: number, topRight?: number, bottomRight?: number, bottomLeft?: number) {\r\n            this.topLeft = topLeft == null ? 0 : topLeft;\r\n            this.topRight = topRight == null ? 0 : topRight;\r\n            this.bottomRight = bottomRight == null ? 0 : bottomRight;\r\n            this.bottomLeft = bottomLeft == null ? 0 : bottomLeft;\r\n        }\r\n\r\n        static isEmpty (cr: ICornerRadius): boolean {\r\n            return cr.topLeft === 0\r\n                && cr.topRight === 0\r\n                && cr.bottomRight === 0\r\n                && cr.bottomLeft === 0;\r\n        }\r\n\r\n        static isEqual (cr1: ICornerRadius, cr2: ICornerRadius): boolean {\r\n            return cr1.topLeft === cr2.topLeft\r\n                && cr1.topRight === cr2.topRight\r\n                && cr1.bottomRight === cr2.bottomRight\r\n                && cr1.bottomLeft === cr2.bottomLeft;\r\n        }\r\n\r\n        static clear (dest: ICornerRadius) {\r\n            dest.topLeft = dest.topRight = dest.bottomRight = dest.bottomLeft = 0;\r\n        }\r\n\r\n        static copyTo (cr2: ICornerRadius, dest: ICornerRadius) {\r\n            dest.topLeft = cr2.topLeft;\r\n            dest.topRight = cr2.topRight;\r\n            dest.bottomRight = cr2.bottomRight;\r\n            dest.bottomLeft = cr2.bottomLeft;\r\n        }\r\n    }\r\n}","namespace mirage {\n    export enum HorizontalAlignment {\n        left = 0,\n        center = 1,\n        right = 2,\n        stretch = 3,\n    }\n    export enum VerticalAlignment {\n        top = 0,\n        center = 1,\n        bottom = 2,\n        stretch = 3,\n    }\n    export enum Orientation {\n        horizontal = 0,\n        vertical = 1,\n    }\n}","namespace mirage.core {\n    export interface ILayoutNodeInputs {\n        visible: boolean;\n        useLayoutRounding: boolean;\n        margin: Thickness;\n        width: number;\n        height: number;\n        minWidth: number;\n        minHeight: number;\n        maxWidth: number;\n        maxHeight: number;\n        horizontalAlignment: HorizontalAlignment;\n        verticalAlignment: VerticalAlignment;\n        attached: ILayoutNodeAttachedInputs;\n    }\n\n    export interface ILayoutNodeAttachedInputs {\n        [property: string]: any;\n    }\n\n    export interface ILayoutNodeState {\n        flags: LayoutFlags;\n        previousAvailable: ISize;\n        desiredSize: ISize;\n        hiddenDesire: ISize;\n        layoutSlot: IRect;\n        arrangedSlot: IRect;\n        lastArranged: ISize;\n    }\n\n    export interface ILayoutTreeDeepWalker {\n        current: LayoutNode;\n        step(): boolean;\n        skipBranch();\n    }\n\n    export class LayoutNode {\n        inputs: ILayoutNodeInputs;\n        state: ILayoutNodeState;\n        tree: ILayoutTree;\n\n        private $measurer: core.IMeasurer;\n        private $arranger: core.IArranger;\n        private $measureBinder: core.IMeasureBinder;\n        private $arrangeBinder: core.IArrangeBinder;\n\n        constructor() {\n            this.init();\n        }\n\n        init() {\n            Object.defineProperties(this, {\n                \"inputs\": {value: this.createInputs(), writable: false},\n                \"state\": {value: this.createState(), writable: false},\n                \"tree\": {value: this.createTree(), writable: false},\n                \"attached\": {value: {}, writable: false},\n            });\n            this.$measurer = this.createMeasurer();\n            this.$arranger = this.createArranger();\n            this.$measureBinder = NewMeasureBinder(this.state, this.tree, this.$measurer);\n            this.$arrangeBinder = NewArrangeBinder(this.state, this.tree, this.$arranger);\n        }\n\n        protected createInputs(): ILayoutNodeInputs {\n            return {\n                visible: true,\n                useLayoutRounding: true,\n                margin: new Thickness(),\n                width: NaN,\n                height: NaN,\n                minWidth: 0.0,\n                minHeight: 0.0,\n                maxWidth: Number.POSITIVE_INFINITY,\n                maxHeight: Number.POSITIVE_INFINITY,\n                horizontalAlignment: HorizontalAlignment.stretch,\n                verticalAlignment: VerticalAlignment.stretch,\n                attached: {},\n            };\n        }\n\n        protected createState(): ILayoutNodeState {\n            return {\n                flags: LayoutFlags.none,\n                previousAvailable: new Size(),\n                desiredSize: new Size(),\n                hiddenDesire: new Size(),\n                layoutSlot: new Rect(),\n                arrangedSlot: new Rect(),\n                lastArranged: new Size(),\n            };\n        }\n\n        protected createTree(): ILayoutTree {\n            return DefaultLayoutTree();\n        }\n\n        protected createMeasurer(): core.IMeasurer {\n            return core.NewMeasurer(this.inputs, this.state, this.tree, constraint => this.measureOverride(constraint));\n        }\n\n        protected createArranger(): core.IArranger {\n            return core.NewArranger(this.inputs, this.state, this.tree, arrangeSize => this.arrangeOverride(arrangeSize));\n        }\n\n        // PROPERTIES\n\n        get visible(): boolean {\n            return this.inputs.visible;\n        }\n\n        set visible(value: boolean) {\n            if (this.inputs.visible === value)\n                return;\n            this.inputs.visible = value === true;\n            this.invalidateMeasure();\n            var parent = this.tree.parent;\n            if (parent)\n                parent.invalidateMeasure();\n        }\n\n        get useLayoutRounding(): boolean {\n            return this.inputs.useLayoutRounding;\n        }\n\n        set useLayoutRounding(value: boolean) {\n            if (this.inputs.useLayoutRounding === value)\n                return;\n            this.inputs.useLayoutRounding = value === true;\n            this.invalidateMeasure();\n            this.invalidateArrange();\n        }\n\n        get margin(): Thickness {\n            return this.inputs.margin;\n        }\n\n        set margin(value: Thickness) {\n            if (Thickness.isEqual(this.inputs.margin, value))\n                return;\n            this.inputs.margin = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get width(): number {\n            return this.inputs.width;\n        }\n\n        set width(value: number) {\n            if (this.inputs.width === value)\n                return;\n            this.inputs.width = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get height(): number {\n            return this.inputs.height;\n        }\n\n        set height(value: number) {\n            if (this.inputs.height === value)\n                return;\n            this.inputs.height = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get minWidth(): number {\n            return this.inputs.minWidth;\n        }\n\n        set minWidth(value: number) {\n            if (this.inputs.minWidth === value)\n                return;\n            this.inputs.minWidth = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get minHeight(): number {\n            return this.inputs.minHeight;\n        }\n\n        set minHeight(value: number) {\n            if (this.inputs.minHeight === value)\n                return;\n            this.inputs.minHeight = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get maxWidth(): number {\n            return this.inputs.maxWidth;\n        }\n\n        set maxWidth(value: number) {\n            if (this.inputs.maxWidth === value)\n                return;\n            this.inputs.maxWidth = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get maxHeight(): number {\n            return this.inputs.maxHeight;\n        }\n\n        set maxHeight(value: number) {\n            if (this.inputs.maxHeight === value)\n                return;\n            this.inputs.maxHeight = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get horizontalAlignment(): HorizontalAlignment {\n            return this.inputs.horizontalAlignment;\n        }\n\n        set horizontalAlignment(value: HorizontalAlignment) {\n            if (this.inputs.horizontalAlignment === value)\n                return;\n            this.inputs.horizontalAlignment = value;\n            this.invalidateArrange();\n        }\n\n        get verticalAlignment(): VerticalAlignment {\n            return this.inputs.verticalAlignment;\n        }\n\n        set verticalAlignment(value: VerticalAlignment) {\n            if (this.inputs.verticalAlignment === value)\n                return;\n            this.inputs.verticalAlignment = value;\n            this.invalidateArrange();\n        }\n\n        // ATTACHED\n\n        getAttached(property: string): any {\n            return this.inputs.attached[property];\n        }\n\n        setAttached(property: string, value: any) {\n            this.inputs.attached[property] = value;\n        }\n\n        // TREE\n\n        setParent(parent: LayoutNode) {\n            if (!parent) {\n                if (!this.tree.parent)\n                    return;\n                this.tree.parent = null;\n                this.onDetached();\n            } else {\n                if (parent === this.tree.parent)\n                    return;\n                this.tree.parent = null;\n                this.onDetached();\n                this.tree.parent = parent;\n                this.onAttached();\n            }\n        }\n\n        protected onDetached() {\n            this.invalidateMeasure();\n            if (this.tree.parent)\n                this.tree.parent.invalidateMeasure();\n            Rect.clear(this.state.layoutSlot);\n        }\n\n        protected onAttached() {\n            var state = this.state;\n            Size.undef(state.previousAvailable);\n            Size.clear(state.arrangedSlot);\n            this.invalidateMeasure();\n            this.invalidateArrange();\n            if ((state.flags & LayoutFlags.sizeHint) > 0 || state.lastArranged !== undefined) {\n                this.tree.propagateFlagUp(LayoutFlags.sizeHint);\n            }\n        }\n\n        walkDeep(reverse?: boolean): ILayoutTreeDeepWalker {\n            var last: LayoutNode = undefined;\n            var walkList: LayoutNode[] = [this];\n\n            return {\n                current: undefined,\n                step(): boolean {\n                    if (last) {\n                        for (var subwalker = last.tree.walk(reverse); subwalker.step();) {\n                            walkList.unshift(subwalker.current);\n                        }\n                    }\n\n                    this.current = last = walkList.shift();\n                    return this.current !== undefined;\n                },\n                skipBranch() {\n                    last = undefined;\n                },\n            };\n        }\n\n        // LAYOUT\n\n        invalidateMeasure() {\n            this.state.flags |= LayoutFlags.measure | LayoutFlags.measureHint;\n            this.tree.propagateFlagUp(LayoutFlags.measureHint);\n        }\n\n        doMeasure(): boolean {\n            return this.$measureBinder();\n        }\n\n        measure(availableSize: ISize): boolean {\n            return this.$measurer(availableSize);\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            var desired = new Size();\n            for (var walker = this.tree.walk(); walker.step();) {\n                walker.current.measure(constraint);\n                Size.max(desired, walker.current.state.desiredSize);\n            }\n            return desired;\n        }\n\n        invalidateArrange() {\n            this.state.flags |= LayoutFlags.arrange | LayoutFlags.arrangeHint;\n            this.tree.propagateFlagUp(LayoutFlags.arrangeHint);\n        }\n\n        doArrange(): boolean {\n            return this.$arrangeBinder();\n        }\n\n        arrange(finalRect: IRect): boolean {\n            return this.$arranger(finalRect);\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            var arranged = new Size(arrangeSize.width, arrangeSize.height);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var childRect = new Rect(0, 0, arrangeSize.width, arrangeSize.height);\n                walker.current.arrange(childRect);\n            }\n            return arranged;\n        }\n\n        sizing(oldSize: ISize, newSize: ISize): boolean {\n            var state = this.state;\n            if (state.lastArranged)\n                Size.copyTo(state.lastArranged, oldSize);\n            Size.copyTo(state.arrangedSlot, newSize);\n            state.lastArranged = undefined;\n            // TODO: Set actualWidth, actualHeight\n            return true;\n        }\n\n        onSizeChanged(oldSize: ISize, newSize: ISize) {\n            // Placeholder for sizing notifications\n        }\n    }\n\n    function onNodeSizeInputsChanged(node: core.LayoutNode) {\n        node.invalidateMeasure();\n        node.invalidateArrange();\n        var parent = node.tree.parent;\n        if (parent)\n            parent.invalidateMeasure();\n    }\n}","var mirage;\n(function (mirage) {\n    mirage.version = '0.1.0';\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var CornerRadius = (function () {\n        function CornerRadius(topLeft, topRight, bottomRight, bottomLeft) {\n            this.topLeft = topLeft == null ? 0 : topLeft;\n            this.topRight = topRight == null ? 0 : topRight;\n            this.bottomRight = bottomRight == null ? 0 : bottomRight;\n            this.bottomLeft = bottomLeft == null ? 0 : bottomLeft;\n        }\n        CornerRadius.isEmpty = function (cr) {\n            return cr.topLeft === 0\n                && cr.topRight === 0\n                && cr.bottomRight === 0\n                && cr.bottomLeft === 0;\n        };\n        CornerRadius.isEqual = function (cr1, cr2) {\n            return cr1.topLeft === cr2.topLeft\n                && cr1.topRight === cr2.topRight\n                && cr1.bottomRight === cr2.bottomRight\n                && cr1.bottomLeft === cr2.bottomLeft;\n        };\n        CornerRadius.clear = function (dest) {\n            dest.topLeft = dest.topRight = dest.bottomRight = dest.bottomLeft = 0;\n        };\n        CornerRadius.copyTo = function (cr2, dest) {\n            dest.topLeft = cr2.topLeft;\n            dest.topRight = cr2.topRight;\n            dest.bottomRight = cr2.bottomRight;\n            dest.bottomLeft = cr2.bottomLeft;\n        };\n        return CornerRadius;\n    })();\n    mirage.CornerRadius = CornerRadius;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    (function (HorizontalAlignment) {\n        HorizontalAlignment[HorizontalAlignment[\"left\"] = 0] = \"left\";\n        HorizontalAlignment[HorizontalAlignment[\"center\"] = 1] = \"center\";\n        HorizontalAlignment[HorizontalAlignment[\"right\"] = 2] = \"right\";\n        HorizontalAlignment[HorizontalAlignment[\"stretch\"] = 3] = \"stretch\";\n    })(mirage.HorizontalAlignment || (mirage.HorizontalAlignment = {}));\n    var HorizontalAlignment = mirage.HorizontalAlignment;\n    (function (VerticalAlignment) {\n        VerticalAlignment[VerticalAlignment[\"top\"] = 0] = \"top\";\n        VerticalAlignment[VerticalAlignment[\"center\"] = 1] = \"center\";\n        VerticalAlignment[VerticalAlignment[\"bottom\"] = 2] = \"bottom\";\n        VerticalAlignment[VerticalAlignment[\"stretch\"] = 3] = \"stretch\";\n    })(mirage.VerticalAlignment || (mirage.VerticalAlignment = {}));\n    var VerticalAlignment = mirage.VerticalAlignment;\n    (function (Orientation) {\n        Orientation[Orientation[\"horizontal\"] = 0] = \"horizontal\";\n        Orientation[Orientation[\"vertical\"] = 1] = \"vertical\";\n    })(mirage.Orientation || (mirage.Orientation = {}));\n    var Orientation = mirage.Orientation;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        var LayoutNode = (function () {\n            function LayoutNode() {\n                this.init();\n            }\n            LayoutNode.prototype.init = function () {\n                Object.defineProperties(this, {\n                    \"inputs\": { value: this.createInputs(), writable: false },\n                    \"state\": { value: this.createState(), writable: false },\n                    \"tree\": { value: this.createTree(), writable: false },\n                    \"attached\": { value: {}, writable: false },\n                });\n                this.$measurer = this.createMeasurer();\n                this.$arranger = this.createArranger();\n                this.$measureBinder = core.NewMeasureBinder(this.state, this.tree, this.$measurer);\n                this.$arrangeBinder = core.NewArrangeBinder(this.state, this.tree, this.$arranger);\n            };\n            LayoutNode.prototype.createInputs = function () {\n                return {\n                    visible: true,\n                    useLayoutRounding: true,\n                    margin: new mirage.Thickness(),\n                    width: NaN,\n                    height: NaN,\n                    minWidth: 0.0,\n                    minHeight: 0.0,\n                    maxWidth: Number.POSITIVE_INFINITY,\n                    maxHeight: Number.POSITIVE_INFINITY,\n                    horizontalAlignment: mirage.HorizontalAlignment.stretch,\n                    verticalAlignment: mirage.VerticalAlignment.stretch,\n                    attached: {},\n                };\n            };\n            LayoutNode.prototype.createState = function () {\n                return {\n                    flags: core.LayoutFlags.none,\n                    previousAvailable: new mirage.Size(),\n                    desiredSize: new mirage.Size(),\n                    hiddenDesire: new mirage.Size(),\n                    layoutSlot: new mirage.Rect(),\n                    arrangedSlot: new mirage.Rect(),\n                    lastArranged: new mirage.Size(),\n                };\n            };\n            LayoutNode.prototype.createTree = function () {\n                return core.DefaultLayoutTree();\n            };\n            LayoutNode.prototype.createMeasurer = function () {\n                var _this = this;\n                return core.NewMeasurer(this.inputs, this.state, this.tree, function (constraint) { return _this.measureOverride(constraint); });\n            };\n            LayoutNode.prototype.createArranger = function () {\n                var _this = this;\n                return core.NewArranger(this.inputs, this.state, this.tree, function (arrangeSize) { return _this.arrangeOverride(arrangeSize); });\n            };\n            Object.defineProperty(LayoutNode.prototype, \"visible\", {\n                get: function () {\n                    return this.inputs.visible;\n                },\n                set: function (value) {\n                    if (this.inputs.visible === value)\n                        return;\n                    this.inputs.visible = value === true;\n                    this.invalidateMeasure();\n                    var parent = this.tree.parent;\n                    if (parent)\n                        parent.invalidateMeasure();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"useLayoutRounding\", {\n                get: function () {\n                    return this.inputs.useLayoutRounding;\n                },\n                set: function (value) {\n                    if (this.inputs.useLayoutRounding === value)\n                        return;\n                    this.inputs.useLayoutRounding = value === true;\n                    this.invalidateMeasure();\n                    this.invalidateArrange();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"margin\", {\n                get: function () {\n                    return this.inputs.margin;\n                },\n                set: function (value) {\n                    if (mirage.Thickness.isEqual(this.inputs.margin, value))\n                        return;\n                    this.inputs.margin = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"width\", {\n                get: function () {\n                    return this.inputs.width;\n                },\n                set: function (value) {\n                    if (this.inputs.width === value)\n                        return;\n                    this.inputs.width = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"height\", {\n                get: function () {\n                    return this.inputs.height;\n                },\n                set: function (value) {\n                    if (this.inputs.height === value)\n                        return;\n                    this.inputs.height = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"minWidth\", {\n                get: function () {\n                    return this.inputs.minWidth;\n                },\n                set: function (value) {\n                    if (this.inputs.minWidth === value)\n                        return;\n                    this.inputs.minWidth = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"minHeight\", {\n                get: function () {\n                    return this.inputs.minHeight;\n                },\n                set: function (value) {\n                    if (this.inputs.minHeight === value)\n                        return;\n                    this.inputs.minHeight = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"maxWidth\", {\n                get: function () {\n                    return this.inputs.maxWidth;\n                },\n                set: function (value) {\n                    if (this.inputs.maxWidth === value)\n                        return;\n                    this.inputs.maxWidth = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"maxHeight\", {\n                get: function () {\n                    return this.inputs.maxHeight;\n                },\n                set: function (value) {\n                    if (this.inputs.maxHeight === value)\n                        return;\n                    this.inputs.maxHeight = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"horizontalAlignment\", {\n                get: function () {\n                    return this.inputs.horizontalAlignment;\n                },\n                set: function (value) {\n                    if (this.inputs.horizontalAlignment === value)\n                        return;\n                    this.inputs.horizontalAlignment = value;\n                    this.invalidateArrange();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"verticalAlignment\", {\n                get: function () {\n                    return this.inputs.verticalAlignment;\n                },\n                set: function (value) {\n                    if (this.inputs.verticalAlignment === value)\n                        return;\n                    this.inputs.verticalAlignment = value;\n                    this.invalidateArrange();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            LayoutNode.prototype.getAttached = function (property) {\n                return this.inputs.attached[property];\n            };\n            LayoutNode.prototype.setAttached = function (property, value) {\n                this.inputs.attached[property] = value;\n            };\n            LayoutNode.prototype.setParent = function (parent) {\n                if (!parent) {\n                    if (!this.tree.parent)\n                        return;\n                    this.tree.parent = null;\n                    this.onDetached();\n                }\n                else {\n                    if (parent === this.tree.parent)\n                        return;\n                    this.tree.parent = null;\n                    this.onDetached();\n                    this.tree.parent = parent;\n                    this.onAttached();\n                }\n            };\n            LayoutNode.prototype.onDetached = function () {\n                this.invalidateMeasure();\n                if (this.tree.parent)\n                    this.tree.parent.invalidateMeasure();\n                mirage.Rect.clear(this.state.layoutSlot);\n            };\n            LayoutNode.prototype.onAttached = function () {\n                var state = this.state;\n                mirage.Size.undef(state.previousAvailable);\n                mirage.Size.clear(state.arrangedSlot);\n                this.invalidateMeasure();\n                this.invalidateArrange();\n                if ((state.flags & core.LayoutFlags.sizeHint) > 0 || state.lastArranged !== undefined) {\n                    this.tree.propagateFlagUp(core.LayoutFlags.sizeHint);\n                }\n            };\n            LayoutNode.prototype.walkDeep = function (reverse) {\n                var last = undefined;\n                var walkList = [this];\n                return {\n                    current: undefined,\n                    step: function () {\n                        if (last) {\n                            for (var subwalker = last.tree.walk(reverse); subwalker.step();) {\n                                walkList.unshift(subwalker.current);\n                            }\n                        }\n                        this.current = last = walkList.shift();\n                        return this.current !== undefined;\n                    },\n                    skipBranch: function () {\n                        last = undefined;\n                    },\n                };\n            };\n            LayoutNode.prototype.invalidateMeasure = function () {\n                this.state.flags |= core.LayoutFlags.measure | core.LayoutFlags.measureHint;\n                this.tree.propagateFlagUp(core.LayoutFlags.measureHint);\n            };\n            LayoutNode.prototype.doMeasure = function () {\n                return this.$measureBinder();\n            };\n            LayoutNode.prototype.measure = function (availableSize) {\n                return this.$measurer(availableSize);\n            };\n            LayoutNode.prototype.measureOverride = function (constraint) {\n                var desired = new mirage.Size();\n                for (var walker = this.tree.walk(); walker.step();) {\n                    walker.current.measure(constraint);\n                    mirage.Size.max(desired, walker.current.state.desiredSize);\n                }\n                return desired;\n            };\n            LayoutNode.prototype.invalidateArrange = function () {\n                this.state.flags |= core.LayoutFlags.arrange | core.LayoutFlags.arrangeHint;\n                this.tree.propagateFlagUp(core.LayoutFlags.arrangeHint);\n            };\n            LayoutNode.prototype.doArrange = function () {\n                return this.$arrangeBinder();\n            };\n            LayoutNode.prototype.arrange = function (finalRect) {\n                return this.$arranger(finalRect);\n            };\n            LayoutNode.prototype.arrangeOverride = function (arrangeSize) {\n                var arranged = new mirage.Size(arrangeSize.width, arrangeSize.height);\n                for (var walker = this.tree.walk(); walker.step();) {\n                    var childRect = new mirage.Rect(0, 0, arrangeSize.width, arrangeSize.height);\n                    walker.current.arrange(childRect);\n                }\n                return arranged;\n            };\n            LayoutNode.prototype.sizing = function (oldSize, newSize) {\n                var state = this.state;\n                if (state.lastArranged)\n                    mirage.Size.copyTo(state.lastArranged, oldSize);\n                mirage.Size.copyTo(state.arrangedSlot, newSize);\n                state.lastArranged = undefined;\n                return true;\n            };\n            LayoutNode.prototype.onSizeChanged = function (oldSize, newSize) {\n            };\n            return LayoutNode;\n        })();\n        core.LayoutNode = LayoutNode;\n        function onNodeSizeInputsChanged(node) {\n            node.invalidateMeasure();\n            node.invalidateArrange();\n            var parent = node.tree.parent;\n            if (parent)\n                parent.invalidateMeasure();\n        }\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"core/LayoutNode\" />\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar mirage;\n(function (mirage) {\n    var Panel = (function (_super) {\n        __extends(Panel, _super);\n        function Panel() {\n            _super.apply(this, arguments);\n        }\n        Panel.prototype.createTree = function () {\n            return NewPanelTree();\n        };\n        Panel.prototype.measureOverride = function (constraint) {\n            return new mirage.Size(constraint.width, constraint.height);\n        };\n        Panel.prototype.arrangeOverride = function (arrangeSize) {\n            return new mirage.Size(arrangeSize.width, arrangeSize.height);\n        };\n        Object.defineProperty(Panel.prototype, \"childCount\", {\n            get: function () {\n                return this.tree.children.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Panel.prototype.insertChild = function (child, index) {\n            var children = this.tree.children;\n            if (index >= children.length) {\n                this.appendChild(child);\n            }\n            else if (index <= 0) {\n                this.prependChild(child);\n            }\n            else {\n                children.splice(index, 0, child);\n                child.setParent(this);\n            }\n        };\n        Panel.prototype.prependChild = function (child) {\n            this.tree.children.unshift(child);\n            child.setParent(this);\n        };\n        Panel.prototype.appendChild = function (child) {\n            this.tree.children.push(child);\n            child.setParent(this);\n        };\n        Panel.prototype.removeChild = function (child) {\n            var children = this.tree.children;\n            var index = children.indexOf(child);\n            if (index < 0)\n                return false;\n            this.tree.children.splice(index, 1);\n            child.setParent(null);\n            return true;\n        };\n        Panel.prototype.removeChildAt = function (index) {\n            var children = this.tree.children;\n            if (index < 0 || index >= children.length)\n                return null;\n            var removed = children.splice(index, 1)[0];\n            if (removed)\n                removed.setParent(null);\n            return removed;\n        };\n        Panel.prototype.getChildAt = function (index) {\n            return this.tree.children[index];\n        };\n        return Panel;\n    })(mirage.core.LayoutNode);\n    mirage.Panel = Panel;\n    function NewPanelTree() {\n        var tree = mirage.core.DefaultLayoutTree();\n        tree.isLayoutContainer = true;\n        tree.children = [];\n        tree.walk = function (reverse) {\n            if (!reverse) {\n                var i = -1;\n                return {\n                    current: undefined,\n                    step: function () {\n                        i++;\n                        if (i >= tree.children.length) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                };\n            }\n            else {\n                var i = tree.children.length;\n                return {\n                    current: undefined,\n                    step: function () {\n                        i--;\n                        if (i < 0) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                };\n            }\n        };\n        return tree;\n    }\n    mirage.NewPanelTree = NewPanelTree;\n})(mirage || (mirage = {}));\n/// <reference path=\"Panel\" />\nvar mirage;\n(function (mirage) {\n    var Grid = (function (_super) {\n        __extends(Grid, _super);\n        function Grid() {\n            _super.apply(this, arguments);\n        }\n        Grid.getColumn = function (node) {\n            return node.getAttached(\"grid.column\");\n        };\n        Grid.setColumn = function (node, value) {\n            node.setAttached(\"grid.column\", value);\n            invalidateCell(node);\n        };\n        Grid.getColumnSpan = function (node) {\n            return node.getAttached(\"grid.column-span\");\n        };\n        Grid.setColumnSpan = function (node, value) {\n            node.setAttached(\"grid.column-span\", value);\n            invalidateCell(node);\n        };\n        Grid.getRow = function (node) {\n            return node.getAttached(\"grid.row\");\n        };\n        Grid.setRow = function (node, value) {\n            node.setAttached(\"grid.row\", value);\n            invalidateCell(node);\n        };\n        Grid.getRowSpan = function (node) {\n            return node.getAttached(\"grid.row-span\");\n        };\n        Grid.setRowSpan = function (node, value) {\n            node.setAttached(\"grid.row-span\", value);\n            invalidateCell(node);\n        };\n        Grid.prototype.init = function () {\n            _super.prototype.init.call(this);\n            this.$measureOverride = mirage.grid.NewGridMeasureOverride(this.inputs, this.state, this.tree);\n            this.$arrangeOverride = mirage.grid.NewGridArrangeOverride(this.inputs, this.state, this.tree);\n        };\n        Object.defineProperty(Grid.prototype, \"rowDefinitions\", {\n            get: function () {\n                return this.inputs.rowDefinitions;\n            },\n            set: function (value) {\n                this.inputs.rowDefinitions = value;\n                this.invalidateMeasure();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Grid.prototype, \"columnDefinitions\", {\n            get: function () {\n                return this.inputs.columnDefinitions;\n            },\n            set: function (value) {\n                this.inputs.columnDefinitions = value;\n                this.invalidateMeasure();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Grid.prototype.createInputs = function () {\n            var inputs = _super.prototype.createInputs.call(this);\n            inputs.rowDefinitions = [];\n            inputs.columnDefinitions = [];\n            return inputs;\n        };\n        Grid.prototype.createState = function () {\n            var state = _super.prototype.createState.call(this);\n            state.design = mirage.grid.design.NewGridDesign();\n            return state;\n        };\n        Grid.prototype.measureOverride = function (constraint) {\n            return this.$measureOverride(constraint);\n        };\n        Grid.prototype.arrangeOverride = function (arrangeSize) {\n            return this.$arrangeOverride(arrangeSize);\n        };\n        return Grid;\n    })(mirage.Panel);\n    mirage.Grid = Grid;\n    function invalidateCell(node) {\n        var parent = node.tree.parent;\n        if (parent instanceof Grid)\n            parent.invalidateMeasure();\n        node.invalidateMeasure();\n    }\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    function NewColumnDefinitions(defs) {\n        var coldefs = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            var token = tokens[i];\n            if (token === \" \")\n                continue;\n            coldefs.push(NewColumnDefinition(token));\n        }\n        return coldefs;\n    }\n    mirage.NewColumnDefinitions = NewColumnDefinitions;\n    function NewColumnDefinition() {\n        var len;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n        switch (arguments.length) {\n            case 1:\n                len = mirage.parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = mirage.parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: mirage.GridUnitType.star,\n                };\n                break;\n        }\n        var actual = NaN;\n        return {\n            width: len,\n            minWidth: min,\n            maxWidth: max,\n            getActualWidth: function () {\n                return actual;\n            },\n            setActualWidth: function (value) {\n                actual = value;\n            },\n        };\n    }\n    mirage.NewColumnDefinition = NewColumnDefinition;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    (function (GridUnitType) {\n        GridUnitType[GridUnitType[\"auto\"] = 0] = \"auto\";\n        GridUnitType[GridUnitType[\"pixel\"] = 1] = \"pixel\";\n        GridUnitType[GridUnitType[\"star\"] = 2] = \"star\";\n    })(mirage.GridUnitType || (mirage.GridUnitType = {}));\n    var GridUnitType = mirage.GridUnitType;\n    function parseGridLength(s) {\n        var auto = { value: 0, type: GridUnitType.auto };\n        if (s === \"auto\") {\n            return auto;\n        }\n        if (s[s.length - 1] === \"*\") {\n            if (s.length === 1)\n                return { value: 1, type: GridUnitType.star };\n            return {\n                value: parseInt(s.substr(0, s.length - 1)),\n                type: GridUnitType.star,\n            };\n        }\n        return {\n            value: parseInt(s),\n            type: GridUnitType.pixel,\n        };\n    }\n    mirage.parseGridLength = parseGridLength;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    function NewRowDefinitions(defs) {\n        var rowdefs = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            var token = tokens[i];\n            if (token === \" \")\n                continue;\n            rowdefs.push(NewRowDefinition(token));\n        }\n        return rowdefs;\n    }\n    mirage.NewRowDefinitions = NewRowDefinitions;\n    function NewRowDefinition() {\n        var len;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n        switch (arguments.length) {\n            case 1:\n                len = mirage.parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = mirage.parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: mirage.GridUnitType.star,\n                };\n                break;\n        }\n        var actual = NaN;\n        return {\n            height: len,\n            minHeight: min,\n            maxHeight: max,\n            getActualHeight: function () {\n                return actual;\n            },\n            setActualHeight: function (value) {\n                actual = value;\n            },\n        };\n    }\n    mirage.NewRowDefinition = NewRowDefinition;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var Point = (function () {\n        function Point(x, y) {\n            this.x = x == null ? 0 : x;\n            this.y = y == null ? 0 : y;\n        }\n        Point.isEqual = function (p1, p2) {\n            return p1.x === p2.x\n                && p1.y === p2.y;\n        };\n        Point.copyTo = function (src, dest) {\n            dest.x = src.x;\n            dest.y = src.y;\n        };\n        Point.round = function (dest) {\n            dest.x = Math.round(dest.x);\n            dest.y = Math.round(dest.y);\n        };\n        return Point;\n    })();\n    mirage.Point = Point;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    (function (RectOverlap) {\n        RectOverlap[RectOverlap[\"outside\"] = 0] = \"outside\";\n        RectOverlap[RectOverlap[\"inside\"] = 1] = \"inside\";\n        RectOverlap[RectOverlap[\"part\"] = 2] = \"part\";\n    })(mirage.RectOverlap || (mirage.RectOverlap = {}));\n    var RectOverlap = mirage.RectOverlap;\n    var Rect = (function () {\n        function Rect(x, y, width, height) {\n            this.x = x == null ? 0 : x;\n            this.y = y == null ? 0 : y;\n            this.width = width == null ? 0 : width;\n            this.height = height == null ? 0 : height;\n        }\n        Rect.clear = function (rect) {\n            rect.x = rect.y = rect.width = rect.height = 0;\n        };\n        Rect.getBottom = function (rect) {\n            return rect.y + rect.height;\n        };\n        Rect.getRight = function (rect) {\n            return rect.x + rect.width;\n        };\n        Rect.isEqual = function (rect1, rect2) {\n            return rect1.x === rect2.x\n                && rect1.y === rect2.y\n                && rect1.width === rect2.width\n                && rect1.height === rect2.height;\n        };\n        Rect.isEmpty = function (src) {\n            return src.width === 0\n                || src.height === 0;\n        };\n        Rect.copyTo = function (src, dest) {\n            dest.x = src.x;\n            dest.y = src.y;\n            dest.width = src.width;\n            dest.height = src.height;\n        };\n        Rect.roundOut = function (dest) {\n            var x = Math.floor(dest.x);\n            var y = Math.floor(dest.y);\n            dest.width = Math.ceil(dest.x + dest.width) - x;\n            dest.height = Math.ceil(dest.y + dest.height) - y;\n            dest.x = x;\n            dest.y = y;\n        };\n        Rect.roundIn = function (dest) {\n            var x = Math.ceil(dest.x);\n            var y = Math.ceil(dest.y);\n            dest.width = Math.floor(dest.x + dest.width) - Math.ceil(dest.x);\n            dest.height = Math.floor(dest.y + dest.height) - Math.ceil(dest.y);\n            dest.x = x;\n            dest.y = y;\n            return dest;\n        };\n        Rect.intersection = function (dest, rect2) {\n            var x = Math.max(dest.x, rect2.x);\n            var y = Math.max(dest.y, rect2.y);\n            dest.width = Math.max(0, Math.min(dest.x + dest.width, rect2.x + rect2.width) - x);\n            dest.height = Math.max(0, Math.min(dest.y + dest.height, rect2.y + rect2.height) - y);\n            dest.x = x;\n            dest.y = y;\n        };\n        Rect.union = function (dest, rect2) {\n            if (rect2.width <= 0 || rect2.height <= 0)\n                return;\n            if (dest.width <= 0 || dest.height <= 0) {\n                Rect.copyTo(rect2, dest);\n                return;\n            }\n            var x = Math.min(dest.x, rect2.x);\n            var y = Math.min(dest.y, rect2.y);\n            dest.width = Math.max(dest.x + dest.width, rect2.x + rect2.width) - x;\n            dest.height = Math.max(dest.y + dest.height, rect2.y + rect2.height) - y;\n            dest.x = x;\n            dest.y = y;\n        };\n        Rect.isContainedIn = function (src, test) {\n            var sl = src.x;\n            var st = src.y;\n            var sr = src.x + src.width;\n            var sb = src.y + src.height;\n            var tl = test.x;\n            var tt = test.y;\n            var tr = test.x + test.width;\n            var tb = test.y + test.height;\n            if (sl < tl || st < tt || sl > tr || st > tb)\n                return false;\n            if (sr < tl || sb < tt || sr > tr || sb > tb)\n                return false;\n            return true;\n        };\n        Rect.containsPoint = function (rect1, p) {\n            return rect1.x <= p.x\n                && rect1.y <= p.y\n                && (rect1.x + rect1.width) >= p.x\n                && (rect1.y + rect1.height) >= p.y;\n        };\n        Rect.extendTo = function (dest, x, y) {\n            var rx = dest.x;\n            var ry = dest.y;\n            var rw = dest.width;\n            var rh = dest.height;\n            if (x < rx || x > (rx + rw))\n                rw = Math.max(Math.abs(x - rx), Math.abs(x - rx - rw));\n            if (y < ry || y > (ry + rh))\n                rh = Math.max(Math.abs(y - ry), Math.abs(y - ry - rh));\n            dest.x = Math.min(rx, x);\n            dest.y = Math.min(ry, y);\n            dest.width = rw;\n            dest.height = rh;\n        };\n        Rect.grow = function (dest, left, top, right, bottom) {\n            dest.x -= left;\n            dest.y -= top;\n            dest.width += left + right;\n            dest.height += top + bottom;\n            if (dest.width < 0)\n                dest.width = 0;\n            if (dest.height < 0)\n                dest.height = 0;\n            return dest;\n        };\n        Rect.shrink = function (dest, left, top, right, bottom) {\n            dest.x += left;\n            dest.y += top;\n            dest.width -= left + right;\n            dest.height -= top + bottom;\n            if (dest.width < 0)\n                dest.width = 0;\n            if (dest.height < 0)\n                dest.height = 0;\n        };\n        Rect.rectIn = function (rect1, rect2) {\n            var copy = new Rect();\n            Rect.copyTo(rect1, copy);\n            Rect.intersection(copy, rect2);\n            if (Rect.isEmpty(copy))\n                return RectOverlap.outside;\n            if (Rect.isEqual(copy, rect2))\n                return RectOverlap.inside;\n            return RectOverlap.part;\n        };\n        return Rect;\n    })();\n    mirage.Rect = Rect;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var Size = (function () {\n        function Size(width, height) {\n            this.width = width == null ? 0 : width;\n            this.height = height == null ? 0 : height;\n        }\n        Size.copyTo = function (src, dest) {\n            dest.width = src.width;\n            dest.height = src.height;\n        };\n        Size.isEqual = function (size1, size2) {\n            return size1.width === size2.width\n                && size1.height === size2.height;\n        };\n        Size.isEmpty = function (size) {\n            return size.width === 0\n                || size.height === 0;\n        };\n        Size.max = function (dest, size2) {\n            dest.width = Math.max(dest.width, size2.width);\n            dest.height = Math.max(dest.height, size2.height);\n        };\n        Size.min = function (dest, size2) {\n            dest.width = Math.min(dest.width, size2.width);\n            dest.height = Math.min(dest.height, size2.height);\n        };\n        Size.round = function (size) {\n            size.width = Math.round(size.width);\n            size.height = Math.round(size.height);\n        };\n        Size.isUndef = function (size) {\n            return isNaN(size.width) && isNaN(size.height);\n        };\n        Size.clear = function (size) {\n            size.width = 0;\n            size.height = 0;\n        };\n        Size.undef = function (size) {\n            size.width = NaN;\n            size.height = NaN;\n        };\n        return Size;\n    })();\n    mirage.Size = Size;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var StackPanel = (function (_super) {\n        __extends(StackPanel, _super);\n        function StackPanel() {\n            _super.apply(this, arguments);\n        }\n        Object.defineProperty(StackPanel.prototype, \"orientation\", {\n            get: function () {\n                return this.inputs.orientation;\n            },\n            set: function (value) {\n                if (this.inputs.orientation === value)\n                    return;\n                this.inputs.orientation = value;\n                this.invalidateMeasure();\n                this.invalidateArrange();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        StackPanel.prototype.createInputs = function () {\n            var inputs = _super.prototype.createInputs.call(this);\n            inputs.orientation = mirage.Orientation.horizontal;\n            return inputs;\n        };\n        StackPanel.prototype.measureOverride = function (constraint) {\n            if (this.inputs.orientation === mirage.Orientation.vertical) {\n                return this.measureVertical(constraint);\n            }\n            else {\n                return this.measureHorizontal(constraint);\n            }\n        };\n        StackPanel.prototype.measureVertical = function (constraint) {\n            var ca = new mirage.Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new mirage.Size();\n            var inputs = this.inputs;\n            ca.width = constraint.width;\n            if (!isNaN(inputs.width))\n                ca.width = inputs.width;\n            ca.width = Math.min(ca.width, inputs.maxWidth);\n            ca.width = Math.max(ca.width, inputs.minWidth);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n                var childDesired = child.state.desiredSize;\n                measured.height += childDesired.height;\n                measured.width = Math.max(measured.width, childDesired.width);\n            }\n            return measured;\n        };\n        StackPanel.prototype.measureHorizontal = function (constraint) {\n            var ca = new mirage.Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new mirage.Size();\n            var inputs = this.inputs;\n            ca.height = constraint.height;\n            if (!isNaN(inputs.height))\n                ca.height = inputs.height;\n            ca.height = Math.min(ca.height, inputs.maxHeight);\n            ca.height = Math.max(ca.height, inputs.minHeight);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n                var childDesired = child.state.desiredSize;\n                measured.width += childDesired.width;\n                measured.height = Math.max(measured.height, childDesired.height);\n            }\n            return measured;\n        };\n        StackPanel.prototype.arrangeOverride = function (arrangeSize) {\n            if (this.inputs.orientation === mirage.Orientation.vertical) {\n                return this.arrangeVertical(arrangeSize);\n            }\n            else {\n                return this.arrangeHorizontal(arrangeSize);\n            }\n        };\n        StackPanel.prototype.arrangeVertical = function (arrangeSize) {\n            var arranged = new mirage.Size(arrangeSize.width, 0);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new mirage.Rect(0, arranged.height, arrangeSize.width, childDesired.height);\n                if (mirage.Rect.isEmpty(childFinal))\n                    mirage.Rect.clear(childFinal);\n                child.arrange(childFinal);\n                arranged.width = Math.max(arranged.width, arrangeSize.width);\n                arranged.height += childDesired.height;\n            }\n            arranged.height = Math.max(arranged.height, arrangeSize.height);\n            return arranged;\n        };\n        StackPanel.prototype.arrangeHorizontal = function (arrangeSize) {\n            var arranged = new mirage.Size(0, arrangeSize.height);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new mirage.Rect(arranged.width, 0, childDesired.width, arrangeSize.height);\n                if (mirage.Rect.isEmpty(childFinal))\n                    mirage.Rect.clear(childFinal);\n                child.arrange(childFinal);\n                arranged.width += childDesired.width;\n                arranged.height = Math.max(arranged.height, arrangeSize.height);\n            }\n            arranged.width = Math.max(arranged.width, arrangeSize.width);\n            return arranged;\n        };\n        return StackPanel;\n    })(mirage.Panel);\n    mirage.StackPanel = StackPanel;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var Thickness = (function () {\n        function Thickness(left, top, right, bottom) {\n            this.left = left == null ? 0 : left;\n            this.top = top == null ? 0 : top;\n            this.right = right == null ? 0 : right;\n            this.bottom = bottom == null ? 0 : bottom;\n        }\n        Thickness.add = function (dest, t2) {\n            dest.left += t2.left;\n            dest.top += t2.top;\n            dest.right += t2.right;\n            dest.bottom += t2.bottom;\n        };\n        Thickness.copyTo = function (thickness, dest) {\n            dest.left = thickness.left;\n            dest.top = thickness.top;\n            dest.right = thickness.right;\n            dest.bottom = thickness.bottom;\n        };\n        Thickness.isEmpty = function (thickness) {\n            return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;\n        };\n        Thickness.isEqual = function (t1, t2) {\n            return t1.left === t2.left\n                && t1.top === t2.top\n                && t1.right === t2.right\n                && t1.bottom === t2.bottom;\n        };\n        Thickness.isBalanced = function (thickness) {\n            return thickness.left === thickness.top\n                && thickness.left === thickness.right\n                && thickness.left === thickness.bottom;\n        };\n        Thickness.shrinkSize = function (thickness, dest) {\n            var w = dest.width;\n            var h = dest.height;\n            if (w != Number.POSITIVE_INFINITY)\n                w -= thickness.left + thickness.right;\n            if (h != Number.POSITIVE_INFINITY)\n                h -= thickness.top + thickness.bottom;\n            dest.width = w > 0 ? w : 0;\n            dest.height = h > 0 ? h : 0;\n            return dest;\n        };\n        Thickness.shrinkRect = function (thickness, dest) {\n            dest.x += thickness.left;\n            dest.y += thickness.top;\n            dest.width -= thickness.left + thickness.right;\n            dest.height -= thickness.top + thickness.bottom;\n            if (dest.width < 0)\n                dest.width = 0;\n            if (dest.height < 0)\n                dest.height = 0;\n        };\n        Thickness.shrinkCornerRadius = function (thickness, dest) {\n            dest.topLeft = Math.max(dest.topLeft - Math.max(thickness.left, thickness.top) * 0.5, 0);\n            dest.topRight = Math.max(dest.topRight - Math.max(thickness.right, thickness.top) * 0.5, 0);\n            dest.bottomRight = Math.max(dest.bottomRight - Math.max(thickness.right, thickness.bottom) * 0.5, 0);\n            dest.bottomLeft = Math.max(dest.bottomLeft - Math.max(thickness.left, thickness.bottom) * 0.5, 0);\n        };\n        Thickness.growSize = function (thickness, dest) {\n            var w = dest.width;\n            var h = dest.height;\n            if (w != Number.POSITIVE_INFINITY)\n                w += thickness.left + thickness.right;\n            if (h != Number.POSITIVE_INFINITY)\n                h += thickness.top + thickness.bottom;\n            dest.width = w > 0 ? w : 0;\n            dest.height = h > 0 ? h : 0;\n            return dest;\n        };\n        Thickness.growRect = function (thickness, dest) {\n            dest.x -= thickness.left;\n            dest.y -= thickness.top;\n            dest.width += thickness.left + thickness.right;\n            dest.height += thickness.top + thickness.bottom;\n            if (dest.width < 0)\n                dest.width = 0;\n            if (dest.height < 0)\n                dest.height = 0;\n        };\n        Thickness.growCornerRadius = function (thickness, dest) {\n            dest.topLeft = dest.topLeft ? Math.max(dest.topLeft + Math.max(thickness.left, thickness.top) * 0.5, 0) : 0;\n            dest.topRight = dest.topRight ? Math.max(dest.topRight + Math.max(thickness.right, thickness.top) * 0.5, 0) : 0;\n            dest.bottomRight = dest.bottomRight ? Math.max(dest.bottomRight + Math.max(thickness.right, thickness.bottom) * 0.5, 0) : 0;\n            dest.bottomLeft = dest.bottomLeft ? Math.max(dest.bottomLeft + Math.max(thickness.left, thickness.bottom) * 0.5, 0) : 0;\n        };\n        return Thickness;\n    })();\n    mirage.Thickness = Thickness;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function NewArrangeBinder(state, tree, arranger) {\n            return function () {\n                var last = state.layoutSlot || undefined;\n                if (!tree.parent)\n                    last = new mirage.Rect();\n                if (last) {\n                    return arranger(last);\n                }\n                else if (tree.parent) {\n                    tree.parent.invalidateArrange();\n                }\n                return false;\n            };\n        }\n        core.NewArrangeBinder = NewArrangeBinder;\n        function NewSpecialArrangeBinder(node, arranger) {\n            var state = node.state;\n            var tree = node.tree;\n            function expandViewport(viewport) {\n            }\n            function shiftViewport(viewport) {\n            }\n            return function () {\n                var last = state.layoutSlot || undefined;\n                if (!tree.parent) {\n                    last = new mirage.Rect();\n                    expandViewport(last);\n                    shiftViewport(last);\n                }\n                if (last) {\n                    return arranger(last);\n                }\n                else if (tree.parent) {\n                    tree.parent.invalidateArrange();\n                }\n                return false;\n            };\n        }\n        core.NewSpecialArrangeBinder = NewSpecialArrangeBinder;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function NewArranger(inputs, state, tree, override) {\n            return function (finalRect) {\n                if (inputs.visible !== true) {\n                    return false;\n                }\n                var childRect = new mirage.Rect();\n                if (inputs.useLayoutRounding) {\n                    childRect.x = Math.round(finalRect.x);\n                    childRect.y = Math.round(finalRect.y);\n                    childRect.width = Math.round(finalRect.width);\n                    childRect.height = Math.round(finalRect.height);\n                }\n                else {\n                    mirage.Rect.copyTo(finalRect, childRect);\n                }\n                if (childRect.width < 0 || childRect.height < 0\n                    || !isFinite(childRect.width) || !isFinite(childRect.height)\n                    || isNaN(childRect.x) || isNaN(childRect.y)\n                    || isNaN(childRect.width) || isNaN(childRect.height)) {\n                    console.warn(\"[mirage] cannot call arrange using rect with NaN/infinite values.\");\n                    return false;\n                }\n                if ((state.flags & core.LayoutFlags.arrange) <= 0) {\n                    return false;\n                }\n                if (mirage.Rect.isEqual(state.layoutSlot, childRect)) {\n                    return false;\n                }\n                mirage.Rect.copyTo(childRect, state.layoutSlot);\n                mirage.Thickness.shrinkRect(inputs.margin, childRect);\n                var stretched = new mirage.Size(childRect.width, childRect.height);\n                core.coerceSize(stretched, inputs);\n                var framework = new mirage.Size();\n                core.coerceSize(framework, inputs);\n                if (inputs.horizontalAlignment === mirage.HorizontalAlignment.stretch) {\n                    framework.width = Math.max(framework.width, stretched.width);\n                }\n                if (inputs.verticalAlignment === mirage.VerticalAlignment.stretch) {\n                    framework.height = Math.max(framework.height, stretched.height);\n                }\n                var offer = new mirage.Size(state.hiddenDesire.width, state.hiddenDesire.height);\n                mirage.Size.max(offer, framework);\n                var arranged = override(offer);\n                state.flags &= ~core.LayoutFlags.arrange;\n                if (inputs.useLayoutRounding) {\n                    mirage.Size.round(arranged);\n                }\n                var constrained = new mirage.Size(arranged.width, arranged.height);\n                core.coerceSize(constrained, inputs);\n                mirage.Size.min(constrained, arranged);\n                var as = state.arrangedSlot;\n                mirage.Point.copyTo(childRect, as);\n                switch (inputs.horizontalAlignment) {\n                    case mirage.HorizontalAlignment.left:\n                        break;\n                    case mirage.HorizontalAlignment.right:\n                        as.x += childRect.width - constrained.width;\n                        break;\n                    case mirage.HorizontalAlignment.center:\n                        as.x += (childRect.width - constrained.width) * 0.5;\n                        break;\n                    default:\n                        as.x += Math.max((childRect.width - constrained.width) * 0.5, 0);\n                        break;\n                }\n                switch (inputs.verticalAlignment) {\n                    case mirage.VerticalAlignment.top:\n                        break;\n                    case mirage.VerticalAlignment.bottom:\n                        as.y += childRect.height - constrained.height;\n                        break;\n                    case mirage.VerticalAlignment.center:\n                        as.y += (childRect.height - constrained.height) * 0.5;\n                        break;\n                    default:\n                        as.y += Math.max((childRect.height - constrained.height) * 0.5, 0);\n                        break;\n                }\n                if (inputs.useLayoutRounding) {\n                    mirage.Point.round(as);\n                }\n                var oldArrange = state.arrangedSlot;\n                if (!mirage.Size.isEqual(oldArrange, arranged)) {\n                    mirage.Size.copyTo(oldArrange, state.lastArranged);\n                    state.flags |= core.LayoutFlags.sizeHint;\n                    tree.propagateFlagUp(core.LayoutFlags.sizeHint);\n                }\n                mirage.Size.copyTo(arranged, state.arrangedSlot);\n                return true;\n            };\n        }\n        core.NewArranger = NewArranger;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function DefaultLayoutTree() {\n            return {\n                isContainer: true,\n                isLayoutContainer: false,\n                parent: null,\n                applyTemplate: function () {\n                    return true;\n                },\n                propagateFlagUp: function (flag) {\n                    for (var cur = this.parent; !!cur && (cur.state.flags & flag) <= 0; cur = cur.tree.parent) {\n                        cur.state.flags |= flag;\n                    }\n                },\n                walk: function (reverse) {\n                    return {\n                        current: undefined,\n                        step: function () {\n                            return false;\n                        },\n                    };\n                },\n            };\n        }\n        core.DefaultLayoutTree = DefaultLayoutTree;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        (function (LayoutFlags) {\n            LayoutFlags[LayoutFlags[\"none\"] = 0] = \"none\";\n            LayoutFlags[LayoutFlags[\"measure\"] = 2] = \"measure\";\n            LayoutFlags[LayoutFlags[\"arrange\"] = 4] = \"arrange\";\n            LayoutFlags[LayoutFlags[\"measureHint\"] = 8] = \"measureHint\";\n            LayoutFlags[LayoutFlags[\"arrangeHint\"] = 16] = \"arrangeHint\";\n            LayoutFlags[LayoutFlags[\"sizeHint\"] = 32] = \"sizeHint\";\n            LayoutFlags[LayoutFlags[\"hints\"] = 56] = \"hints\";\n        })(core.LayoutFlags || (core.LayoutFlags = {}));\n        var LayoutFlags = core.LayoutFlags;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function NewMeasureBinder(state, tree, measurer) {\n            return function () {\n                var last = state.previousAvailable;\n                if (mirage.Size.isUndef(last) && !tree.parent && tree.isLayoutContainer)\n                    last.width = last.height = Number.POSITIVE_INFINITY;\n                var success = false;\n                if (!mirage.Size.isUndef(last)) {\n                    var old = new mirage.Size();\n                    mirage.Size.copyTo(state.desiredSize, old);\n                    success = measurer(last);\n                    if (mirage.Size.isEqual(old, state.desiredSize))\n                        return success;\n                }\n                if (tree.parent)\n                    tree.parent.invalidateMeasure();\n                state.flags &= ~core.LayoutFlags.measure;\n                return success;\n            };\n        }\n        core.NewMeasureBinder = NewMeasureBinder;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function NewMeasurer(inputs, state, tree, override) {\n            return function (availableSize) {\n                if (isNaN(availableSize.width) || isNaN(availableSize.height)) {\n                    console.warn(\"[mirage] cannot call measure using a size with NaN values.\");\n                    return false;\n                }\n                if (inputs.visible !== true) {\n                    return false;\n                }\n                tree.applyTemplate();\n                if ((state.flags & core.LayoutFlags.measure) <= 0) {\n                    return false;\n                }\n                var pc = state.previousAvailable;\n                if (!mirage.Size.isUndef(pc) && pc.width === availableSize.width && pc.height === availableSize.height) {\n                    return false;\n                }\n                state.flags |= (core.LayoutFlags.arrange | core.LayoutFlags.arrangeHint);\n                var framedSize = new mirage.Size(availableSize.width, availableSize.height);\n                mirage.Thickness.shrinkSize(inputs.margin, framedSize);\n                core.coerceSize(framedSize, inputs);\n                var desired = override(framedSize);\n                state.flags &= ~core.LayoutFlags.measure;\n                mirage.Size.copyTo(desired, state.hiddenDesire);\n                core.coerceSize(desired, inputs);\n                mirage.Thickness.growSize(inputs.margin, desired);\n                desired.width = Math.min(desired.width, availableSize.width);\n                desired.height = Math.min(desired.height, availableSize.height);\n                if (inputs.useLayoutRounding) {\n                    mirage.Size.round(desired);\n                }\n                mirage.Size.copyTo(desired, state.desiredSize);\n                return true;\n            };\n        }\n        core.NewMeasurer = NewMeasurer;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function coerceSize(size, inputs) {\n            var cw = Math.max(inputs.minWidth, size.width);\n            var ch = Math.max(inputs.minHeight, size.height);\n            if (!isNaN(inputs.width))\n                cw = inputs.width;\n            if (!isNaN(inputs.height))\n                ch = inputs.height;\n            cw = Math.max(Math.min(cw, inputs.maxWidth), inputs.minWidth);\n            ch = Math.max(Math.min(ch, inputs.maxHeight), inputs.minHeight);\n            if (inputs.useLayoutRounding) {\n                cw = Math.round(cw);\n                ch = Math.round(ch);\n            }\n            size.width = cw;\n            size.height = ch;\n        }\n        core.coerceSize = coerceSize;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        function NewArrangeDrafter(node) {\n            var arrangeList = [];\n            return {\n                flush: function () {\n                    var cur;\n                    while ((cur = arrangeList.shift()) != null) {\n                        cur.tree.propagateFlagUp(LayoutFlags.arrangeHint);\n                    }\n                },\n                prepare: function () {\n                    for (var walker = node.walkDeep(); walker.step();) {\n                        var cur = walker.current;\n                        if (!cur.inputs.visible) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        if ((cur.state.flags & LayoutFlags.arrangeHint) === 0) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        cur.state.flags &= ~LayoutFlags.arrangeHint;\n                        if ((cur.state.flags & LayoutFlags.arrange) > 0) {\n                            arrangeList.push(cur);\n                        }\n                    }\n                    return arrangeList.length > 0;\n                },\n                draft: function () {\n                    var cur;\n                    while ((cur = arrangeList.shift()) != null) {\n                        cur.doArrange();\n                    }\n                    return true;\n                },\n            };\n        }\n        draft.NewArrangeDrafter = NewArrangeDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        var MAX_COUNT = 255;\n        function NewDrafter(node, rootSize) {\n            var measure = draft.NewMeasureDrafter(node, rootSize);\n            var arrange = draft.NewArrangeDrafter(node);\n            var size = draft.NewSizeDrafter(node);\n            function runDraft() {\n                if (!node.inputs.visible)\n                    return false;\n                arrange.flush();\n                size.flush();\n                var flags = node.state.flags;\n                if ((flags & LayoutFlags.measureHint) > 0) {\n                    return measure.prepare()\n                        && measure.draft();\n                }\n                if ((flags & LayoutFlags.arrangeHint) > 0) {\n                    return arrange.prepare()\n                        && arrange.draft();\n                }\n                if ((flags & LayoutFlags.sizeHint) > 0) {\n                    return size.prepare()\n                        && size.draft()\n                        && size.notify();\n                }\n                return false;\n            }\n            return function () {\n                if ((node.state.flags & LayoutFlags.hints) === 0)\n                    return false;\n                var updated = false;\n                for (var count = 0; count < MAX_COUNT; count++) {\n                    if (!runDraft())\n                        break;\n                    updated = true;\n                }\n                if (count >= MAX_COUNT) {\n                    console.error(\"[mirage] aborting infinite draft\");\n                }\n                return updated;\n            };\n        }\n        draft.NewDrafter = NewDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        function NewMeasureDrafter(node, rootSize) {\n            var measureList = [];\n            return {\n                prepare: function () {\n                    var last = node.state.previousAvailable;\n                    if (node.tree.isContainer && (mirage.Size.isUndef(last) || !mirage.Size.isEqual(last, rootSize))) {\n                        node.state.flags |= LayoutFlags.measure;\n                        mirage.Size.copyTo(rootSize, node.state.previousAvailable);\n                    }\n                    for (var walker = node.walkDeep(); walker.step();) {\n                        var cur = walker.current;\n                        if (!cur.inputs.visible) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        if ((cur.state.flags & LayoutFlags.measureHint) === 0) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        cur.state.flags &= ~LayoutFlags.measureHint;\n                        if ((cur.state.flags & LayoutFlags.measure) > 0) {\n                            measureList.push(cur);\n                        }\n                    }\n                    return measureList.length > 0;\n                },\n                draft: function () {\n                    var cur;\n                    while ((cur = measureList.shift()) != null) {\n                        cur.doMeasure();\n                    }\n                    return true;\n                },\n            };\n        }\n        draft.NewMeasureDrafter = NewMeasureDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        function NewSizeDrafter(node) {\n            var sizingList = [];\n            var sizingUpdates = [];\n            return {\n                flush: function () {\n                    var cur;\n                    while ((cur = sizingList.shift()) != null) {\n                        cur.tree.propagateFlagUp(LayoutFlags.sizeHint);\n                    }\n                },\n                prepare: function () {\n                    for (var walker = node.walkDeep(); walker.step();) {\n                        var cur = walker.current;\n                        if (!cur.inputs.visible) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        if ((cur.state.flags & LayoutFlags.sizeHint) === 0) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        cur.state.flags &= ~LayoutFlags.sizeHint;\n                        if (cur.state.lastArranged !== undefined) {\n                            sizingList.push(cur);\n                        }\n                    }\n                    return sizingList.length > 0;\n                },\n                draft: function () {\n                    var oldSize = new mirage.Size();\n                    var newSize = new mirage.Size();\n                    var cur;\n                    while ((cur = sizingList.pop()) != null) {\n                        cur.sizing(oldSize, newSize);\n                        if (!mirage.Size.isEqual(oldSize, newSize)) {\n                            sizingUpdates.push({\n                                node: cur,\n                                oldSize: oldSize,\n                                newSize: newSize,\n                            });\n                            oldSize = new mirage.Size();\n                            newSize = new mirage.Size();\n                        }\n                    }\n                    return sizingUpdates.length > 0;\n                },\n                notify: function () {\n                    var update;\n                    while ((update = sizingUpdates.pop()) != null) {\n                        update.node.onSizeChanged(update.oldSize, update.newSize);\n                    }\n                    return true;\n                }\n            };\n        }\n        draft.NewSizeDrafter = NewSizeDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        function NewGridArrangeOverride(inputs, state, tree) {\n            var des = state.design.arrange;\n            return function (arrangeSize) {\n                des.init(arrangeSize, inputs.columnDefinitions, inputs.rowDefinitions);\n                var cr = new mirage.Rect();\n                for (var walker = tree.walk(); walker.step();) {\n                    var child = walker.current;\n                    des.calcChildRect(cr, child);\n                    child.arrange(cr);\n                }\n                return new mirage.Size(arrangeSize.width, arrangeSize.height);\n            };\n        }\n        grid.NewGridArrangeOverride = NewGridArrangeOverride;\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        function NewGridMeasureOverride(inputs, state, tree) {\n            var des = state.design.measure;\n            var overrideAutoAuto = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.autoAuto, des, tree);\n            var overrideStarAuto = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.starAuto, des, tree);\n            var overrideAutoStar = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.autoStar, des, tree);\n            var overrideStarAuto2 = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.starAutoAgain, des, tree);\n            var overrideNonStar = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.nonStar, des, tree);\n            var overrideRemainingStar = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.remainingStar, des, tree);\n            return function (constraint) {\n                des.init(constraint, inputs.columnDefinitions, inputs.rowDefinitions, tree);\n                overrideAutoAuto();\n                overrideStarAuto();\n                overrideAutoStar();\n                overrideStarAuto2();\n                overrideNonStar();\n                overrideRemainingStar();\n                des.finish();\n                return des.getDesired();\n            };\n        }\n        grid.NewGridMeasureOverride = NewGridMeasureOverride;\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridArrangeDesign(cm, rm) {\n                return {\n                    init: function (arrangeSize, coldefs, rowdefs) {\n                        originalToOffered(cm);\n                        originalToOffered(rm);\n                        var consumed = new mirage.Size(design.helpers.calcDesiredToOffered(cm), design.helpers.calcDesiredToOffered(rm));\n                        if (consumed.width !== arrangeSize.width) {\n                            design.helpers.expand(arrangeSize.width, cm);\n                        }\n                        if (consumed.height !== arrangeSize.height) {\n                            design.helpers.expand(arrangeSize.height, rm);\n                        }\n                        if (!!coldefs) {\n                            for (var i = 0; i < coldefs.length; i++) {\n                                coldefs[i].setActualWidth(cm[i][i].offered);\n                            }\n                        }\n                        if (!!rowdefs) {\n                            for (var i = 0; i < rowdefs.length; i++) {\n                                rowdefs[i].setActualHeight(rm[i][i].offered);\n                            }\n                        }\n                    },\n                    calcChildRect: function (childRect, child) {\n                        mirage.Rect.clear(childRect);\n                        var col = mirage.Grid.getColumn(child) || 0;\n                        col = Math.min(col, cm.length - 1);\n                        var colspan = mirage.Grid.getColumnSpan(child);\n                        if (colspan !== 0)\n                            colspan = colspan || 1;\n                        colspan = Math.min(colspan, cm.length - col);\n                        var row = mirage.Grid.getRow(child) || 0;\n                        row = Math.min(row, rm.length - 1);\n                        var rowspan = mirage.Grid.getRowSpan(child);\n                        if (rowspan !== 0)\n                            rowspan = rowspan || 1;\n                        rowspan = Math.min(rowspan, rm.length - row);\n                        for (var i = 0; i < col; i++) {\n                            childRect.x += cm[i][i].offered;\n                        }\n                        for (var i = col; i < col + colspan; i++) {\n                            childRect.width += cm[i][i].offered;\n                        }\n                        for (var i = 0; i < row; i++) {\n                            childRect.y += rm[i][i].offered;\n                        }\n                        for (var i = row; i < row + rowspan; i++) {\n                            childRect.height += rm[i][i].offered;\n                        }\n                    },\n                };\n            }\n            design.NewGridArrangeDesign = NewGridArrangeDesign;\n            function originalToOffered(matrix) {\n                for (var i = 0; i < matrix.length; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        matrix[i][j].offered = matrix[i][j].original;\n                    }\n                }\n            }\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridPlacement(cm, rm) {\n                var unicells = [];\n                var multicells = [];\n                return {\n                    init: function () {\n                        unicells.length = 0;\n                        multicells.length = 0;\n                    },\n                    add: function (isRow, start, span, size) {\n                        var item = {\n                            matrix: isRow ? rm : cm,\n                            start: start,\n                            end: start + span - 1,\n                            size: size,\n                        };\n                        if (item.start === item.end) {\n                            unicells.unshift(item);\n                        }\n                        else {\n                            multicells.push(item);\n                        }\n                    },\n                    allocate: function (allocFunc) {\n                        var cell;\n                        while ((cell = unicells.pop()) != null) {\n                            var i = cell.start;\n                            var j = cell.end;\n                            cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                            allocFunc();\n                        }\n                        while ((cell = multicells.pop()) != null) {\n                            var i = cell.start;\n                            var j = cell.end;\n                            cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                            allocFunc();\n                        }\n                    },\n                };\n            }\n            design.NewGridPlacement = NewGridPlacement;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridShape(childShapes) {\n                var hasAutoAuto = false;\n                var hasStarAuto = false;\n                var hasAutoStar = false;\n                for (var i = 0; i < childShapes.length; i++) {\n                    var cs = childShapes[i];\n                    hasAutoAuto = hasAutoAuto || (cs.autoRow && cs.autoCol && !cs.starRow && !cs.starCol);\n                    hasStarAuto = hasStarAuto || (cs.starRow && cs.autoCol);\n                    hasAutoStar = hasAutoStar || (cs.autoRow && cs.starCol);\n                }\n                return {\n                    hasAutoAuto: hasAutoAuto,\n                    hasStarAuto: hasStarAuto,\n                    hasAutoStar: hasAutoStar,\n                };\n            }\n            design.NewGridShape = NewGridShape;\n            var GridChildShape = (function () {\n                function GridChildShape() {\n                }\n                GridChildShape.prototype.init = function (child, cm, rm) {\n                    var col = this.col = Math.min(mirage.Grid.getColumn(child), cm.length - 1);\n                    if (isNaN(col))\n                        this.col = col = 0;\n                    var row = this.row = Math.min(mirage.Grid.getRow(child), rm.length - 1);\n                    if (isNaN(row))\n                        this.row = row = 0;\n                    var colspan = this.colspan = Math.min(mirage.Grid.getColumnSpan(child), cm.length - col);\n                    if (isNaN(colspan))\n                        this.colspan = colspan = 1;\n                    var rowspan = this.rowspan = Math.min(mirage.Grid.getRowSpan(child), rm.length - row);\n                    if (isNaN(rowspan))\n                        this.rowspan = rowspan = 1;\n                    this.starRow = this.autoRow = this.starCol = this.autoCol = false;\n                    for (var i = row; i < row + rowspan; i++) {\n                        this.starRow = this.starRow || (rm[i][i].type === mirage.GridUnitType.star);\n                        this.autoRow = this.autoRow || (rm[i][i].type === mirage.GridUnitType.auto);\n                    }\n                    for (var i = col; i < col + colspan; i++) {\n                        this.starCol = this.starCol || (cm[i][i].type === mirage.GridUnitType.star);\n                        this.autoCol = this.autoCol || (cm[i][i].type === mirage.GridUnitType.auto);\n                    }\n                };\n                GridChildShape.prototype.shouldMeasurePass = function (gridShape, childSize, pass) {\n                    childSize.width = childSize.height = 0;\n                    if (this.autoRow && this.autoCol && !this.starRow && !this.starCol) {\n                        if (pass !== design.MeasureOverridePass.autoAuto)\n                            return false;\n                        childSize.width = Number.POSITIVE_INFINITY;\n                        childSize.height = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if (this.starRow && this.autoCol && !this.starCol) {\n                        if (pass !== design.MeasureOverridePass.starAuto && pass !== design.MeasureOverridePass.starAutoAgain)\n                            return false;\n                        if (pass === design.MeasureOverridePass.autoAuto && gridShape.hasAutoStar)\n                            childSize.height = Number.POSITIVE_INFINITY;\n                        childSize.width = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if (this.autoRow && this.starCol && !this.starRow) {\n                        if (pass !== design.MeasureOverridePass.autoStar)\n                            return false;\n                        childSize.height = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if ((this.autoRow || this.autoCol) && !(this.starRow || this.starCol)) {\n                        if (pass !== design.MeasureOverridePass.nonStar)\n                            return false;\n                        if (this.autoRow)\n                            childSize.height = Number.POSITIVE_INFINITY;\n                        if (this.autoCol)\n                            childSize.width = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if (!(this.starRow || this.starCol))\n                        return pass === design.MeasureOverridePass.nonStar;\n                    return pass === design.MeasureOverridePass.remainingStar;\n                };\n                GridChildShape.prototype.calcConstraint = function (childSize, cm, rm) {\n                    for (var i = this.row; i < this.row + this.rowspan; i++) {\n                        childSize.height += rm[i][i].offered;\n                    }\n                    for (var i = this.col; i < this.col + this.colspan; i++) {\n                        childSize.width += cm[i][i].offered;\n                    }\n                };\n                return GridChildShape;\n            })();\n            design.GridChildShape = GridChildShape;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            var helpers;\n            (function (helpers) {\n                function expand(available, mat) {\n                    for (var i = 0; i < mat.length; i++) {\n                        var cur = mat[i][i];\n                        if (cur.type === mirage.GridUnitType.star)\n                            cur.offered = 0;\n                        else\n                            available = Math.max(available - cur.offered, 0);\n                    }\n                    assignSize(mat, 0, mat.length - 1, available, mirage.GridUnitType.star, false);\n                }\n                helpers.expand = expand;\n                function assignSize(mat, start, end, size, unitType, desiredSize) {\n                    var count = 0;\n                    var assigned = false;\n                    var segmentSize = 0;\n                    for (var i = start; i <= end; i++) {\n                        var cur = mat[i][i];\n                        segmentSize = desiredSize ? cur.desired : cur.offered;\n                        if (segmentSize < cur.max)\n                            count += (unitType === mirage.GridUnitType.star) ? cur.stars : 1;\n                    }\n                    do {\n                        assigned = false;\n                        var contribution = size / count;\n                        for (var i = start; i <= end; i++) {\n                            var cur = mat[i][i];\n                            segmentSize = desiredSize ? cur.desired : cur.offered;\n                            if (!(cur.type === unitType && segmentSize < cur.max))\n                                continue;\n                            var newSize = segmentSize;\n                            newSize += contribution * (unitType === mirage.GridUnitType.star ? cur.stars : 1);\n                            newSize = Math.min(newSize, cur.max);\n                            assigned = assigned || (newSize > segmentSize);\n                            size -= newSize - segmentSize;\n                            if (desiredSize)\n                                cur.desired = newSize;\n                            else\n                                cur.offered = newSize;\n                        }\n                    } while (assigned);\n                    return size;\n                }\n                helpers.assignSize = assignSize;\n                function calcDesiredToOffered(matrix) {\n                    var total = 0;\n                    for (var i = 0; i < matrix.length; i++) {\n                        total += (matrix[i][i].offered = matrix[i][i].desired);\n                    }\n                    return total;\n                }\n                helpers.calcDesiredToOffered = calcDesiredToOffered;\n            })(helpers = design.helpers || (design.helpers = {}));\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridDesign() {\n                var cm = [];\n                var rm = [];\n                return {\n                    measure: design.NewGridMeasureDesign(cm, rm),\n                    arrange: design.NewGridArrangeDesign(cm, rm),\n                };\n            }\n            design.NewGridDesign = NewGridDesign;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridMeasureDesign(cm, rm) {\n                var shape;\n                var childShapes = [];\n                var placement = design.NewGridPlacement(cm, rm);\n                return {\n                    init: function (constraint, coldefs, rowdefs, tree) {\n                        ensureMatrix(cm, !coldefs ? 1 : coldefs.length || 1);\n                        ensureMatrix(rm, !rowdefs ? 1 : rowdefs.length || 1);\n                        prepareCols(cm, coldefs);\n                        prepareRows(rm, rowdefs);\n                        var i = 0;\n                        for (var walker = tree.walk(); walker.step(); i++) {\n                            var childShape;\n                            if (i < childShapes.length) {\n                                childShapes[i] = childShapes[i] || new design.GridChildShape();\n                            }\n                            else {\n                                childShapes.push(childShape = new design.GridChildShape());\n                            }\n                            childShape.init(walker.current, cm, rm);\n                        }\n                        if (i < childShapes.length)\n                            childShapes.slice(i, childShapes.length - i);\n                        shape = design.NewGridShape(childShapes);\n                        placement.init();\n                        if (tree.children.length > 0) {\n                            design.helpers.expand(constraint.width, cm);\n                            design.helpers.expand(constraint.height, rm);\n                        }\n                    },\n                    measureChild: function (pass, index, child) {\n                        var childShape = childShapes[index];\n                        var childSize = new mirage.Size();\n                        if (!childShape || !childShape.shouldMeasurePass(shape, childSize, pass))\n                            return;\n                        childShape.calcConstraint(childSize, cm, rm);\n                        child.measure(childSize);\n                        var desired = child.state.desiredSize;\n                        if (pass !== design.MeasureOverridePass.starAuto)\n                            placement.add(true, childShape.row, childShape.rowspan, desired.height);\n                        placement.add(false, childShape.col, childShape.colspan, desired.width);\n                    },\n                    finishPass: function () {\n                        placement.allocate(allocateDesiredSizeFunc(cm, rm));\n                    },\n                    finish: function () {\n                        for (var i = 0; i < cm.length; i++) {\n                            for (var j = 0; j <= i; j++) {\n                                cm[i][j].original = cm[i][j].offered;\n                            }\n                        }\n                        for (var i = 0; i < rm.length; i++) {\n                            for (var j = 0; j <= i; j++) {\n                                rm[i][j].original = rm[i][j].offered;\n                            }\n                        }\n                    },\n                    getDesired: function () {\n                        var desired = new mirage.Size();\n                        for (var i = 0; i < cm.length; i++) {\n                            desired.width += cm[i][i].desired;\n                        }\n                        for (var i = 0; i < rm.length; i++) {\n                            desired.height += rm[i][i].desired;\n                        }\n                        return desired;\n                    },\n                };\n            }\n            design.NewGridMeasureDesign = NewGridMeasureDesign;\n            var DEFAULT_GRID_LEN = {\n                value: 1.0,\n                type: mirage.GridUnitType.star\n            };\n            function ensureMatrix(matrix, defCount) {\n                if (matrix.length > defCount)\n                    matrix.splice(defCount, matrix.length - defCount);\n                for (var i = 0; i < defCount; i++) {\n                    if (matrix.length <= i)\n                        matrix.push([]);\n                    var mrow = matrix[i];\n                    if (mrow.length > (i + 1))\n                        mrow.splice(i, mrow.length - i - 1);\n                    for (var ii = 0; ii <= i; ii++) {\n                        if (mrow.length <= ii)\n                            mrow.push(new design.Segment());\n                        else\n                            design.Segment.init(mrow[ii]);\n                    }\n                }\n            }\n            function prepareCols(cm, coldefs) {\n                if (!coldefs || coldefs.length === 0) {\n                    var mcell = cm[0][0];\n                    mcell.type = mirage.GridUnitType.star;\n                    mcell.stars = 1.0;\n                    return;\n                }\n                for (var i = 0; i < coldefs.length; i++) {\n                    var colDef = coldefs[i];\n                    var width = colDef.width || DEFAULT_GRID_LEN;\n                    colDef.setActualWidth(Number.POSITIVE_INFINITY);\n                    var cell = design.Segment.init(cm[i][i], 0.0, colDef.minWidth, colDef.maxWidth, width.type);\n                    if (width.type === mirage.GridUnitType.pixel) {\n                        cell.desired = cell.offered = cell.clamp(width.value);\n                        colDef.setActualWidth(cell.desired);\n                    }\n                    else if (width.type === mirage.GridUnitType.star) {\n                        cell.stars = width.value;\n                    }\n                    else if (width.type === mirage.GridUnitType.auto) {\n                        cell.desired = cell.offered = cell.clamp(0);\n                    }\n                }\n            }\n            function prepareRows(rm, rowdefs) {\n                if (!rowdefs || rowdefs.length === 0) {\n                    var mcell = rm[0][0];\n                    mcell.type = mirage.GridUnitType.star;\n                    mcell.stars = 1.0;\n                    return;\n                }\n                for (var i = 0; i < rowdefs.length; i++) {\n                    var rowDef = rowdefs[i];\n                    var height = rowDef.height || DEFAULT_GRID_LEN;\n                    rowDef.setActualHeight(Number.POSITIVE_INFINITY);\n                    var cell = design.Segment.init(rm[i][i], 0.0, rowDef.minHeight, rowDef.maxHeight, height.type);\n                    if (height.type === mirage.GridUnitType.pixel) {\n                        cell.desired = cell.offered = cell.clamp(height.value);\n                        rowDef.setActualHeight(cell.desired);\n                    }\n                    else if (height.type === mirage.GridUnitType.star) {\n                        cell.stars = height.value;\n                    }\n                    else if (height.type === mirage.GridUnitType.auto) {\n                        cell.desired = cell.offered = cell.clamp(0);\n                    }\n                }\n            }\n            function allocateDesiredSizeFunc(cm, rm) {\n                function hasStarInSpan(mat, start, end) {\n                    var spansStar = false;\n                    for (var i = start; i >= end; i--) {\n                        spansStar = spansStar || mat[i][i].type === mirage.GridUnitType.star;\n                    }\n                    return spansStar;\n                }\n                function calcDesired(mat, start, end) {\n                    var total = 0;\n                    for (var i = start; i >= end; i--) {\n                        total += mat[i][i].desired;\n                    }\n                    return total;\n                }\n                function allocSegments(mat) {\n                    var count = mat.length;\n                    for (var start = count - 1; start >= 0; start--) {\n                        for (var end = start; end >= 0; end--) {\n                            var hasStar = hasStarInSpan(mat, start, end);\n                            var cur = mat[start][end].desired;\n                            var total = calcDesired(mat, start, end);\n                            var additional = cur - total;\n                            if (additional > 0) {\n                                if (hasStar) {\n                                    design.helpers.assignSize(mat, end, start, additional, mirage.GridUnitType.star, true);\n                                }\n                                else {\n                                    design.helpers.assignSize(mat, end, start, additional, mirage.GridUnitType.pixel, true);\n                                    design.helpers.assignSize(mat, end, start, additional, mirage.GridUnitType.auto, true);\n                                }\n                            }\n                        }\n                    }\n                }\n                return function () {\n                    allocSegments(rm);\n                    allocSegments(cm);\n                    design.helpers.calcDesiredToOffered(rm);\n                    design.helpers.calcDesiredToOffered(cm);\n                };\n            }\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            (function (MeasureOverridePass) {\n                MeasureOverridePass[MeasureOverridePass[\"autoAuto\"] = 0] = \"autoAuto\";\n                MeasureOverridePass[MeasureOverridePass[\"starAuto\"] = 1] = \"starAuto\";\n                MeasureOverridePass[MeasureOverridePass[\"autoStar\"] = 2] = \"autoStar\";\n                MeasureOverridePass[MeasureOverridePass[\"starAutoAgain\"] = 3] = \"starAutoAgain\";\n                MeasureOverridePass[MeasureOverridePass[\"nonStar\"] = 4] = \"nonStar\";\n                MeasureOverridePass[MeasureOverridePass[\"remainingStar\"] = 5] = \"remainingStar\";\n            })(design.MeasureOverridePass || (design.MeasureOverridePass = {}));\n            var MeasureOverridePass = design.MeasureOverridePass;\n            function NewMeasureOverridePass(pass, des, tree) {\n                return function () {\n                    for (var walker = tree.walk(), i = 0; walker.step(); i++) {\n                        des.measureChild(pass, i, walker.current);\n                    }\n                    des.finishPass();\n                };\n            }\n            design.NewMeasureOverridePass = NewMeasureOverridePass;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            var Segment = (function () {\n                function Segment() {\n                    this.desired = 0.0;\n                    this.offered = 0.0;\n                    this.original = 0.0;\n                    this.min = 0.0;\n                    this.max = Number.POSITIVE_INFINITY;\n                    this.stars = 0;\n                    this.type = mirage.GridUnitType.pixel;\n                }\n                Segment.prototype.clamp = function (value) {\n                    if (value < this.min)\n                        return this.min;\n                    if (value > this.max)\n                        return this.max;\n                    return value;\n                };\n                Segment.init = function (segment, offered, min, max, unitType) {\n                    segment.desired = 0.0;\n                    segment.stars = 0;\n                    segment.offered = offered || 0.0;\n                    segment.min = min || 0.0;\n                    segment.max = max != null ? max : Number.POSITIVE_INFINITY;\n                    segment.type = unitType != null ? unitType : mirage.GridUnitType.pixel;\n                    if (segment.offered < min)\n                        segment.offered = min;\n                    else if (segment.offered > max)\n                        segment.offered = max;\n                    return segment;\n                };\n                return Segment;\n            })();\n            design.Segment = Segment;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\n","/// <reference path=\"core/LayoutNode\" />\n\nnamespace mirage {\n    export class Panel extends core.LayoutNode {\n        tree: IPanelTree;\n\n        protected createTree(): core.ILayoutTree {\n            return NewPanelTree();\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            return new Size(constraint.width, constraint.height);\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            return new Size(arrangeSize.width, arrangeSize.height);\n        }\n\n        get childCount(): number {\n            return this.tree.children.length;\n        }\n\n        insertChild(child: core.LayoutNode, index: number) {\n            var children = this.tree.children;\n            if (index >= children.length) {\n                this.appendChild(child);\n            } else if (index <= 0) {\n                this.prependChild(child);\n            } else {\n                children.splice(index, 0, child);\n                child.setParent(this);\n            }\n        }\n\n        prependChild(child: core.LayoutNode) {\n            this.tree.children.unshift(child);\n            child.setParent(this);\n        }\n\n        appendChild(child: core.LayoutNode) {\n            this.tree.children.push(child);\n            child.setParent(this);\n        }\n\n        removeChild(child: core.LayoutNode): boolean {\n            var children = this.tree.children;\n            var index = children.indexOf(child);\n            if (index < 0)\n                return false;\n            this.tree.children.splice(index, 1);\n            child.setParent(null);\n            return true;\n        }\n\n        removeChildAt(index: number): core.LayoutNode {\n            var children = this.tree.children;\n            if (index < 0 || index >= children.length)\n                return null;\n            var removed = children.splice(index, 1)[0];\n            if (removed)\n                removed.setParent(null);\n            return removed;\n        }\n\n        getChildAt(index: number): core.LayoutNode {\n            return this.tree.children[index];\n        }\n    }\n\n    export interface IPanelTree extends core.ILayoutTree {\n        children: core.LayoutNode[];\n    }\n\n    export function NewPanelTree(): IPanelTree {\n        var tree = <IPanelTree>core.DefaultLayoutTree();\n        tree.isLayoutContainer = true;\n        tree.children = [];\n        tree.walk = (reverse?: boolean): core.ILayoutTreeWalker => {\n            if (!reverse) {\n                var i = -1;\n                return {\n                    current: undefined,\n                    step(): boolean {\n                        i++;\n                        if (i >= tree.children.length) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                };\n            } else {\n                var i = tree.children.length;\n                return {\n                    current: undefined,\n                    step(): boolean {\n                        i--;\n                        if (i < 0) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                }\n            }\n        };\n        return tree;\n    }\n}","/// <reference path=\"Panel\" />\n\nnamespace mirage {\n    export interface IGridInputs extends core.ILayoutNodeInputs {\n        rowDefinitions: IRowDefinition[];\n        columnDefinitions: IColumnDefinition[];\n    }\n\n    export interface IGridState extends core.ILayoutNodeState {\n        design: grid.design.IGridDesign;\n    }\n\n    export class Grid extends Panel {\n        static getColumn(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.column\");\n        }\n\n        static setColumn(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.column\", value);\n            invalidateCell(node);\n        }\n\n        static getColumnSpan(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.column-span\");\n        }\n\n        static setColumnSpan(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.column-span\", value);\n            invalidateCell(node);\n        }\n\n        static getRow(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.row\");\n        }\n\n        static setRow(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.row\", value);\n            invalidateCell(node);\n        }\n\n        static getRowSpan(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.row-span\");\n        }\n\n        static setRowSpan(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.row-span\", value);\n            invalidateCell(node);\n        }\n\n        inputs: IGridInputs;\n        state: IGridState;\n\n        private $measureOverride: core.IMeasureOverride;\n        private $arrangeOverride: core.IArrangeOverride;\n\n        init() {\n            super.init();\n            this.$measureOverride = grid.NewGridMeasureOverride(this.inputs, this.state, this.tree);\n            this.$arrangeOverride = grid.NewGridArrangeOverride(this.inputs, this.state, this.tree);\n        }\n\n        get rowDefinitions(): IRowDefinition[] {\n            return this.inputs.rowDefinitions;\n        }\n\n        set rowDefinitions(value: IRowDefinition[]) {\n            this.inputs.rowDefinitions = value;\n            this.invalidateMeasure();\n        }\n\n        get columnDefinitions(): IColumnDefinition[] {\n            return this.inputs.columnDefinitions;\n        }\n\n        set columnDefinitions(value: IColumnDefinition[]) {\n            this.inputs.columnDefinitions = value;\n            this.invalidateMeasure();\n        }\n\n        protected createInputs(): IGridInputs {\n            var inputs = <IGridInputs>super.createInputs();\n            inputs.rowDefinitions = [];\n            inputs.columnDefinitions = [];\n            return inputs;\n        }\n\n        protected createState(): IGridState {\n            var state = <IGridState>super.createState();\n            state.design = grid.design.NewGridDesign();\n            return state;\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            return this.$measureOverride(constraint);\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            return this.$arrangeOverride(arrangeSize);\n        }\n    }\n\n    function invalidateCell(node: core.LayoutNode) {\n        var parent = node.tree.parent;\n        if (parent instanceof Grid)\n            parent.invalidateMeasure();\n        node.invalidateMeasure();\n    }\n}","namespace mirage {\n    export interface IColumnDefinition {\n        width: IGridLength;\n        minWidth: number;\n        maxWidth: number;\n        getActualWidth(): number;\n\n        /// WARNING: This should only be used by engine\n        setActualWidth(value: number);\n    }\n\n    export function NewColumnDefinitions(defs: string): IColumnDefinition[] {\n        var coldefs: IColumnDefinition[] = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            let token = tokens[i];\n            if (token === \" \")\n                continue;\n            coldefs.push(NewColumnDefinition(token));\n        }\n        return coldefs;\n    }\n\n    export function NewColumnDefinition(): IColumnDefinition;\n    export function NewColumnDefinition(width: string): IColumnDefinition;\n    export function NewColumnDefinition(widthValue: number, widthType: GridUnitType): IColumnDefinition;\n    export function NewColumnDefinition(width: string, minWidth: number, maxWidth: number): IColumnDefinition;\n    export function NewColumnDefinition(widthValue: number, widthType: GridUnitType, minWidth: number, maxWidth: number): IColumnDefinition;\n    export function NewColumnDefinition(): IColumnDefinition {\n        var len: IGridLength;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n\n        switch (arguments.length) {\n            case 1:\n                len = parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: GridUnitType.star,\n                };\n                break;\n        }\n\n        var actual = NaN;\n        return {\n            width: len,\n            minWidth: min,\n            maxWidth: max,\n            getActualWidth(): number {\n                return actual;\n            },\n            setActualWidth(value: number) {\n                actual = value;\n            },\n        };\n    }\n}","namespace mirage {\n    export enum GridUnitType {\n        auto = 0,\n        pixel = 1,\n        star = 2,\n    }\n\n    export interface IGridLength {\n        value: number;\n        type: GridUnitType;\n    }\n\n    export function parseGridLength(s: string): IGridLength {\n        var auto = {value: 0, type: GridUnitType.auto};\n        if (s === \"auto\") {\n            return auto;\n        }\n        if (s[s.length - 1] === \"*\") {\n            if (s.length === 1)\n                return {value: 1, type: GridUnitType.star};\n            return {\n                value: parseInt(s.substr(0, s.length - 1)),\n                type: GridUnitType.star,\n            };\n        }\n        return {\n            value: parseInt(s),\n            type: GridUnitType.pixel,\n        };\n    }\n}","namespace mirage {\n    export interface IRowDefinition {\n        height: IGridLength;\n        minHeight: number;\n        maxHeight: number;\n        getActualHeight(): number;\n\n        /// WARNING: This should only be used by engine\n        setActualHeight(value: number);\n    }\n\n    export function NewRowDefinitions(defs: string): IRowDefinition[] {\n        var rowdefs: IRowDefinition[] = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            let token = tokens[i];\n            if (token === \" \")\n                continue;\n            rowdefs.push(NewRowDefinition(token));\n        }\n        return rowdefs;\n    }\n\n    export function NewRowDefinition(): IRowDefinition;\n    export function NewRowDefinition(height: string): IRowDefinition;\n    export function NewRowDefinition(heightValue: number, heightType: GridUnitType): IRowDefinition;\n    export function NewRowDefinition(height: string, minHeight: number, maxHeight: number): IRowDefinition;\n    export function NewRowDefinition(heightValue: number, heightType: GridUnitType, minHeight: number, maxHeight: number): IRowDefinition;\n    export function NewRowDefinition(): IRowDefinition {\n        var len: IGridLength;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n\n        switch (arguments.length) {\n            case 1:\n                len = parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: GridUnitType.star,\n                };\n                break;\n        }\n\n        var actual = NaN;\n        return {\n            height: len,\n            minHeight: min,\n            maxHeight: max,\n            getActualHeight(): number {\n                return actual;\n            },\n            setActualHeight(value: number) {\n                actual = value;\n            },\n        };\n    }\n}","namespace mirage {\r\n    export interface IPoint {\r\n        x: number;\r\n        y: number;\r\n    }\r\n\r\n    export class Point implements IPoint {\r\n        x: number;\r\n        y: number;\r\n\r\n        constructor(x?: number, y?: number) {\r\n            this.x = x == null ? 0 : x;\r\n            this.y = y == null ? 0 : y;\r\n        }\r\n\r\n        static isEqual(p1: IPoint, p2: IPoint): boolean {\r\n            return p1.x === p2.x\r\n                && p1.y === p2.y;\r\n        }\r\n\r\n        static copyTo(src: IPoint, dest: IPoint) {\r\n            dest.x = src.x;\r\n            dest.y = src.y;\r\n        }\r\n\r\n        static round(dest: IPoint) {\r\n            dest.x = Math.round(dest.x);\r\n            dest.y = Math.round(dest.y);\r\n        }\r\n    }\r\n}","namespace mirage {\r\n    export enum RectOverlap {\r\n        outside,\r\n        inside,\r\n        part,\r\n    }\r\n\r\n    export interface IRect extends IPoint, ISize {\r\n    }\r\n\r\n    export class Rect implements IRect {\r\n        x: number;\r\n        y: number;\r\n        width: number;\r\n        height: number;\r\n\r\n        constructor(x?: number, y?: number, width?: number, height?: number) {\r\n            this.x = x == null ? 0 : x;\r\n            this.y = y == null ? 0 : y;\r\n            this.width = width == null ? 0 : width;\r\n            this.height = height == null ? 0 : height;\r\n        }\r\n\r\n        static clear(rect: IRect) {\r\n            rect.x = rect.y = rect.width = rect.height = 0;\r\n        }\r\n\r\n        static getBottom(rect: IRect): number {\r\n            return rect.y + rect.height;\r\n        }\r\n\r\n        static getRight(rect: IRect): number {\r\n            return rect.x + rect.width;\r\n        }\r\n\r\n        static isEqual(rect1: IRect, rect2: IRect): boolean {\r\n            return rect1.x === rect2.x\r\n                && rect1.y === rect2.y\r\n                && rect1.width === rect2.width\r\n                && rect1.height === rect2.height;\r\n        }\r\n\r\n        static isEmpty(src: IRect): boolean {\r\n            return src.width === 0\r\n                || src.height === 0;\r\n        }\r\n\r\n        static copyTo(src: IRect, dest: IRect) {\r\n            dest.x = src.x;\r\n            dest.y = src.y;\r\n            dest.width = src.width;\r\n            dest.height = src.height;\r\n        }\r\n\r\n        static roundOut(dest: IRect) {\r\n            var x = Math.floor(dest.x);\r\n            var y = Math.floor(dest.y);\r\n            dest.width = Math.ceil(dest.x + dest.width) - x;\r\n            dest.height = Math.ceil(dest.y + dest.height) - y;\r\n            dest.x = x;\r\n            dest.y = y;\r\n        }\r\n\r\n        static roundIn(dest: IRect) {\r\n            var x = Math.ceil(dest.x);\r\n            var y = Math.ceil(dest.y);\r\n            dest.width = Math.floor(dest.x + dest.width) - Math.ceil(dest.x);\r\n            dest.height = Math.floor(dest.y + dest.height) - Math.ceil(dest.y);\r\n            dest.x = x;\r\n            dest.y = y;\r\n            return dest;\r\n        }\r\n\r\n        static intersection(dest: IRect, rect2: IRect) {\r\n            var x = Math.max(dest.x, rect2.x);\r\n            var y = Math.max(dest.y, rect2.y);\r\n            dest.width = Math.max(0, Math.min(dest.x + dest.width, rect2.x + rect2.width) - x);\r\n            dest.height = Math.max(0, Math.min(dest.y + dest.height, rect2.y + rect2.height) - y);\r\n            dest.x = x;\r\n            dest.y = y;\r\n        }\r\n\r\n        static union(dest: IRect, rect2: IRect) {\r\n            if (rect2.width <= 0 || rect2.height <= 0)\r\n                return;\r\n            if (dest.width <= 0 || dest.height <= 0) {\r\n                Rect.copyTo(rect2, dest);\r\n                return;\r\n            }\r\n\r\n            var x = Math.min(dest.x, rect2.x);\r\n            var y = Math.min(dest.y, rect2.y);\r\n            dest.width = Math.max(dest.x + dest.width, rect2.x + rect2.width) - x;\r\n            dest.height = Math.max(dest.y + dest.height, rect2.y + rect2.height) - y;\r\n            dest.x = x;\r\n            dest.y = y;\r\n        }\r\n\r\n        static isContainedIn(src: IRect, test: IRect) {\r\n            var sl = src.x;\r\n            var st = src.y;\r\n            var sr = src.x + src.width;\r\n            var sb = src.y + src.height;\r\n\r\n            var tl = test.x;\r\n            var tt = test.y;\r\n            var tr = test.x + test.width;\r\n            var tb = test.y + test.height;\r\n\r\n            if (sl < tl || st < tt || sl > tr || st > tb) //src top-left is outside test\r\n                return false;\r\n            if (sr < tl || sb < tt || sr > tr || sb > tb) //src bottom-right is outside test\r\n                return false;\r\n            return true;\r\n        }\r\n\r\n        static containsPoint(rect1: IRect, p: Point): boolean {\r\n            return rect1.x <= p.x\r\n                && rect1.y <= p.y\r\n                && (rect1.x + rect1.width) >= p.x\r\n                && (rect1.y + rect1.height) >= p.y;\r\n        }\r\n\r\n        static extendTo(dest: IRect, x: number, y: number) {\r\n            var rx = dest.x;\r\n            var ry = dest.y;\r\n            var rw = dest.width;\r\n            var rh = dest.height;\r\n\r\n            if (x < rx || x > (rx + rw))\r\n                rw = Math.max(Math.abs(x - rx), Math.abs(x - rx - rw));\r\n            if (y < ry || y > (ry + rh))\r\n                rh = Math.max(Math.abs(y - ry), Math.abs(y - ry - rh));\r\n\r\n            dest.x = Math.min(rx, x);\r\n            dest.y = Math.min(ry, y);\r\n            dest.width = rw;\r\n            dest.height = rh;\r\n        }\r\n\r\n        static grow(dest: IRect, left: number, top: number, right: number, bottom: number) {\r\n            dest.x -= left;\r\n            dest.y -= top;\r\n            dest.width += left + right;\r\n            dest.height += top + bottom;\r\n            if (dest.width < 0)\r\n                dest.width = 0;\r\n            if (dest.height < 0)\r\n                dest.height = 0;\r\n            return dest;\r\n        }\r\n\r\n        static shrink(dest: IRect, left: number, top: number, right: number, bottom: number) {\r\n            dest.x += left;\r\n            dest.y += top;\r\n            dest.width -= left + right;\r\n            dest.height -= top + bottom;\r\n            if (dest.width < 0)\r\n                dest.width = 0;\r\n            if (dest.height < 0)\r\n                dest.height = 0;\r\n        }\r\n\r\n        static rectIn(rect1: IRect, rect2: IRect) {\r\n            //TODO: Implement without creating Rect\r\n            var copy = new Rect();\r\n            Rect.copyTo(rect1, copy);\r\n            Rect.intersection(copy, rect2);\r\n            if (Rect.isEmpty(copy))\r\n                return RectOverlap.outside;\r\n            if (Rect.isEqual(copy, rect2))\r\n                return RectOverlap.inside;\r\n            return RectOverlap.part;\r\n        }\r\n    }\r\n}","namespace mirage {\r\n    export interface ISize {\r\n        width: number;\r\n        height: number;\r\n    }\r\n\r\n    export class Size implements ISize {\r\n        width: number;\r\n        height: number;\r\n\r\n        constructor (width?: number, height?: number) {\r\n            this.width = width == null ? 0 : width;\r\n            this.height = height == null ? 0 : height;\r\n        }\r\n\r\n        static copyTo (src: ISize, dest: ISize) {\r\n            dest.width = src.width;\r\n            dest.height = src.height;\r\n        }\r\n\r\n        static isEqual (size1: ISize, size2: ISize): boolean {\r\n            return size1.width === size2.width\r\n                && size1.height === size2.height;\r\n        }\r\n\r\n        static isEmpty (size: Size): boolean {\r\n            return size.width === 0\r\n                || size.height === 0;\r\n        }\r\n\r\n        static max (dest: ISize, size2: ISize) {\r\n            dest.width = Math.max(dest.width, size2.width);\r\n            dest.height = Math.max(dest.height, size2.height);\r\n        }\r\n\r\n        static min (dest: ISize, size2: ISize) {\r\n            dest.width = Math.min(dest.width, size2.width);\r\n            dest.height = Math.min(dest.height, size2.height);\r\n        }\r\n\r\n        static round(size: ISize) {\r\n            size.width = Math.round(size.width);\r\n            size.height = Math.round(size.height);\r\n        }\r\n\r\n        static isUndef (size: ISize): boolean {\r\n            return isNaN(size.width) && isNaN(size.height);\r\n        }\r\n\r\n        static clear (size: ISize) {\r\n            size.width = 0;\r\n            size.height = 0;\r\n        }\r\n\r\n        static undef (size: ISize) {\r\n            size.width = NaN;\r\n            size.height = NaN;\r\n        }\r\n    }\r\n}","namespace mirage {\n    export interface IStackPanelInputs extends core.ILayoutNodeInputs {\n        orientation: Orientation;\n    }\n\n    export class StackPanel extends Panel {\n        inputs: IStackPanelInputs;\n\n        get orientation(): Orientation {\n            return this.inputs.orientation;\n        }\n\n        set orientation(value: Orientation) {\n            if (this.inputs.orientation === value)\n                return;\n            this.inputs.orientation = value;\n            this.invalidateMeasure();\n            this.invalidateArrange();\n        }\n\n        protected createInputs(): IStackPanelInputs {\n            var inputs = <IStackPanelInputs>super.createInputs();\n            inputs.orientation = Orientation.horizontal;\n            return inputs;\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            if (this.inputs.orientation === Orientation.vertical) {\n                return this.measureVertical(constraint);\n            } else {\n                return this.measureHorizontal(constraint);\n            }\n        }\n\n        private measureVertical(constraint: ISize): ISize {\n            var ca = new Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new Size();\n            var inputs = this.inputs;\n\n            ca.width = constraint.width;\n            if (!isNaN(inputs.width))\n                ca.width = inputs.width;\n            ca.width = Math.min(ca.width, inputs.maxWidth);\n            ca.width = Math.max(ca.width, inputs.minWidth);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n\n                var childDesired = child.state.desiredSize;\n                measured.height += childDesired.height;\n                measured.width = Math.max(measured.width, childDesired.width);\n            }\n\n            return measured;\n        }\n\n        private measureHorizontal(constraint: ISize): ISize {\n            var ca = new Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new Size();\n            var inputs = this.inputs;\n\n            ca.height = constraint.height;\n            if (!isNaN(inputs.height))\n                ca.height = inputs.height;\n            ca.height = Math.min(ca.height, inputs.maxHeight);\n            ca.height = Math.max(ca.height, inputs.minHeight);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n\n                var childDesired = child.state.desiredSize;\n                measured.width += childDesired.width;\n                measured.height = Math.max(measured.height, childDesired.height);\n            }\n\n            return measured;\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            if (this.inputs.orientation === Orientation.vertical) {\n                return this.arrangeVertical(arrangeSize);\n            } else {\n                return this.arrangeHorizontal(arrangeSize);\n            }\n        }\n\n        private arrangeVertical(arrangeSize: ISize): ISize {\n            var arranged = new Size(arrangeSize.width, 0);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new Rect(0, arranged.height, arrangeSize.width, childDesired.height);\n                if (Rect.isEmpty(childFinal))\n                    Rect.clear(childFinal);\n\n                child.arrange(childFinal);\n\n                arranged.width = Math.max(arranged.width, arrangeSize.width);\n                arranged.height += childDesired.height;\n            }\n\n            arranged.height = Math.max(arranged.height, arrangeSize.height);\n\n            return arranged;\n        }\n\n        private arrangeHorizontal(arrangeSize: ISize): ISize {\n            var arranged = new Size(0, arrangeSize.height);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new Rect(arranged.width, 0, childDesired.width, arrangeSize.height);\n                if (Rect.isEmpty(childFinal))\n                    Rect.clear(childFinal);\n\n                child.arrange(childFinal);\n\n                arranged.width += childDesired.width;\n                arranged.height = Math.max(arranged.height, arrangeSize.height);\n            }\n\n            arranged.width = Math.max(arranged.width, arrangeSize.width);\n\n            return arranged;\n        }\n    }\n}","namespace mirage {\r\n    export class Thickness {\r\n        left: number;\r\n        top: number;\r\n        right: number;\r\n        bottom: number;\r\n\r\n        constructor(left?: number, top?: number, right?: number, bottom?: number) {\r\n            this.left = left == null ? 0 : left;\r\n            this.top = top == null ? 0 : top;\r\n            this.right = right == null ? 0 : right;\r\n            this.bottom = bottom == null ? 0 : bottom;\r\n        }\r\n\r\n        static add(dest: Thickness, t2: Thickness) {\r\n            dest.left += t2.left;\r\n            dest.top += t2.top;\r\n            dest.right += t2.right;\r\n            dest.bottom += t2.bottom;\r\n        }\r\n\r\n        static copyTo(thickness: Thickness, dest: Thickness) {\r\n            dest.left = thickness.left;\r\n            dest.top = thickness.top;\r\n            dest.right = thickness.right;\r\n            dest.bottom = thickness.bottom;\r\n        }\r\n\r\n        static isEmpty(thickness: Thickness): boolean {\r\n            return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;\r\n        }\r\n\r\n        static isEqual(t1: Thickness, t2: Thickness): boolean {\r\n            return t1.left === t2.left\r\n                && t1.top === t2.top\r\n                && t1.right === t2.right\r\n                && t1.bottom === t2.bottom;\r\n        }\r\n\r\n        static isBalanced(thickness: Thickness): boolean {\r\n            return thickness.left === thickness.top\r\n                && thickness.left === thickness.right\r\n                && thickness.left === thickness.bottom;\r\n        }\r\n\r\n        static shrinkSize(thickness: Thickness, dest: Size) {\r\n            var w = dest.width;\r\n            var h = dest.height;\r\n            if (w != Number.POSITIVE_INFINITY)\r\n                w -= thickness.left + thickness.right;\r\n            if (h != Number.POSITIVE_INFINITY)\r\n                h -= thickness.top + thickness.bottom;\r\n            dest.width = w > 0 ? w : 0;\r\n            dest.height = h > 0 ? h : 0;\r\n            return dest;\r\n        }\r\n\r\n        static shrinkRect(thickness: Thickness, dest: IRect) {\r\n            dest.x += thickness.left;\r\n            dest.y += thickness.top;\r\n            dest.width -= thickness.left + thickness.right;\r\n            dest.height -= thickness.top + thickness.bottom;\r\n            if (dest.width < 0)\r\n                dest.width = 0;\r\n            if (dest.height < 0)\r\n                dest.height = 0;\r\n        }\r\n\r\n        static shrinkCornerRadius(thickness: Thickness, dest: ICornerRadius) {\r\n            dest.topLeft = Math.max(dest.topLeft - Math.max(thickness.left, thickness.top) * 0.5, 0);\r\n            dest.topRight = Math.max(dest.topRight - Math.max(thickness.right, thickness.top) * 0.5, 0);\r\n            dest.bottomRight = Math.max(dest.bottomRight - Math.max(thickness.right, thickness.bottom) * 0.5, 0);\r\n            dest.bottomLeft = Math.max(dest.bottomLeft - Math.max(thickness.left, thickness.bottom) * 0.5, 0);\r\n        }\r\n\r\n        static growSize(thickness: Thickness, dest: Size) {\r\n            var w = dest.width;\r\n            var h = dest.height;\r\n            if (w != Number.POSITIVE_INFINITY)\r\n                w += thickness.left + thickness.right;\r\n            if (h != Number.POSITIVE_INFINITY)\r\n                h += thickness.top + thickness.bottom;\r\n            dest.width = w > 0 ? w : 0;\r\n            dest.height = h > 0 ? h : 0;\r\n            return dest;\r\n        }\r\n\r\n        static growRect(thickness: Thickness, dest: IRect) {\r\n            dest.x -= thickness.left;\r\n            dest.y -= thickness.top;\r\n            dest.width += thickness.left + thickness.right;\r\n            dest.height += thickness.top + thickness.bottom;\r\n            if (dest.width < 0)\r\n                dest.width = 0;\r\n            if (dest.height < 0)\r\n                dest.height = 0;\r\n        }\r\n\r\n        static growCornerRadius(thickness: Thickness, dest: ICornerRadius) {\r\n            dest.topLeft = dest.topLeft ? Math.max(dest.topLeft + Math.max(thickness.left, thickness.top) * 0.5, 0) : 0;\r\n            dest.topRight = dest.topRight ? Math.max(dest.topRight + Math.max(thickness.right, thickness.top) * 0.5, 0) : 0;\r\n            dest.bottomRight = dest.bottomRight ? Math.max(dest.bottomRight + Math.max(thickness.right, thickness.bottom) * 0.5, 0) : 0;\r\n            dest.bottomLeft = dest.bottomLeft ? Math.max(dest.bottomLeft + Math.max(thickness.left, thickness.bottom) * 0.5, 0) : 0;\r\n        }\r\n    }\r\n}","namespace mirage.core {\n    export interface IArrangeBinder {\n        (): boolean;\n    }\n\n    export function NewArrangeBinder(state: IArrangeState, tree: ILayoutTree, arranger: IArranger): IArrangeBinder {\n        return function (): boolean {\n            var last = state.layoutSlot || undefined;\n            if (!tree.parent)\n                last = new Rect();\n\n            if (last) {\n                return arranger(last);\n            } else if (tree.parent) {\n                tree.parent.invalidateArrange();\n            }\n            return false;\n        };\n    }\n\n    // TODO: This binder is not in use at this time\n    // We should explore whether expand+shift is needed\n    // If it is, we should push the \"surface\" size rather than pull it\n    export function NewSpecialArrangeBinder(node: core.LayoutNode, arranger: IArranger): IArrangeBinder {\n        var state = node.state;\n        var tree = node.tree;\n\n        function expandViewport(viewport: IRect) {\n            /*\n             if (tree.isLayoutContainer) {\n             Size.copyTo(state.desiredSize, viewport);\n             if (tree.surface) {\n             var measure = state.previousAvailable;\n             if (!Size.isUndef(measure)) {\n             viewport.width = Math.max(viewport.width, measure.width);\n             viewport.height = Math.max(viewport.height, measure.height);\n             } else {\n             viewport.width = tree.surface.width;\n             viewport.height = tree.surface.height;\n             }\n             }\n             } else {\n             viewport.width = assets.actualWidth;\n             viewport.height = assets.actualHeight;\n             }\n             */\n        }\n\n        function shiftViewport(viewport: IRect) {\n            //NOTE: Coercing undefined, null, NaN, and 0 to 0\n            //viewport.x =  Canvas.getLeft(node) || 0;\n            //viewport.y = Canvas.getTop(node) || 0;\n        }\n\n        return function (): boolean {\n            var last = state.layoutSlot || undefined;\n            if (!tree.parent) {\n                last = new Rect();\n                expandViewport(last);\n                shiftViewport(last);\n            }\n\n            if (last) {\n                return arranger(last);\n            } else if (tree.parent) {\n                tree.parent.invalidateArrange();\n            }\n            return false;\n        };\n    }\n}","namespace mirage.core {\n    export interface IArrangeInputs {\n        visible: boolean;\n        margin: Thickness;\n        width: number;\n        height: number;\n        minWidth: number;\n        minHeight: number;\n        maxWidth: number;\n        maxHeight: number;\n        useLayoutRounding: boolean;\n        horizontalAlignment: HorizontalAlignment;\n        verticalAlignment: VerticalAlignment;\n    }\n\n    export interface IArrangeState {\n        flags: LayoutFlags;\n        previousAvailable: ISize;\n        desiredSize: ISize;\n        hiddenDesire: ISize;\n        layoutSlot: IRect;\n        arrangedSlot: IRect;\n        lastArranged: ISize;\n    }\n\n\n    export interface IArranger {\n        (finalRect: Rect): boolean;\n    }\n    export interface IArrangeOverride {\n        (finalSize: ISize): ISize;\n    }\n\n    export function NewArranger(inputs: IArrangeInputs, state: IArrangeState, tree: ILayoutTree, override: IArrangeOverride): IArranger {\n        return function (finalRect: Rect): boolean {\n            if (inputs.visible !== true) {\n                return false;\n            }\n\n            // Apply rounding\n            var childRect = new Rect();\n            if (inputs.useLayoutRounding) {\n                childRect.x = Math.round(finalRect.x);\n                childRect.y = Math.round(finalRect.y);\n                childRect.width = Math.round(finalRect.width);\n                childRect.height = Math.round(finalRect.height);\n            } else {\n                Rect.copyTo(finalRect, childRect);\n            }\n\n            // Validate\n            if (childRect.width < 0 || childRect.height < 0\n                || !isFinite(childRect.width) || !isFinite(childRect.height)\n                || isNaN(childRect.x) || isNaN(childRect.y)\n                || isNaN(childRect.width) || isNaN(childRect.height)) {\n                console.warn(\"[mirage] cannot call arrange using rect with NaN/infinite values.\");\n                return false;\n            }\n\n            // Check need to arrange\n            if ((state.flags & LayoutFlags.arrange) <= 0) {\n                return false;\n            }\n            if (Rect.isEqual(state.layoutSlot, childRect)) {\n                return false;\n            }\n            Rect.copyTo(childRect, state.layoutSlot);\n\n            // Calculate stretched\n            Thickness.shrinkRect(inputs.margin, childRect);\n            var stretched = new Size(childRect.width, childRect.height);\n            coerceSize(stretched, inputs);\n\n            // Prepare override\n            var framework = new Size();\n            coerceSize(framework, inputs);\n            if (inputs.horizontalAlignment === HorizontalAlignment.stretch) {\n                framework.width = Math.max(framework.width, stretched.width);\n            }\n            if (inputs.verticalAlignment === VerticalAlignment.stretch) {\n                framework.height = Math.max(framework.height, stretched.height);\n            }\n            var offer = new Size(state.hiddenDesire.width, state.hiddenDesire.height);\n            Size.max(offer, framework);\n\n            // Do override\n            var arranged = override(offer);\n\n            // Complete override\n            state.flags &= ~LayoutFlags.arrange;\n            if (inputs.useLayoutRounding) {\n                Size.round(arranged);\n            }\n\n            // Constrain\n            var constrained = new Size(arranged.width, arranged.height);\n            coerceSize(constrained, inputs);\n            Size.min(constrained, arranged);\n\n            // Calculate visual offset\n            var as = state.arrangedSlot;\n            Point.copyTo(childRect, as);\n            switch (inputs.horizontalAlignment) {\n                case HorizontalAlignment.left:\n                    break;\n                case HorizontalAlignment.right:\n                    as.x += childRect.width - constrained.width;\n                    break;\n                case HorizontalAlignment.center:\n                    as.x += (childRect.width - constrained.width) * 0.5;\n                    break;\n                default:\n                    as.x += Math.max((childRect.width - constrained.width) * 0.5, 0);\n                    break;\n            }\n            switch (inputs.verticalAlignment) {\n                case VerticalAlignment.top:\n                    break;\n                case VerticalAlignment.bottom:\n                    as.y += childRect.height - constrained.height;\n                    break;\n                case VerticalAlignment.center:\n                    as.y += (childRect.height - constrained.height) * 0.5;\n                    break;\n                default:\n                    as.y += Math.max((childRect.height - constrained.height) * 0.5, 0);\n                    break;\n            }\n            if (inputs.useLayoutRounding) {\n                Point.round(as);\n            }\n\n            // Cycle old + current arranged for sizing\n            var oldArrange = state.arrangedSlot;\n            if (!Size.isEqual(oldArrange, arranged)) {\n                Size.copyTo(oldArrange, state.lastArranged);\n                state.flags |= LayoutFlags.sizeHint;\n                tree.propagateFlagUp(LayoutFlags.sizeHint);\n            }\n            Size.copyTo(arranged, state.arrangedSlot);\n\n            return true;\n        }\n    }\n}","namespace mirage.core {\n    export function DefaultLayoutTree(): ILayoutTree {\n        return {\n            isContainer: true,\n            isLayoutContainer: false,\n            parent: null,\n            applyTemplate(): boolean {\n                return true;\n            },\n            propagateFlagUp(flag: LayoutFlags) {\n                for (var cur: LayoutNode = this.parent; !!cur && (cur.state.flags & flag) <= 0; cur = cur.tree.parent) {\n                    cur.state.flags |= flag;\n                }\n            },\n            walk(reverse?: boolean): ILayoutTreeWalker {\n                return {\n                    current: undefined,\n                    step(): boolean {\n                        return false;\n                    },\n                }\n            },\n        };\n    }\n}","namespace mirage.core {\n    export enum LayoutFlags {\n        none = 0,\n\n        measure = 1 << 1,\n        arrange = 1 << 2,\n\n        measureHint = 1 << 3,\n        arrangeHint = 1 << 4,\n        sizeHint    = 1 << 5,\n        hints       = measureHint | arrangeHint | sizeHint,\n    }\n}\n","namespace mirage.core {\n    export interface IMeasureBinder {\n        (): boolean;\n    }\n\n    export function NewMeasureBinder(state: IMeasureState, tree: ILayoutTree, measurer: IMeasurer): IMeasureBinder {\n        return function (): boolean {\n            var last = state.previousAvailable;\n\n            if (Size.isUndef(last) && !tree.parent && tree.isLayoutContainer)\n                last.width = last.height = Number.POSITIVE_INFINITY;\n\n            var success = false;\n            if (!Size.isUndef(last)) {\n                var old = new Size();\n                Size.copyTo(state.desiredSize, old);\n                success = measurer(last);\n                if (Size.isEqual(old, state.desiredSize))\n                    return success;\n            }\n\n            if (tree.parent)\n                tree.parent.invalidateMeasure();\n\n            state.flags &= ~LayoutFlags.measure;\n            return success;\n        };\n    }\n}","namespace mirage.core {\n    export interface IMeasureInputs {\n        visible: boolean;\n        margin: Thickness;\n        width: number;\n        height: number;\n        minWidth: number;\n        minHeight: number;\n        maxWidth: number;\n        maxHeight: number;\n        useLayoutRounding: boolean;\n    }\n\n    export interface IMeasureState {\n        flags: LayoutFlags;\n        previousAvailable: ISize;\n        desiredSize: ISize;\n        hiddenDesire: ISize;\n    }\n\n    export interface IMeasurer {\n        (availableSize: ISize): boolean;\n    }\n    export interface IMeasureOverride {\n        (coreSize: ISize): Size;\n    }\n\n    export function NewMeasurer(inputs: IMeasureInputs, state: IMeasureState, tree: ILayoutTree, override: IMeasureOverride): IMeasurer {\n        return function (availableSize: ISize): boolean {\n            // Validate\n            if (isNaN(availableSize.width) || isNaN(availableSize.height)) {\n                console.warn(\"[mirage] cannot call measure using a size with NaN values.\");\n                return false;\n            }\n            if (inputs.visible !== true) {\n                return false;\n            }\n\n            // Apply Template\n            tree.applyTemplate();\n\n            // Check need to measure\n            if ((state.flags & LayoutFlags.measure) <= 0) {\n                return false;\n            }\n            var pc = state.previousAvailable;\n            if (!Size.isUndef(pc) && pc.width === availableSize.width && pc.height === availableSize.height) {\n                return false;\n            }\n\n            // Invalidate downstream\n            state.flags |= (LayoutFlags.arrange | LayoutFlags.arrangeHint);\n\n            // Prepare for override\n            var framedSize = new Size(availableSize.width, availableSize.height);\n            Thickness.shrinkSize(inputs.margin, framedSize);\n            coerceSize(framedSize, inputs);\n\n            // Do override\n            var desired = override(framedSize);\n\n            // Complete override\n            state.flags &= ~LayoutFlags.measure;\n            Size.copyTo(desired, state.hiddenDesire);\n\n            // Finish desired\n            coerceSize(desired, inputs);\n            Thickness.growSize(inputs.margin, desired);\n\n            desired.width = Math.min(desired.width, availableSize.width);\n            desired.height = Math.min(desired.height, availableSize.height);\n            if (inputs.useLayoutRounding) {\n                Size.round(desired);\n            }\n            Size.copyTo(desired, state.desiredSize);\n\n            return true;\n        };\n    }\n}","namespace mirage.core {\n    export interface ISized {\n        width: number;\n        height: number;\n        minWidth: number;\n        minHeight: number;\n        maxWidth: number;\n        maxHeight: number;\n        useLayoutRounding: boolean;\n    }\n\n    export function coerceSize(size: ISize, inputs: ISized) {\n        var cw = Math.max(inputs.minWidth, size.width);\n        var ch = Math.max(inputs.minHeight, size.height);\n\n        if (!isNaN(inputs.width))\n            cw = inputs.width;\n\n        if (!isNaN(inputs.height))\n            ch = inputs.height;\n\n        cw = Math.max(Math.min(cw, inputs.maxWidth), inputs.minWidth);\n        ch = Math.max(Math.min(ch, inputs.maxHeight), inputs.minHeight);\n\n        if (inputs.useLayoutRounding) {\n            cw = Math.round(cw);\n            ch = Math.round(ch);\n        }\n\n        size.width = cw;\n        size.height = ch;\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    export interface IArrangeDrafter {\n        flush();\n        prepare(): boolean;\n        draft(): boolean;\n    }\n\n    export function NewArrangeDrafter(node: core.LayoutNode): IArrangeDrafter {\n        var arrangeList: core.LayoutNode[] = [];\n\n        return {\n            flush() {\n                var cur: core.LayoutNode;\n                while ((cur = arrangeList.shift()) != null) {\n                    cur.tree.propagateFlagUp(LayoutFlags.arrangeHint);\n                }\n            },\n            prepare(): boolean {\n                for (var walker = node.walkDeep(); walker.step();) {\n                    var cur = walker.current;\n                    if (!cur.inputs.visible) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    if ((cur.state.flags & LayoutFlags.arrangeHint) === 0) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    cur.state.flags &= ~LayoutFlags.arrangeHint;\n                    if ((cur.state.flags & LayoutFlags.arrange) > 0) {\n                        arrangeList.push(cur);\n                    }\n                }\n                return arrangeList.length > 0;\n            },\n            draft(): boolean {\n                var cur: core.LayoutNode;\n                while ((cur = arrangeList.shift()) != null) {\n                    cur.doArrange();\n                }\n                return true;\n            },\n        }\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    var MAX_COUNT = 255;\n\n    export interface IDrafter {\n        (): boolean;\n    }\n\n    export function NewDrafter(node: core.LayoutNode, rootSize: ISize): IDrafter {\n        var measure = NewMeasureDrafter(node, rootSize);\n        var arrange = NewArrangeDrafter(node);\n        var size = NewSizeDrafter(node);\n\n        /// Every pass at runDraft will exclusively run measure, arrange, or size\n        /// true should be returned if any updates were made\n        function runDraft(): boolean {\n            if (!node.inputs.visible)\n                return false;\n\n            arrange.flush();\n            size.flush();\n\n            var flags = node.state.flags;\n            if ((flags & LayoutFlags.measureHint) > 0) {\n                return measure.prepare()\n                    && measure.draft();\n            }\n            if ((flags & LayoutFlags.arrangeHint) > 0) {\n                return arrange.prepare()\n                    && arrange.draft();\n            }\n            if ((flags & LayoutFlags.sizeHint) > 0) {\n                return size.prepare()\n                    && size.draft()\n                    && size.notify();\n            }\n\n            return false;\n        }\n\n        return function (): boolean {\n            if ((node.state.flags & LayoutFlags.hints) === 0)\n                return false;\n            var updated = false;\n            for (var count = 0; count < MAX_COUNT; count++) {\n                if (!runDraft())\n                    break;\n                updated = true;\n            }\n            if (count >= MAX_COUNT) {\n                console.error(\"[mirage] aborting infinite draft\");\n            }\n            return updated;\n        };\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    export interface IMeasureDrafter {\n        prepare(): boolean;\n        draft(): boolean;\n    }\n\n    export function NewMeasureDrafter(node: core.LayoutNode, rootSize: ISize): IMeasureDrafter {\n        var measureList: core.LayoutNode[] = [];\n\n        return {\n            prepare(): boolean {\n                var last = node.state.previousAvailable;\n                if (node.tree.isContainer && (Size.isUndef(last) || !Size.isEqual(last, rootSize))) {\n                    node.state.flags |= LayoutFlags.measure;\n                    Size.copyTo(rootSize, node.state.previousAvailable);\n                }\n\n                // Load up measure list\n                for (var walker = node.walkDeep(); walker.step();) {\n                    var cur = walker.current;\n                    if (!cur.inputs.visible) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    if ((cur.state.flags & LayoutFlags.measureHint) === 0) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    cur.state.flags &= ~LayoutFlags.measureHint;\n                    if ((cur.state.flags & LayoutFlags.measure) > 0) {\n                        measureList.push(cur);\n                    }\n                }\n\n                return measureList.length > 0;\n            },\n            draft(): boolean {\n                var cur: core.LayoutNode;\n                while ((cur = measureList.shift()) != null) {\n                    cur.doMeasure();\n                }\n                return true;\n            },\n        };\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    export interface ISizeDrafter {\n        flush();\n        prepare(): boolean;\n        draft(): boolean;\n        notify(): boolean;\n    }\n\n    interface ISizingUpdate {\n        node: core.LayoutNode;\n        oldSize: ISize;\n        newSize: ISize;\n    }\n\n    export function NewSizeDrafter(node: core.LayoutNode): ISizeDrafter {\n        var sizingList: core.LayoutNode[] = [];\n        var sizingUpdates: ISizingUpdate[] = [];\n\n        return {\n            flush() {\n                var cur: core.LayoutNode;\n                while ((cur = sizingList.shift()) != null) {\n                    cur.tree.propagateFlagUp(LayoutFlags.sizeHint);\n                }\n            },\n            prepare(): boolean {\n                for (var walker = node.walkDeep(); walker.step();) {\n                    var cur = walker.current;\n                    if (!cur.inputs.visible) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    if ((cur.state.flags & LayoutFlags.sizeHint) === 0) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    cur.state.flags &= ~LayoutFlags.sizeHint;\n                    if (cur.state.lastArranged !== undefined) {\n                        sizingList.push(cur);\n                    }\n                }\n                return sizingList.length > 0;\n            },\n            draft(): boolean {\n                var oldSize = new Size();\n                var newSize = new Size();\n                var cur: core.LayoutNode;\n                while ((cur = sizingList.pop()) != null) {\n                    cur.sizing(oldSize, newSize);\n                    if (!Size.isEqual(oldSize, newSize)) {\n                        sizingUpdates.push({\n                            node: cur,\n                            oldSize: oldSize,\n                            newSize: newSize,\n                        });\n                        oldSize = new Size();\n                        newSize = new Size();\n                    }\n                }\n                return sizingUpdates.length > 0;\n            },\n            notify(): boolean {\n                var update: ISizingUpdate;\n                while ((update = sizingUpdates.pop()) != null) {\n                    update.node.onSizeChanged(update.oldSize, update.newSize);\n                }\n                return true;\n            }\n        };\n    }\n}","namespace mirage.grid {\n    export function NewGridArrangeOverride(inputs: IGridInputs, state: IGridState, tree: IPanelTree): core.IArrangeOverride {\n        var des = state.design.arrange;\n\n        return function (arrangeSize: ISize): ISize {\n            des.init(arrangeSize, inputs.columnDefinitions, inputs.rowDefinitions);\n\n            var cr = new Rect();\n            for (var walker = tree.walk(); walker.step();) {\n                var child = walker.current;\n                des.calcChildRect(cr, child);\n                child.arrange(cr);\n            }\n\n            return new Size(arrangeSize.width, arrangeSize.height);\n        };\n    }\n}","namespace mirage.grid {\n    export function NewGridMeasureOverride(inputs: IGridInputs, state: IGridState, tree: IPanelTree): core.IMeasureOverride {\n        var des = state.design.measure;\n\n        var overrideAutoAuto = design.NewMeasureOverridePass(design.MeasureOverridePass.autoAuto, des, tree);\n        var overrideStarAuto = design.NewMeasureOverridePass(design.MeasureOverridePass.starAuto, des, tree);\n        var overrideAutoStar = design.NewMeasureOverridePass(design.MeasureOverridePass.autoStar, des, tree);\n        var overrideStarAuto2 = design.NewMeasureOverridePass(design.MeasureOverridePass.starAutoAgain, des, tree);\n        var overrideNonStar = design.NewMeasureOverridePass(design.MeasureOverridePass.nonStar, des, tree);\n        var overrideRemainingStar = design.NewMeasureOverridePass(design.MeasureOverridePass.remainingStar, des, tree);\n\n        return function (constraint: ISize): ISize {\n            des.init(constraint, inputs.columnDefinitions, inputs.rowDefinitions, tree);\n            overrideAutoAuto();\n            overrideStarAuto();\n            overrideAutoStar();\n            overrideStarAuto2();\n            overrideNonStar();\n            overrideRemainingStar();\n            des.finish();\n            return des.getDesired();\n        };\n    }\n}","namespace mirage.grid.design {\n    export interface IGridArrangeDesign {\n        init(arrangeSize: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[]);\n        calcChildRect(childRect: IRect, child: core.LayoutNode);\n    }\n\n    export function NewGridArrangeDesign(cm: Segment[][], rm: Segment[][]): IGridArrangeDesign {\n        return {\n            init(arrangeSize: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[]) {\n                originalToOffered(cm);\n                originalToOffered(rm);\n\n                var consumed = new Size(helpers.calcDesiredToOffered(cm), helpers.calcDesiredToOffered(rm));\n\n                if (consumed.width !== arrangeSize.width) {\n                    helpers.expand(arrangeSize.width, cm);\n                }\n                if (consumed.height !== arrangeSize.height) {\n                    helpers.expand(arrangeSize.height, rm);\n                }\n\n                if (!!coldefs) {\n                    for (var i = 0; i < coldefs.length; i++) {\n                        coldefs[i].setActualWidth(cm[i][i].offered);\n                    }\n                }\n                if (!!rowdefs) {\n                    for (var i = 0; i < rowdefs.length; i++) {\n                        rowdefs[i].setActualHeight(rm[i][i].offered);\n                    }\n                }\n            },\n            calcChildRect(childRect: IRect, child: core.LayoutNode) {\n                Rect.clear(childRect);\n\n                var col = Grid.getColumn(child) || 0; //coerce NaN, undefined, null, 0 => 0\n                col = Math.min(col, cm.length - 1);\n\n                var colspan = Grid.getColumnSpan(child);\n                if (colspan !== 0)\n                    colspan = colspan || 1; //coerce NaN, undefined, null => 1\n                colspan = Math.min(colspan, cm.length - col);\n\n                var row = Grid.getRow(child) || 0; //coerce NaN, undefined, null, 0 => 0\n                row = Math.min(row, rm.length - 1);\n\n                var rowspan = Grid.getRowSpan(child);\n                if (rowspan !== 0)\n                    rowspan = rowspan || 1; //coerce NaN, undefined, null => 1\n                rowspan = Math.min(rowspan, rm.length - row);\n\n                for (var i = 0; i < col; i++) {\n                    childRect.x += cm[i][i].offered;\n                }\n                for (var i = col; i < col + colspan; i++) {\n                    childRect.width += cm[i][i].offered;\n                }\n\n                for (var i = 0; i < row; i++) {\n                    childRect.y += rm[i][i].offered;\n                }\n                for (var i = row; i < row + rowspan; i++) {\n                    childRect.height += rm[i][i].offered;\n                }\n            },\n        };\n    }\n\n    function originalToOffered(matrix: Segment[][]) {\n        for (var i = 0; i < matrix.length; i++) {\n            for (var j = 0; j <= i; j++) {\n                matrix[i][j].offered = matrix[i][j].original;\n            }\n        }\n    }\n}","namespace mirage.grid.design {\n    export interface IGridPlacement {\n        init();\n        add(isRow: boolean, start: number, span: number, size: number);\n        allocate(allocFunc: () => void);\n    }\n\n    interface IGridPlacementCell {\n        matrix: Segment[][];\n        start: number;\n        end: number;\n        size: number;\n    }\n\n    export function NewGridPlacement(cm: Segment[][], rm: Segment[][]): IGridPlacement {\n        var unicells: IGridPlacementCell[] = [];\n        var multicells: IGridPlacementCell[] = [];\n\n        return {\n            init() {\n                unicells.length = 0;\n                multicells.length = 0;\n            },\n            add(isRow: boolean, start: number, span: number, size: number) {\n                var item: IGridPlacementCell = {\n                    matrix: isRow ? rm : cm,\n                    start: start,\n                    end: start + span - 1,\n                    size: size,\n                };\n                if (item.start === item.end) {\n                    unicells.unshift(item);\n                } else {\n                    multicells.push(item);\n                }\n            },\n            allocate(allocFunc: () => void) {\n                var cell: IGridPlacementCell;\n                while ((cell = unicells.pop()) != null) {\n                    var i = cell.start;\n                    var j = cell.end;\n                    cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                    allocFunc();\n                }\n                while ((cell = multicells.pop()) != null) {\n                    var i = cell.start;\n                    var j = cell.end;\n                    cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                    allocFunc();\n                }\n            },\n        }\n    }\n}","namespace mirage.grid.design {\n    export interface IGridShape {\n        hasAutoAuto: boolean;\n        hasStarAuto: boolean;\n        hasAutoStar: boolean;\n    }\n\n    export function NewGridShape(childShapes: IGridChildShape[]): IGridShape {\n        var hasAutoAuto = false;\n        var hasStarAuto = false;\n        var hasAutoStar = false;\n\n        for (var i = 0; i < childShapes.length; i++) {\n            let cs = childShapes[i];\n            hasAutoAuto = hasAutoAuto || (cs.autoRow && cs.autoCol && !cs.starRow && !cs.starCol);\n            hasStarAuto = hasStarAuto || (cs.starRow && cs.autoCol);\n            hasAutoStar = hasAutoStar || (cs.autoRow && cs.starCol);\n        }\n\n        return {\n            hasAutoAuto: hasAutoAuto,\n            hasStarAuto: hasStarAuto,\n            hasAutoStar: hasAutoStar,\n        };\n    }\n\n    export interface IGridChildShape {\n        starRow: boolean;\n        autoRow: boolean;\n        starCol: boolean;\n        autoCol: boolean;\n\n        col: number;\n        row: number;\n        colspan: number;\n        rowspan: number;\n\n        init (child: core.LayoutNode, rm: Segment[][], cm: Segment[][]);\n        shouldMeasurePass (gridShape: IGridShape, childSize: ISize, pass: MeasureOverridePass): boolean;\n        calcConstraint (childSize: ISize, cm: Segment[][], rm: Segment[][]);\n    }\n\n    export class GridChildShape implements IGridChildShape {\n        starRow: boolean;\n        autoRow: boolean;\n        starCol: boolean;\n        autoCol: boolean;\n\n        col: number;\n        row: number;\n        colspan: number;\n        rowspan: number;\n\n        init(child: core.LayoutNode, cm: Segment[][], rm: Segment[][]) {\n            var col = this.col = Math.min(Grid.getColumn(child), cm.length - 1);\n            if (isNaN(col))\n                this.col = col = 0;\n            var row = this.row = Math.min(Grid.getRow(child), rm.length - 1);\n            if (isNaN(row))\n                this.row = row = 0;\n            var colspan = this.colspan = Math.min(Grid.getColumnSpan(child), cm.length - col);\n            if (isNaN(colspan))\n                this.colspan = colspan = 1;\n            var rowspan = this.rowspan = Math.min(Grid.getRowSpan(child), rm.length - row);\n            if (isNaN(rowspan))\n                this.rowspan = rowspan = 1;\n\n            this.starRow = this.autoRow = this.starCol = this.autoCol = false;\n\n            for (var i = row; i < row + rowspan; i++) {\n                this.starRow = this.starRow || (rm[i][i].type === GridUnitType.star);\n                this.autoRow = this.autoRow || (rm[i][i].type === GridUnitType.auto);\n            }\n            for (var i = col; i < col + colspan; i++) {\n                this.starCol = this.starCol || (cm[i][i].type === GridUnitType.star);\n                this.autoCol = this.autoCol || (cm[i][i].type === GridUnitType.auto);\n            }\n        }\n\n        shouldMeasurePass(gridShape: IGridShape, childSize: ISize, pass: MeasureOverridePass): boolean {\n            childSize.width = childSize.height = 0;\n\n            if (this.autoRow && this.autoCol && !this.starRow && !this.starCol) {\n                if (pass !== MeasureOverridePass.autoAuto)\n                    return false;\n                childSize.width = Number.POSITIVE_INFINITY;\n                childSize.height = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if (this.starRow && this.autoCol && !this.starCol) {\n                if (pass !== MeasureOverridePass.starAuto && pass !== MeasureOverridePass.starAutoAgain)\n                    return false;\n                if (pass === MeasureOverridePass.autoAuto && gridShape.hasAutoStar)\n                    childSize.height = Number.POSITIVE_INFINITY;\n                childSize.width = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if (this.autoRow && this.starCol && !this.starRow) {\n                if (pass !== MeasureOverridePass.autoStar)\n                    return false;\n                childSize.height = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if ((this.autoRow || this.autoCol) && !(this.starRow || this.starCol)) {\n                if (pass !== MeasureOverridePass.nonStar)\n                    return false;\n                if (this.autoRow)\n                    childSize.height = Number.POSITIVE_INFINITY;\n                if (this.autoCol)\n                    childSize.width = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if (!(this.starRow || this.starCol))\n                return pass === MeasureOverridePass.nonStar;\n\n            return pass === MeasureOverridePass.remainingStar;\n        }\n\n        calcConstraint(childSize: ISize, cm: Segment[][], rm: Segment[][]) {\n            for (var i = this.row; i < this.row + this.rowspan; i++) {\n                childSize.height += rm[i][i].offered;\n            }\n            for (var i = this.col; i < this.col + this.colspan; i++) {\n                childSize.width += cm[i][i].offered;\n            }\n        }\n    }\n}","namespace mirage.grid.design.helpers {\n    export function expand(available: number, mat: Segment[][]) {\n        for (var i = 0; i < mat.length; i++) {\n            var cur = mat[i][i];\n            if (cur.type === GridUnitType.star)\n                cur.offered = 0;\n            else\n                available = Math.max(available - cur.offered, 0);\n        }\n        assignSize(mat, 0, mat.length - 1, available, GridUnitType.star, false);\n\n        //TODO: setActualWidth, setActualHeight if star?\n    }\n\n    export function assignSize(mat: Segment[][], start: number, end: number, size: number, unitType: GridUnitType, desiredSize: boolean): number {\n        var count = 0;\n        var assigned = false;\n        var segmentSize = 0;\n        for (var i = start; i <= end; i++) {\n            let cur = mat[i][i];\n            segmentSize = desiredSize ? cur.desired : cur.offered;\n            if (segmentSize < cur.max)\n                count += (unitType === GridUnitType.star) ? cur.stars : 1;\n        }\n\n        do {\n            assigned = false;\n            let contribution = size / count;\n            for (var i = start; i <= end; i++) {\n                let cur = mat[i][i];\n                segmentSize = desiredSize ? cur.desired : cur.offered;\n                if (!(cur.type === unitType && segmentSize < cur.max))\n                    continue;\n                let newSize = segmentSize;\n                newSize += contribution * (unitType === GridUnitType.star ? cur.stars : 1);\n                newSize = Math.min(newSize, cur.max);\n                assigned = assigned || (newSize > segmentSize);\n                size -= newSize - segmentSize;\n                if (desiredSize)\n                    cur.desired = newSize;\n                else\n                    cur.offered = newSize;\n            }\n        } while (assigned);\n        return size;\n    }\n\n    export function calcDesiredToOffered(matrix: Segment[][]): number {\n        var total = 0;\n        for (var i = 0; i < matrix.length; i++) {\n            total += (matrix[i][i].offered = matrix[i][i].desired);\n        }\n        return total;\n    }\n}","namespace mirage.grid.design {\n    export interface IGridDesign {\n        measure: IGridMeasureDesign;\n        arrange: IGridArrangeDesign;\n    }\n\n    export function NewGridDesign(): IGridDesign {\n        var cm: Segment[][] = [];\n        var rm: Segment[][] = [];\n\n        return {\n            measure: NewGridMeasureDesign(cm, rm),\n            arrange: NewGridArrangeDesign(cm, rm),\n        };\n    }\n}","namespace mirage.grid.design {\n    export interface IGridMeasureDesign {\n        init(constraint: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[], tree: IPanelTree);\n        measureChild(pass: MeasureOverridePass, index: number, child: core.LayoutNode);\n        finishPass();\n        finish();\n        getDesired(): ISize;\n    }\n\n    export function NewGridMeasureDesign(cm: Segment[][], rm: Segment[][]): IGridMeasureDesign {\n        var shape: IGridShape;\n        var childShapes: IGridChildShape[] = [];\n        var placement = NewGridPlacement(cm, rm);\n\n        return {\n            init(constraint: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[], tree: IPanelTree) {\n                ensureMatrix(cm, !coldefs ? 1 : coldefs.length || 1);\n                ensureMatrix(rm, !rowdefs ? 1 : rowdefs.length || 1);\n                prepareCols(cm, coldefs);\n                prepareRows(rm, rowdefs);\n\n                var i = 0;\n                for (var walker = tree.walk(); walker.step(); i++) {\n                    var childShape: IGridChildShape;\n                    if (i < childShapes.length) {\n                        childShapes[i] = childShapes[i] || new GridChildShape();\n                    } else {\n                        childShapes.push(childShape = new GridChildShape());\n                    }\n                    childShape.init(walker.current, cm, rm);\n                }\n                if (i < childShapes.length)\n                    childShapes.slice(i, childShapes.length - i);\n                shape = NewGridShape(childShapes);\n\n                placement.init();\n\n                if (tree.children.length > 0) {\n                    helpers.expand(constraint.width, cm);\n                    helpers.expand(constraint.height, rm);\n                }\n\n            },\n            measureChild(pass: MeasureOverridePass, index: number, child: core.LayoutNode) {\n                var childShape = childShapes[index];\n\n                var childSize = new Size();\n                if (!childShape || !childShape.shouldMeasurePass(shape, childSize, pass))\n                    return;\n                childShape.calcConstraint(childSize, cm, rm);\n\n                child.measure(childSize);\n\n                var desired = child.state.desiredSize;\n                if (pass !== MeasureOverridePass.starAuto)\n                    placement.add(true, childShape.row, childShape.rowspan, desired.height);\n                placement.add(false, childShape.col, childShape.colspan, desired.width);\n            },\n            finishPass() {\n                placement.allocate(allocateDesiredSizeFunc(cm, rm));\n            },\n            finish() {\n                for (var i = 0; i < cm.length; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        cm[i][j].original = cm[i][j].offered;\n                    }\n                }\n                for (var i = 0; i < rm.length; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        rm[i][j].original = rm[i][j].offered;\n                    }\n                }\n            },\n            getDesired(): ISize {\n                var desired = new Size();\n                for (var i = 0; i < cm.length; i++) {\n                    desired.width += cm[i][i].desired;\n                }\n                for (var i = 0; i < rm.length; i++) {\n                    desired.height += rm[i][i].desired;\n                }\n                return desired;\n            },\n        }\n    }\n\n    var DEFAULT_GRID_LEN: IGridLength = {\n        value: 1.0,\n        type: GridUnitType.star\n    };\n\n    function ensureMatrix(matrix: Segment[][], defCount: number) {\n        if (matrix.length > defCount)\n            matrix.splice(defCount, matrix.length - defCount);\n        for (var i = 0; i < defCount; i++) {\n            if (matrix.length <= i)\n                matrix.push([]);\n            var mrow = matrix[i];\n            if (mrow.length > (i + 1))\n                mrow.splice(i, mrow.length - i - 1);\n            for (var ii = 0; ii <= i; ii++) {\n                if (mrow.length <= ii)\n                    mrow.push(new Segment());\n                else\n                    Segment.init(mrow[ii]);\n            }\n        }\n    }\n\n    function prepareCols(cm: Segment[][], coldefs: IColumnDefinition[]) {\n        if (!coldefs || coldefs.length === 0) {\n            var mcell = cm[0][0];\n            mcell.type = GridUnitType.star;\n            mcell.stars = 1.0;\n            return;\n        }\n\n        for (var i = 0; i < coldefs.length; i++) {\n            var colDef = coldefs[i];\n            var width = colDef.width || DEFAULT_GRID_LEN;\n            colDef.setActualWidth(Number.POSITIVE_INFINITY);\n\n            var cell = Segment.init(cm[i][i], 0.0, colDef.minWidth, colDef.maxWidth, width.type);\n            if (width.type === GridUnitType.pixel) {\n                cell.desired = cell.offered = cell.clamp(width.value);\n                colDef.setActualWidth(cell.desired);\n            } else if (width.type === GridUnitType.star) {\n                cell.stars = width.value;\n            } else if (width.type === GridUnitType.auto) {\n                cell.desired = cell.offered = cell.clamp(0);\n            }\n        }\n    }\n\n    function prepareRows(rm: Segment[][], rowdefs: IRowDefinition[]) {\n        if (!rowdefs || rowdefs.length === 0) {\n            var mcell = rm[0][0];\n            mcell.type = GridUnitType.star;\n            mcell.stars = 1.0;\n            return;\n        }\n\n        for (var i = 0; i < rowdefs.length; i++) {\n            var rowDef = rowdefs[i];\n            var height = rowDef.height || DEFAULT_GRID_LEN;\n            rowDef.setActualHeight(Number.POSITIVE_INFINITY);\n\n            var cell = Segment.init(rm[i][i], 0.0, rowDef.minHeight, rowDef.maxHeight, height.type);\n            if (height.type === GridUnitType.pixel) {\n                cell.desired = cell.offered = cell.clamp(height.value);\n                rowDef.setActualHeight(cell.desired);\n            } else if (height.type === GridUnitType.star) {\n                cell.stars = height.value;\n            } else if (height.type === GridUnitType.auto) {\n                cell.desired = cell.offered = cell.clamp(0);\n            }\n        }\n    }\n\n    function allocateDesiredSizeFunc(cm: Segment[][], rm: Segment[][]): () => void {\n        function hasStarInSpan(mat: Segment[][], start: number, end: number): boolean {\n            var spansStar = false;\n            for (var i = start; i >= end; i--) {\n                spansStar = spansStar || mat[i][i].type === GridUnitType.star;\n            }\n            return spansStar;\n        }\n\n        function calcDesired(mat: Segment[][], start: number, end: number): number {\n            var total = 0;\n            for (var i = start; i >= end; i--) {\n                total += mat[i][i].desired;\n            }\n            return total;\n        }\n\n        function allocSegments(mat: Segment[][]) {\n            var count = mat.length;\n            for (var start = count - 1; start >= 0; start--) {\n                for (var end = start; end >= 0; end--) {\n                    let hasStar = hasStarInSpan(mat, start, end);\n                    let cur = mat[start][end].desired;\n                    let total = calcDesired(mat, start, end);\n                    let additional = cur - total;\n                    if (additional > 0) {\n                        if (hasStar) {\n                            helpers.assignSize(mat, end, start, additional, GridUnitType.star, true);\n                        } else {\n                            helpers.assignSize(mat, end, start, additional, GridUnitType.pixel, true);\n                            helpers.assignSize(mat, end, start, additional, GridUnitType.auto, true);\n                        }\n                    }\n                }\n            }\n        }\n\n        return function () {\n            // Allocate heights then widths\n            allocSegments(rm);\n            allocSegments(cm);\n\n            helpers.calcDesiredToOffered(rm);\n            helpers.calcDesiredToOffered(cm);\n        };\n    }\n}","namespace mirage.grid.design {\n    export enum MeasureOverridePass {\n        autoAuto, //Child in auto row, auto col\n        starAuto, //Child in star row, auto col\n        autoStar, //Child in auto row, star col\n        starAutoAgain, //star row, auto col repeated\n        nonStar, //Child in auto/pixel row, auto/pixel col\n        remainingStar, //Child in ?\n    }\n\n    export function NewMeasureOverridePass(pass: MeasureOverridePass, des: IGridMeasureDesign, tree: IPanelTree) {\n        return function() {\n            for (var walker = tree.walk(), i = 0; walker.step(); i++) {\n                des.measureChild(pass, i, walker.current);\n            }\n            des.finishPass();\n        };\n    }\n}","module mirage.grid.design {\r\n    export class Segment {\r\n        desired: number = 0.0;\r\n        offered: number = 0.0;\r\n        original: number = 0.0;\r\n        min: number = 0.0;\r\n        max: number = Number.POSITIVE_INFINITY;\r\n        stars: number = 0;\r\n        type = GridUnitType.pixel;\r\n\r\n        clamp(value: number): number {\r\n            if (value < this.min)\r\n                return this.min;\r\n            if (value > this.max)\r\n                return this.max;\r\n            return value;\r\n        }\r\n\r\n        static init(segment: Segment, offered?: number, min?: number, max?: number, unitType?: GridUnitType): Segment {\r\n            segment.desired = 0.0;\r\n            segment.stars = 0;\r\n            segment.offered = offered || 0.0;\r\n            segment.min = min || 0.0;\r\n            segment.max = max != null ? max : Number.POSITIVE_INFINITY;\r\n            segment.type = unitType != null ? unitType : GridUnitType.pixel;\r\n\r\n            if (segment.offered < min)\r\n                segment.offered = min;\r\n            else if (segment.offered > max)\r\n                segment.offered = max;\r\n\r\n            return segment;\r\n        }\r\n    }\r\n}"],"sourceRoot":"/mirage"}