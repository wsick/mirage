{"version":3,"sources":["_version.ts","core/LayoutNode.ts","mirage.js","typeLookup.ts","Panel.ts","Thickness.ts","convert/converters.ts","map/mappers.ts","Canvas.ts","Enums.ts","IRowDefinition.ts","IColumnDefinition.ts","Grid.ts","IGridLength.ts","IRenderAdapter.ts","Point.ts","Rect.ts","Size.ts","core/converters.ts","StackPanel.ts","core/Arranger.ts","core/DefaultLayoutTree.ts","core/LayoutFlags.ts","core/mappers.ts","core/Measurer.ts","core/util.ts","draft/ArrangeDrafter.ts","draft/Drafter.ts","draft/MeasureDrafter.ts","draft/SlotDrafter.ts","grid/GridArrangeOverride.ts","grid/GridMeasureOverride.ts","grid/design/Arrange.ts","grid/design/GridPlacement.ts","grid/design/GridShape.ts","grid/design/helpers.ts","grid/design/IGridDesign.ts","grid/design/Measure.ts","grid/design/MeasureOverridePass.ts","grid/design/Segment.ts"],"names":["mirage","mirage.core","mirage.core.onNodeSizeInputsChanged","mirage.core.LayoutNode","mirage.core.LayoutNode.constructor","mirage.core.LayoutNode.init","mirage.core.LayoutNode.createInputs","mirage.core.LayoutNode.createState","mirage.core.LayoutNode.createTree","mirage.core.LayoutNode.createMeasurer","mirage.core.LayoutNode.createArranger","get","mirage.core.LayoutNode.visible","set","enumerable","configurable","mirage.core.LayoutNode.useLayoutRounding","mirage.core.LayoutNode.margin","mirage.core.LayoutNode.width","mirage.core.LayoutNode.height","mirage.core.LayoutNode.minWidth","mirage.core.LayoutNode.minHeight","mirage.core.LayoutNode.maxWidth","mirage.core.LayoutNode.maxHeight","mirage.core.LayoutNode.horizontalAlignment","mirage.core.LayoutNode.verticalAlignment","mirage.core.LayoutNode.getAttached","mirage.core.LayoutNode.setAttached","mirage.core.LayoutNode.setParent","mirage.core.LayoutNode.onDetached","mirage.core.LayoutNode.onAttached","mirage.core.LayoutNode.walkDeep","mirage.core.LayoutNode.walkDeep.step","mirage.core.LayoutNode.walkDeep.skipBranch","mirage.core.LayoutNode.invalidateMeasure","mirage.core.LayoutNode.doMeasure","mirage.core.LayoutNode.measure","mirage.core.LayoutNode.measureOverride","mirage.core.LayoutNode.invalidateArrange","mirage.core.LayoutNode.doArrange","mirage.core.LayoutNode.arrange","mirage.core.LayoutNode.arrangeOverride","mirage.core.LayoutNode.slot","mirage.createNodeByType","mirage.registerNodeType","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","mirage.NewPanelTree","mirage.NewPanelTree.step","mirage.Panel","mirage.Panel.constructor","mirage.Panel.createTree","mirage.Panel.measureOverride","mirage.Panel.arrangeOverride","mirage.Panel.childCount","mirage.Panel.insertChild","mirage.Panel.prependChild","mirage.Panel.appendChild","mirage.Panel.removeChild","mirage.Panel.removeChildAt","mirage.Panel.getChildAt","mirage.Thickness","mirage.Thickness.constructor","mirage.Thickness.isEqual","mirage.Thickness.growSize","mirage.Thickness.shrinkSize","mirage.Thickness.shrinkRect","mirage.convert","mirage.convert.register","mirage.convert.getConverter","mirage.map","mirage.map.getSetter","mirage.map.getMapper","mirage.map.registerNormal","mirage.map.registerCustom","mirage.convertCanvasCoord","mirage.Canvas","mirage.Canvas.constructor","mirage.Canvas.getLeft","mirage.Canvas.setLeft","mirage.Canvas.getTop","mirage.Canvas.setTop","mirage.Canvas.measureOverride","mirage.Canvas.arrangeOverride","mirage.HorizontalAlignment","mirage.VerticalAlignment","mirage.Orientation","mirage.NewRowDefinitions","mirage.NewRowDefinition","mirage.NewRowDefinition.getActualHeight","mirage.NewRowDefinition.setActualHeight","mirage.NewColumnDefinitions","mirage.NewColumnDefinition","mirage.NewColumnDefinition.getActualWidth","mirage.NewColumnDefinition.setActualWidth","mirage.invalidateCell","mirage.convertGridCell","mirage.Grid","mirage.Grid.constructor","mirage.Grid.getColumn","mirage.Grid.setColumn","mirage.Grid.getColumnSpan","mirage.Grid.setColumnSpan","mirage.Grid.getRow","mirage.Grid.setRow","mirage.Grid.getRowSpan","mirage.Grid.setRowSpan","mirage.Grid.init","mirage.Grid.rowDefinitions","mirage.Grid.columnDefinitions","mirage.Grid.createInputs","mirage.Grid.createState","mirage.Grid.measureOverride","mirage.Grid.arrangeOverride","mirage.parseGridLength","mirage.GridUnitType","mirage.adapters","mirage.adapters.register","mirage.adapters.unregister","mirage.adapters.updateSlots","mirage.Point","mirage.Point.constructor","mirage.Point.isEqual","mirage.Point.copyTo","mirage.Point.round","mirage.Rect","mirage.Rect.constructor","mirage.Rect.clear","mirage.Rect.isEqual","mirage.Rect.isEmpty","mirage.Rect.copyTo","mirage.Rect.isUndef","mirage.Rect.undef","mirage.Size","mirage.Size.constructor","mirage.Size.copyTo","mirage.Size.isEqual","mirage.Size.isEmpty","mirage.Size.max","mirage.Size.min","mirage.Size.round","mirage.Size.clear","mirage.Size.isUndef","mirage.Size.undef","mirage.core.booleanDefaultTrue","mirage.core.float","mirage.core.floatDefaultNaN","mirage.core.floatDefaultInfinite","mirage.core.thickness","mirage.core.enumConverter","mirage.core.splitCommaList","mirage.StackPanel","mirage.StackPanel.constructor","mirage.StackPanel.orientation","mirage.StackPanel.createInputs","mirage.StackPanel.measureOverride","mirage.StackPanel.measureVertical","mirage.StackPanel.measureHorizontal","mirage.StackPanel.arrangeOverride","mirage.StackPanel.arrangeVertical","mirage.StackPanel.arrangeHorizontal","mirage.core.NewArranger","mirage.core.NewArranger.calcOffer","mirage.core.NewArranger.calcVisualOffset","inputs","visible","childRect","Rect","useLayoutRounding","x","Math","round","finalRect","y","width","height","copyTo","isFinite","isNaN","console","warn","state","flags","core","LayoutFlags","arrange","isEqual","layoutSlot","Thickness","shrinkRect","margin","offer","calcOffer","arranged","override","Size","vo","calcVisualOffset","Point","arrangedSlot","lastArrangedSlot","slotHint","tree","propagateFlagUp","mirage.core.DefaultLayoutTree","mirage.core.DefaultLayoutTree.applyTemplate","mirage.core.DefaultLayoutTree.propagateFlagUp","mirage.core.DefaultLayoutTree.walk","mirage.core.DefaultLayoutTree.walk.step","mirage.core.LayoutFlags","mirage.core.NewMeasurer","availableSize","measure","last","lastAvailable","isUndef","applyTemplate","arrangeHint","framedSize","shrinkSize","coerceSize","desired","hiddenDesire","growSize","min","desiredSize","mirage.core.coerceSize","mirage.draft","mirage.draft.NewArrangeDrafter","mirage.draft.NewArrangeDrafter.flush","mirage.draft.NewArrangeDrafter.prepare","mirage.draft.NewArrangeDrafter.draft","mirage.draft.NewDrafter","mirage.draft.NewDrafter.runDraft","node","hints","updated","count","MAX_COUNT","runDraft","updater","rootSize","error","mirage.draft.NewMeasureDrafter","mirage.draft.NewMeasureDrafter.prepare","mirage.draft.NewMeasureDrafter.draft","mirage.draft.NewSlotDrafter","mirage.draft.NewSlotDrafter.flush","mirage.draft.NewSlotDrafter.prepare","mirage.draft.NewSlotDrafter.draft","mirage.draft.NewSlotDrafter.notify","mirage.grid","mirage.grid.NewGridArrangeOverride","des","init","arrangeSize","columnDefinitions","rowDefinitions","cr","walker","walk","step","child","current","calcChildRect","mirage.grid.NewGridMeasureOverride","constraint","overrideAutoAuto","overrideStarAuto","overrideAutoStar","overrideStarAuto2","overrideNonStar","overrideRemainingStar","finish","getDesired","mirage.grid.design","mirage.grid.design.NewGridArrangeDesign","mirage.grid.design.NewGridArrangeDesign.init","mirage.grid.design.NewGridArrangeDesign.calcChildRect","mirage.grid.design.originalToOffered","mirage.grid.design.NewGridPlacement","mirage.grid.design.NewGridPlacement.init","mirage.grid.design.NewGridPlacement.add","mirage.grid.design.NewGridPlacement.allocate","mirage.grid.design.NewGridShape","mirage.grid.design.GridChildShape","mirage.grid.design.GridChildShape.init","mirage.grid.design.GridChildShape.shouldMeasurePass","mirage.grid.design.GridChildShape.calcConstraint","mirage.grid.design.helpers","mirage.grid.design.helpers.expand","mirage.grid.design.helpers.assignSize","mirage.grid.design.helpers.calcDesiredToOffered","mirage.grid.design.NewGridDesign","mirage.grid.design.NewGridMeasureDesign","mirage.grid.design.NewGridMeasureDesign.init","mirage.grid.design.NewGridMeasureDesign.measureChild","mirage.grid.design.NewGridMeasureDesign.finishPass","mirage.grid.design.NewGridMeasureDesign.finish","mirage.grid.design.NewGridMeasureDesign.getDesired","mirage.grid.design.ensureMatrix","mirage.grid.design.prepareCols","mirage.grid.design.prepareRows","mirage.grid.design.allocateDesiredSizeFunc","mirage.grid.design.allocateDesiredSizeFunc.hasStarInSpan","mirage.grid.design.allocateDesiredSizeFunc.calcDesired","mirage.grid.design.allocateDesiredSizeFunc.allocSegments","allocSegments","rm","cm","design","helpers","calcDesiredToOffered","mirage.grid.design.NewMeasureOverridePass","i","measureChild","pass","finishPass","mirage.grid.design.MeasureOverridePass","mirage.grid.design.Segment","mirage.grid.design.Segment.constructor","mirage.grid.design.Segment.clamp","mirage.grid.design.Segment.init"],"mappings":"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","file":"mirage.min.js","sourcesContent":["module mirage {\r\n    export var version = '0.1.0';\r\n}","namespace mirage.core {\n    export interface ILayoutNodeInputs {\n        visible: boolean;\n        useLayoutRounding: boolean;\n        margin: Thickness;\n        width: number;\n        height: number;\n        minWidth: number;\n        minHeight: number;\n        maxWidth: number;\n        maxHeight: number;\n        horizontalAlignment: HorizontalAlignment;\n        verticalAlignment: VerticalAlignment;\n        attached: ILayoutNodeAttachedInputs;\n    }\n\n    export interface ILayoutNodeAttachedInputs {\n        [property: string]: any;\n    }\n\n    export interface ILayoutNodeState {\n        flags: LayoutFlags;\n        lastAvailable: ISize;\n        desiredSize: ISize;\n        hiddenDesire: ISize;\n        layoutSlot: IRect;\n        arrangedSlot: IRect;\n        lastArrangedSlot: IRect;\n    }\n\n    export interface ILayoutTreeDeepWalker {\n        current: LayoutNode;\n        step(): boolean;\n        skipBranch();\n    }\n\n    export var DEFAULT_VISIBLE = true;\n    export var DEFAULT_USE_LAYOUT_ROUNDING = true;\n    export var DEFAULT_WIDTH = NaN;\n    export var DEFAULT_HEIGHT = NaN;\n    export var DEFAULT_MIN_WIDTH = 0.0;\n    export var DEFAULT_MIN_HEIGHT = 0.0;\n    export var DEFAULT_MAX_WIDTH = Number.POSITIVE_INFINITY;\n    export var DEFAULT_MAX_HEIGHT = Number.POSITIVE_INFINITY;\n\n    export class LayoutNode {\n        inputs: ILayoutNodeInputs;\n        state: ILayoutNodeState;\n        tree: ILayoutTree;\n\n        private $measurer: core.IMeasurer;\n        private $arranger: core.IArranger;\n\n        constructor() {\n            this.init();\n        }\n\n        init() {\n            Object.defineProperties(this, {\n                \"inputs\": {value: this.createInputs(), writable: false},\n                \"state\": {value: this.createState(), writable: false},\n                \"tree\": {value: this.createTree(), writable: false},\n                \"attached\": {value: {}, writable: false},\n            });\n            this.$measurer = this.createMeasurer();\n            this.$arranger = this.createArranger();\n        }\n\n        protected createInputs(): ILayoutNodeInputs {\n            return {\n                visible: true,\n                useLayoutRounding: true,\n                margin: new Thickness(),\n                width: NaN,\n                height: NaN,\n                minWidth: 0.0,\n                minHeight: 0.0,\n                maxWidth: Number.POSITIVE_INFINITY,\n                maxHeight: Number.POSITIVE_INFINITY,\n                horizontalAlignment: HorizontalAlignment.stretch,\n                verticalAlignment: VerticalAlignment.stretch,\n                attached: {},\n            };\n        }\n\n        protected createState(): ILayoutNodeState {\n            return {\n                flags: LayoutFlags.none,\n                lastAvailable: new Size(NaN, NaN),\n                desiredSize: new Size(),\n                hiddenDesire: new Size(),\n                layoutSlot: new Rect(NaN, NaN, NaN, NaN),\n                arrangedSlot: new Rect(),\n                lastArrangedSlot: new Rect(NaN, NaN, NaN, NaN),\n            };\n        }\n\n        protected createTree(): ILayoutTree {\n            return DefaultLayoutTree();\n        }\n\n        protected createMeasurer(): core.IMeasurer {\n            return core.NewMeasurer(this.inputs, this.state, this.tree, constraint => this.measureOverride(constraint));\n        }\n\n        protected createArranger(): core.IArranger {\n            return core.NewArranger(this.inputs, this.state, this.tree, arrangeSize => this.arrangeOverride(arrangeSize));\n        }\n\n        // PROPERTIES\n\n        get visible(): boolean {\n            return this.inputs.visible;\n        }\n\n        set visible(value: boolean) {\n            if (this.inputs.visible === value)\n                return;\n            this.inputs.visible = value === true;\n            this.invalidateMeasure();\n            var parent = this.tree.parent;\n            if (parent)\n                parent.invalidateMeasure();\n        }\n\n        get useLayoutRounding(): boolean {\n            return this.inputs.useLayoutRounding;\n        }\n\n        set useLayoutRounding(value: boolean) {\n            if (this.inputs.useLayoutRounding === value)\n                return;\n            this.inputs.useLayoutRounding = value === true;\n            this.invalidateMeasure();\n            this.invalidateArrange();\n        }\n\n        get margin(): Thickness {\n            return this.inputs.margin;\n        }\n\n        set margin(value: Thickness) {\n            if (!value) // unset\n                value = new Thickness();\n            if (Thickness.isEqual(this.inputs.margin, value))\n                return;\n            this.inputs.margin = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get width(): number {\n            return this.inputs.width;\n        }\n\n        set width(value: number) {\n            if (value == null) //unset\n                value = DEFAULT_WIDTH;\n            if (this.inputs.width === value)\n                return;\n            this.inputs.width = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get height(): number {\n            return this.inputs.height;\n        }\n\n        set height(value: number) {\n            if (value == null) //unset\n                value = DEFAULT_HEIGHT;\n            if (this.inputs.height === value)\n                return;\n            this.inputs.height = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get minWidth(): number {\n            return this.inputs.minWidth;\n        }\n\n        set minWidth(value: number) {\n            if (value == null) //unset\n                value = DEFAULT_MIN_WIDTH;\n            if (this.inputs.minWidth === value)\n                return;\n            this.inputs.minWidth = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get minHeight(): number {\n            return this.inputs.minHeight;\n        }\n\n        set minHeight(value: number) {\n            if (value == null) //unset\n                value = DEFAULT_MIN_HEIGHT;\n            if (this.inputs.minHeight === value)\n                return;\n            this.inputs.minHeight = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get maxWidth(): number {\n            return this.inputs.maxWidth;\n        }\n\n        set maxWidth(value: number) {\n            if (value == null) //unset\n                value = DEFAULT_MAX_WIDTH;\n            if (this.inputs.maxWidth === value)\n                return;\n            this.inputs.maxWidth = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get maxHeight(): number {\n            return this.inputs.maxHeight;\n        }\n\n        set maxHeight(value: number) {\n            if (value == null) //unset\n                value = DEFAULT_MAX_HEIGHT;\n            if (this.inputs.maxHeight === value)\n                return;\n            this.inputs.maxHeight = value;\n            onNodeSizeInputsChanged(this);\n        }\n\n        get horizontalAlignment(): HorizontalAlignment {\n            return this.inputs.horizontalAlignment;\n        }\n\n        set horizontalAlignment(value: HorizontalAlignment) {\n            value = value || 0; // coerce null, undefined, 0 => 0\n            if (this.inputs.horizontalAlignment === value)\n                return;\n            this.inputs.horizontalAlignment = value;\n            this.invalidateArrange();\n        }\n\n        get verticalAlignment(): VerticalAlignment {\n            return this.inputs.verticalAlignment;\n        }\n\n        set verticalAlignment(value: VerticalAlignment) {\n            value = value || 0; // coerce null, undefined, 0 => 0\n            if (this.inputs.verticalAlignment === value)\n                return;\n            this.inputs.verticalAlignment = value;\n            this.invalidateArrange();\n        }\n\n        // ATTACHED\n\n        getAttached(property: string): any {\n            return this.inputs.attached[property];\n        }\n\n        setAttached(property: string, value: any) {\n            if (value === undefined) {\n                delete this.inputs.attached[property];\n            } else {\n                this.inputs.attached[property] = value;\n            }\n        }\n\n        // TREE\n\n        setParent(parent: LayoutNode) {\n            if (!parent) {\n                if (!this.tree.parent)\n                    return;\n                this.tree.parent = null;\n                this.onDetached();\n            } else {\n                if (parent === this.tree.parent)\n                    return;\n                this.tree.parent = null;\n                this.onDetached();\n                this.tree.parent = parent;\n                this.onAttached();\n            }\n        }\n\n        protected onDetached() {\n            this.invalidateMeasure();\n            if (this.tree.parent)\n                this.tree.parent.invalidateMeasure();\n            Rect.undef(this.state.layoutSlot);\n        }\n\n        protected onAttached() {\n            var state = this.state;\n            Size.undef(state.lastAvailable);\n            Rect.undef(state.layoutSlot);\n            Size.clear(state.arrangedSlot);\n            this.invalidateMeasure();\n            this.invalidateArrange();\n            if ((state.flags & LayoutFlags.slotHint) > 0 || !Rect.isUndef(state.lastArrangedSlot)) {\n                this.tree.propagateFlagUp(LayoutFlags.slotHint);\n            }\n        }\n\n        walkDeep(reverse?: boolean): ILayoutTreeDeepWalker {\n            var last: LayoutNode = undefined;\n            var walkList: LayoutNode[] = [this];\n\n            return {\n                current: undefined,\n                step(): boolean {\n                    if (last) {\n                        for (var subwalker = last.tree.walk(reverse); subwalker.step();) {\n                            walkList.unshift(subwalker.current);\n                        }\n                    }\n\n                    this.current = last = walkList.shift();\n                    return this.current !== undefined;\n                },\n                skipBranch() {\n                    last = undefined;\n                },\n            };\n        }\n\n        // LAYOUT\n\n        invalidateMeasure() {\n            this.state.flags |= LayoutFlags.measure | LayoutFlags.measureHint;\n            this.tree.propagateFlagUp(LayoutFlags.measureHint);\n        }\n\n        doMeasure(): boolean {\n            var parent = this.tree.parent;\n            var available = new Size();\n            Size.copyTo(this.state.lastAvailable, available);\n            if (!parent && Size.isUndef(available))\n                available.width = available.height = Number.POSITIVE_INFINITY;\n\n            var success = false;\n            if (!Size.isUndef(available)) {\n                var oldDesired = new Size();\n                var newDesired = this.state.desiredSize;\n                Size.copyTo(newDesired, oldDesired);\n                success = this.$measurer(available);\n                if (Size.isEqual(oldDesired, newDesired))\n                    return success;\n            }\n\n            if (parent)\n                parent.invalidateMeasure();\n\n            this.state.flags &= ~LayoutFlags.measure;\n            return success;\n        }\n\n        measure(availableSize: ISize): boolean {\n            return this.$measurer(availableSize);\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            var desired = new Size();\n            for (var walker = this.tree.walk(); walker.step();) {\n                walker.current.measure(constraint);\n                Size.max(desired, walker.current.state.desiredSize);\n            }\n            return desired;\n        }\n\n        invalidateArrange() {\n            this.state.flags |= LayoutFlags.arrange | LayoutFlags.arrangeHint;\n            this.tree.propagateFlagUp(LayoutFlags.arrangeHint);\n        }\n\n        doArrange(rootSize: ISize): boolean {\n            var parent = this.tree.parent;\n            var final = new Rect();\n            if (!parent) {\n                // A root element will always use root size for arrange\n                Size.copyTo(rootSize, final);\n            } else {\n                // If we are starting an arrange from a non-root element,\n                //   our measure developed a desired size that *did not*\n                //   cause a further invalidation up the tree\n                // This means that our desired size *is* our final for arrange\n                Size.copyTo(this.state.desiredSize, final);\n            }\n\n            if (!Rect.isUndef(final))\n                return this.$arranger(final);\n\n            if (parent)\n                parent.invalidateArrange();\n\n            return false;\n        }\n\n        arrange(finalRect: IRect): boolean {\n            return this.$arranger(finalRect);\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            var arranged = new Size(arrangeSize.width, arrangeSize.height);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var childRect = new Rect(0, 0, arrangeSize.width, arrangeSize.height);\n                walker.current.arrange(childRect);\n            }\n            return arranged;\n        }\n\n        slot(oldRect: IRect, newRect: IRect): boolean {\n            var state = this.state;\n            if (!Rect.isUndef(state.lastArrangedSlot))\n                Rect.copyTo(state.lastArrangedSlot, oldRect);\n            Rect.copyTo(state.arrangedSlot, newRect);\n            Rect.undef(state.lastArrangedSlot);\n            // TODO: Set actualWidth, actualHeight\n            return true;\n        }\n    }\n\n    function onNodeSizeInputsChanged(node: core.LayoutNode) {\n        node.invalidateMeasure();\n        node.invalidateArrange();\n        var parent = node.tree.parent;\n        if (parent)\n            parent.invalidateMeasure();\n    }\n}","var mirage;\n(function (mirage) {\n    mirage.version = '0.1.0';\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        core.DEFAULT_VISIBLE = true;\n        core.DEFAULT_USE_LAYOUT_ROUNDING = true;\n        core.DEFAULT_WIDTH = NaN;\n        core.DEFAULT_HEIGHT = NaN;\n        core.DEFAULT_MIN_WIDTH = 0.0;\n        core.DEFAULT_MIN_HEIGHT = 0.0;\n        core.DEFAULT_MAX_WIDTH = Number.POSITIVE_INFINITY;\n        core.DEFAULT_MAX_HEIGHT = Number.POSITIVE_INFINITY;\n        var LayoutNode = (function () {\n            function LayoutNode() {\n                this.init();\n            }\n            LayoutNode.prototype.init = function () {\n                Object.defineProperties(this, {\n                    \"inputs\": { value: this.createInputs(), writable: false },\n                    \"state\": { value: this.createState(), writable: false },\n                    \"tree\": { value: this.createTree(), writable: false },\n                    \"attached\": { value: {}, writable: false },\n                });\n                this.$measurer = this.createMeasurer();\n                this.$arranger = this.createArranger();\n            };\n            LayoutNode.prototype.createInputs = function () {\n                return {\n                    visible: true,\n                    useLayoutRounding: true,\n                    margin: new mirage.Thickness(),\n                    width: NaN,\n                    height: NaN,\n                    minWidth: 0.0,\n                    minHeight: 0.0,\n                    maxWidth: Number.POSITIVE_INFINITY,\n                    maxHeight: Number.POSITIVE_INFINITY,\n                    horizontalAlignment: mirage.HorizontalAlignment.stretch,\n                    verticalAlignment: mirage.VerticalAlignment.stretch,\n                    attached: {},\n                };\n            };\n            LayoutNode.prototype.createState = function () {\n                return {\n                    flags: core.LayoutFlags.none,\n                    lastAvailable: new mirage.Size(NaN, NaN),\n                    desiredSize: new mirage.Size(),\n                    hiddenDesire: new mirage.Size(),\n                    layoutSlot: new mirage.Rect(NaN, NaN, NaN, NaN),\n                    arrangedSlot: new mirage.Rect(),\n                    lastArrangedSlot: new mirage.Rect(NaN, NaN, NaN, NaN),\n                };\n            };\n            LayoutNode.prototype.createTree = function () {\n                return core.DefaultLayoutTree();\n            };\n            LayoutNode.prototype.createMeasurer = function () {\n                var _this = this;\n                return core.NewMeasurer(this.inputs, this.state, this.tree, function (constraint) { return _this.measureOverride(constraint); });\n            };\n            LayoutNode.prototype.createArranger = function () {\n                var _this = this;\n                return core.NewArranger(this.inputs, this.state, this.tree, function (arrangeSize) { return _this.arrangeOverride(arrangeSize); });\n            };\n            Object.defineProperty(LayoutNode.prototype, \"visible\", {\n                get: function () {\n                    return this.inputs.visible;\n                },\n                set: function (value) {\n                    if (this.inputs.visible === value)\n                        return;\n                    this.inputs.visible = value === true;\n                    this.invalidateMeasure();\n                    var parent = this.tree.parent;\n                    if (parent)\n                        parent.invalidateMeasure();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"useLayoutRounding\", {\n                get: function () {\n                    return this.inputs.useLayoutRounding;\n                },\n                set: function (value) {\n                    if (this.inputs.useLayoutRounding === value)\n                        return;\n                    this.inputs.useLayoutRounding = value === true;\n                    this.invalidateMeasure();\n                    this.invalidateArrange();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"margin\", {\n                get: function () {\n                    return this.inputs.margin;\n                },\n                set: function (value) {\n                    if (!value)\n                        value = new mirage.Thickness();\n                    if (mirage.Thickness.isEqual(this.inputs.margin, value))\n                        return;\n                    this.inputs.margin = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"width\", {\n                get: function () {\n                    return this.inputs.width;\n                },\n                set: function (value) {\n                    if (value == null)\n                        value = core.DEFAULT_WIDTH;\n                    if (this.inputs.width === value)\n                        return;\n                    this.inputs.width = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"height\", {\n                get: function () {\n                    return this.inputs.height;\n                },\n                set: function (value) {\n                    if (value == null)\n                        value = core.DEFAULT_HEIGHT;\n                    if (this.inputs.height === value)\n                        return;\n                    this.inputs.height = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"minWidth\", {\n                get: function () {\n                    return this.inputs.minWidth;\n                },\n                set: function (value) {\n                    if (value == null)\n                        value = core.DEFAULT_MIN_WIDTH;\n                    if (this.inputs.minWidth === value)\n                        return;\n                    this.inputs.minWidth = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"minHeight\", {\n                get: function () {\n                    return this.inputs.minHeight;\n                },\n                set: function (value) {\n                    if (value == null)\n                        value = core.DEFAULT_MIN_HEIGHT;\n                    if (this.inputs.minHeight === value)\n                        return;\n                    this.inputs.minHeight = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"maxWidth\", {\n                get: function () {\n                    return this.inputs.maxWidth;\n                },\n                set: function (value) {\n                    if (value == null)\n                        value = core.DEFAULT_MAX_WIDTH;\n                    if (this.inputs.maxWidth === value)\n                        return;\n                    this.inputs.maxWidth = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"maxHeight\", {\n                get: function () {\n                    return this.inputs.maxHeight;\n                },\n                set: function (value) {\n                    if (value == null)\n                        value = core.DEFAULT_MAX_HEIGHT;\n                    if (this.inputs.maxHeight === value)\n                        return;\n                    this.inputs.maxHeight = value;\n                    onNodeSizeInputsChanged(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"horizontalAlignment\", {\n                get: function () {\n                    return this.inputs.horizontalAlignment;\n                },\n                set: function (value) {\n                    value = value || 0;\n                    if (this.inputs.horizontalAlignment === value)\n                        return;\n                    this.inputs.horizontalAlignment = value;\n                    this.invalidateArrange();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(LayoutNode.prototype, \"verticalAlignment\", {\n                get: function () {\n                    return this.inputs.verticalAlignment;\n                },\n                set: function (value) {\n                    value = value || 0;\n                    if (this.inputs.verticalAlignment === value)\n                        return;\n                    this.inputs.verticalAlignment = value;\n                    this.invalidateArrange();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            LayoutNode.prototype.getAttached = function (property) {\n                return this.inputs.attached[property];\n            };\n            LayoutNode.prototype.setAttached = function (property, value) {\n                if (value === undefined) {\n                    delete this.inputs.attached[property];\n                }\n                else {\n                    this.inputs.attached[property] = value;\n                }\n            };\n            LayoutNode.prototype.setParent = function (parent) {\n                if (!parent) {\n                    if (!this.tree.parent)\n                        return;\n                    this.tree.parent = null;\n                    this.onDetached();\n                }\n                else {\n                    if (parent === this.tree.parent)\n                        return;\n                    this.tree.parent = null;\n                    this.onDetached();\n                    this.tree.parent = parent;\n                    this.onAttached();\n                }\n            };\n            LayoutNode.prototype.onDetached = function () {\n                this.invalidateMeasure();\n                if (this.tree.parent)\n                    this.tree.parent.invalidateMeasure();\n                mirage.Rect.undef(this.state.layoutSlot);\n            };\n            LayoutNode.prototype.onAttached = function () {\n                var state = this.state;\n                mirage.Size.undef(state.lastAvailable);\n                mirage.Rect.undef(state.layoutSlot);\n                mirage.Size.clear(state.arrangedSlot);\n                this.invalidateMeasure();\n                this.invalidateArrange();\n                if ((state.flags & core.LayoutFlags.slotHint) > 0 || !mirage.Rect.isUndef(state.lastArrangedSlot)) {\n                    this.tree.propagateFlagUp(core.LayoutFlags.slotHint);\n                }\n            };\n            LayoutNode.prototype.walkDeep = function (reverse) {\n                var last = undefined;\n                var walkList = [this];\n                return {\n                    current: undefined,\n                    step: function () {\n                        if (last) {\n                            for (var subwalker = last.tree.walk(reverse); subwalker.step();) {\n                                walkList.unshift(subwalker.current);\n                            }\n                        }\n                        this.current = last = walkList.shift();\n                        return this.current !== undefined;\n                    },\n                    skipBranch: function () {\n                        last = undefined;\n                    },\n                };\n            };\n            LayoutNode.prototype.invalidateMeasure = function () {\n                this.state.flags |= core.LayoutFlags.measure | core.LayoutFlags.measureHint;\n                this.tree.propagateFlagUp(core.LayoutFlags.measureHint);\n            };\n            LayoutNode.prototype.doMeasure = function () {\n                var parent = this.tree.parent;\n                var available = new mirage.Size();\n                mirage.Size.copyTo(this.state.lastAvailable, available);\n                if (!parent && mirage.Size.isUndef(available))\n                    available.width = available.height = Number.POSITIVE_INFINITY;\n                var success = false;\n                if (!mirage.Size.isUndef(available)) {\n                    var oldDesired = new mirage.Size();\n                    var newDesired = this.state.desiredSize;\n                    mirage.Size.copyTo(newDesired, oldDesired);\n                    success = this.$measurer(available);\n                    if (mirage.Size.isEqual(oldDesired, newDesired))\n                        return success;\n                }\n                if (parent)\n                    parent.invalidateMeasure();\n                this.state.flags &= ~core.LayoutFlags.measure;\n                return success;\n            };\n            LayoutNode.prototype.measure = function (availableSize) {\n                return this.$measurer(availableSize);\n            };\n            LayoutNode.prototype.measureOverride = function (constraint) {\n                var desired = new mirage.Size();\n                for (var walker = this.tree.walk(); walker.step();) {\n                    walker.current.measure(constraint);\n                    mirage.Size.max(desired, walker.current.state.desiredSize);\n                }\n                return desired;\n            };\n            LayoutNode.prototype.invalidateArrange = function () {\n                this.state.flags |= core.LayoutFlags.arrange | core.LayoutFlags.arrangeHint;\n                this.tree.propagateFlagUp(core.LayoutFlags.arrangeHint);\n            };\n            LayoutNode.prototype.doArrange = function (rootSize) {\n                var parent = this.tree.parent;\n                var final = new mirage.Rect();\n                if (!parent) {\n                    mirage.Size.copyTo(rootSize, final);\n                }\n                else {\n                    mirage.Size.copyTo(this.state.desiredSize, final);\n                }\n                if (!mirage.Rect.isUndef(final))\n                    return this.$arranger(final);\n                if (parent)\n                    parent.invalidateArrange();\n                return false;\n            };\n            LayoutNode.prototype.arrange = function (finalRect) {\n                return this.$arranger(finalRect);\n            };\n            LayoutNode.prototype.arrangeOverride = function (arrangeSize) {\n                var arranged = new mirage.Size(arrangeSize.width, arrangeSize.height);\n                for (var walker = this.tree.walk(); walker.step();) {\n                    var childRect = new mirage.Rect(0, 0, arrangeSize.width, arrangeSize.height);\n                    walker.current.arrange(childRect);\n                }\n                return arranged;\n            };\n            LayoutNode.prototype.slot = function (oldRect, newRect) {\n                var state = this.state;\n                if (!mirage.Rect.isUndef(state.lastArrangedSlot))\n                    mirage.Rect.copyTo(state.lastArrangedSlot, oldRect);\n                mirage.Rect.copyTo(state.arrangedSlot, newRect);\n                mirage.Rect.undef(state.lastArrangedSlot);\n                return true;\n            };\n            return LayoutNode;\n        })();\n        core.LayoutNode = LayoutNode;\n        function onNodeSizeInputsChanged(node) {\n            node.invalidateMeasure();\n            node.invalidateArrange();\n            var parent = node.tree.parent;\n            if (parent)\n                parent.invalidateMeasure();\n        }\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var typeCreators = {};\n    function createNodeByType(type) {\n        var creator = typeCreators[type];\n        if (!creator)\n            return new mirage.core.LayoutNode();\n        return new creator();\n    }\n    mirage.createNodeByType = createNodeByType;\n    function registerNodeType(type, creator) {\n        if (typeCreators[type]) {\n            console.warn(\"[mirage] Overriding type registration for \" + type);\n        }\n        typeCreators[type] = creator;\n    }\n    mirage.registerNodeType = registerNodeType;\n})(mirage || (mirage = {}));\n/// <reference path=\"core/LayoutNode\" />\n/// <reference path=\"typeLookup\" />\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar mirage;\n(function (mirage) {\n    var Panel = (function (_super) {\n        __extends(Panel, _super);\n        function Panel() {\n            _super.apply(this, arguments);\n        }\n        Panel.prototype.createTree = function () {\n            return NewPanelTree();\n        };\n        Panel.prototype.measureOverride = function (constraint) {\n            return new mirage.Size(constraint.width, constraint.height);\n        };\n        Panel.prototype.arrangeOverride = function (arrangeSize) {\n            return new mirage.Size(arrangeSize.width, arrangeSize.height);\n        };\n        Object.defineProperty(Panel.prototype, \"childCount\", {\n            get: function () {\n                return this.tree.children.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Panel.prototype.insertChild = function (child, index) {\n            var children = this.tree.children;\n            if (index >= children.length) {\n                this.appendChild(child);\n            }\n            else if (index <= 0) {\n                this.prependChild(child);\n            }\n            else {\n                children.splice(index, 0, child);\n                child.setParent(this);\n            }\n        };\n        Panel.prototype.prependChild = function (child) {\n            this.tree.children.unshift(child);\n            child.setParent(this);\n        };\n        Panel.prototype.appendChild = function (child) {\n            this.tree.children.push(child);\n            child.setParent(this);\n        };\n        Panel.prototype.removeChild = function (child) {\n            var children = this.tree.children;\n            var index = children.indexOf(child);\n            if (index < 0)\n                return false;\n            this.tree.children.splice(index, 1);\n            child.setParent(null);\n            return true;\n        };\n        Panel.prototype.removeChildAt = function (index) {\n            var children = this.tree.children;\n            if (index < 0 || index >= children.length)\n                return null;\n            var removed = children.splice(index, 1)[0];\n            if (removed)\n                removed.setParent(null);\n            return removed;\n        };\n        Panel.prototype.getChildAt = function (index) {\n            return this.tree.children[index];\n        };\n        return Panel;\n    })(mirage.core.LayoutNode);\n    mirage.Panel = Panel;\n    mirage.registerNodeType(\"panel\", Panel);\n    function NewPanelTree() {\n        var tree = mirage.core.DefaultLayoutTree();\n        tree.children = [];\n        tree.walk = function (reverse) {\n            if (!reverse) {\n                var i = -1;\n                return {\n                    current: undefined,\n                    step: function () {\n                        i++;\n                        if (i >= tree.children.length) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                };\n            }\n            else {\n                var i = tree.children.length;\n                return {\n                    current: undefined,\n                    step: function () {\n                        i--;\n                        if (i < 0) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                };\n            }\n        };\n        return tree;\n    }\n    mirage.NewPanelTree = NewPanelTree;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var Thickness = (function () {\n        function Thickness(left, top, right, bottom) {\n            this.left = left == null ? 0 : left;\n            this.top = top == null ? 0 : top;\n            this.right = right == null ? 0 : right;\n            this.bottom = bottom == null ? 0 : bottom;\n        }\n        Thickness.isEqual = function (t1, t2) {\n            return t1.left === t2.left\n                && t1.top === t2.top\n                && t1.right === t2.right\n                && t1.bottom === t2.bottom;\n        };\n        Thickness.growSize = function (thickness, dest) {\n            var w = dest.width;\n            var h = dest.height;\n            if (w != Number.POSITIVE_INFINITY)\n                w += thickness.left + thickness.right;\n            if (h != Number.POSITIVE_INFINITY)\n                h += thickness.top + thickness.bottom;\n            dest.width = w > 0 ? w : 0;\n            dest.height = h > 0 ? h : 0;\n            return dest;\n        };\n        Thickness.shrinkSize = function (thickness, dest) {\n            var w = dest.width;\n            var h = dest.height;\n            if (w != Number.POSITIVE_INFINITY)\n                w -= thickness.left + thickness.right;\n            if (h != Number.POSITIVE_INFINITY)\n                h -= thickness.top + thickness.bottom;\n            dest.width = w > 0 ? w : 0;\n            dest.height = h > 0 ? h : 0;\n            return dest;\n        };\n        Thickness.shrinkRect = function (thickness, dest) {\n            dest.x += thickness.left;\n            dest.y += thickness.top;\n            dest.width -= thickness.left + thickness.right;\n            dest.height -= thickness.top + thickness.bottom;\n            if (dest.width < 0)\n                dest.width = 0;\n            if (dest.height < 0)\n                dest.height = 0;\n        };\n        return Thickness;\n    })();\n    mirage.Thickness = Thickness;\n})(mirage || (mirage = {}));\n/// <reference path=\"../Thickness\" />\nvar mirage;\n(function (mirage) {\n    var convert;\n    (function (convert) {\n        var converters = {};\n        function register(property, converter) {\n            converters[property] = converter;\n        }\n        convert.register = register;\n        function getConverter(property) {\n            return converters[property];\n        }\n        convert.getConverter = getConverter;\n    })(convert = mirage.convert || (mirage.convert = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../convert/converters\" />\nvar mirage;\n(function (mirage) {\n    var map;\n    (function (map) {\n        var setters = {};\n        var mappers = {};\n        function getSetter(property) {\n            return setters[property];\n        }\n        map.getSetter = getSetter;\n        function getMapper(property) {\n            return mappers[property];\n        }\n        map.getMapper = getMapper;\n        function registerNormal(property, key) {\n            setters[property] = function (node, value) { return node[key] = value; };\n            var converter = mirage.convert.getConverter(property);\n            mappers[property] = function (node, value) { return node[key] = converter(value); };\n        }\n        map.registerNormal = registerNormal;\n        function registerCustom(property, setter) {\n            setters[property] = setter;\n            var converter = mirage.convert.getConverter(property);\n            mappers[property] = function (node, value) { return setter(node, converter(value)); };\n        }\n        map.registerCustom = registerCustom;\n    })(map = mirage.map || (mirage.map = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"Panel\" />\n/// <reference path=\"typeLookup\" />\n/// <reference path=\"convert/converters\" />\n/// <reference path=\"map/mappers\" />\nvar mirage;\n(function (mirage) {\n    var Canvas = (function (_super) {\n        __extends(Canvas, _super);\n        function Canvas() {\n            _super.apply(this, arguments);\n        }\n        Canvas.getLeft = function (node) {\n            return node.getAttached(\"canvas.left\");\n        };\n        Canvas.setLeft = function (node, value) {\n            node.setAttached(\"canvas.left\", value);\n            node.invalidateArrange();\n        };\n        Canvas.getTop = function (node) {\n            return node.getAttached(\"canvas.top\");\n        };\n        Canvas.setTop = function (node, value) {\n            node.setAttached(\"canvas.top\", value);\n            node.invalidateArrange();\n        };\n        Canvas.prototype.measureOverride = function (constraint) {\n            var available = new mirage.Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            for (var walker = this.tree.walk(); walker.step();) {\n                walker.current.measure(available);\n            }\n            return new mirage.Size();\n        };\n        Canvas.prototype.arrangeOverride = function (arrangeSize) {\n            var cr = new mirage.Rect();\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                cr.x = Canvas.getLeft(child) || 0;\n                cr.y = Canvas.getTop(child) || 0;\n                mirage.Size.copyTo(child.state.desiredSize, cr);\n                child.arrange(cr);\n            }\n            return arrangeSize;\n        };\n        return Canvas;\n    })(mirage.Panel);\n    mirage.Canvas = Canvas;\n    mirage.registerNodeType(\"canvas\", Canvas);\n    mirage.convert.register(\"canvas.left\", convertCanvasCoord);\n    mirage.convert.register(\"canvas.top\", convertCanvasCoord);\n    mirage.map.registerCustom(\"canvas.left\", Canvas.setLeft);\n    mirage.map.registerCustom(\"canvas.top\", Canvas.setTop);\n    function convertCanvasCoord(value) {\n        if (!value)\n            return 0;\n        return parseFloat(value);\n    }\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    (function (HorizontalAlignment) {\n        HorizontalAlignment[HorizontalAlignment[\"stretch\"] = 0] = \"stretch\";\n        HorizontalAlignment[HorizontalAlignment[\"left\"] = 1] = \"left\";\n        HorizontalAlignment[HorizontalAlignment[\"center\"] = 2] = \"center\";\n        HorizontalAlignment[HorizontalAlignment[\"right\"] = 3] = \"right\";\n    })(mirage.HorizontalAlignment || (mirage.HorizontalAlignment = {}));\n    var HorizontalAlignment = mirage.HorizontalAlignment;\n    (function (VerticalAlignment) {\n        VerticalAlignment[VerticalAlignment[\"stretch\"] = 0] = \"stretch\";\n        VerticalAlignment[VerticalAlignment[\"top\"] = 1] = \"top\";\n        VerticalAlignment[VerticalAlignment[\"center\"] = 2] = \"center\";\n        VerticalAlignment[VerticalAlignment[\"bottom\"] = 3] = \"bottom\";\n    })(mirage.VerticalAlignment || (mirage.VerticalAlignment = {}));\n    var VerticalAlignment = mirage.VerticalAlignment;\n    (function (Orientation) {\n        Orientation[Orientation[\"horizontal\"] = 0] = \"horizontal\";\n        Orientation[Orientation[\"vertical\"] = 1] = \"vertical\";\n    })(mirage.Orientation || (mirage.Orientation = {}));\n    var Orientation = mirage.Orientation;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    function NewRowDefinitions(defs) {\n        var rowdefs = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            var token = tokens[i];\n            if (token === \" \")\n                continue;\n            rowdefs.push(NewRowDefinition(token));\n        }\n        return rowdefs;\n    }\n    mirage.NewRowDefinitions = NewRowDefinitions;\n    function NewRowDefinition() {\n        var len;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n        switch (arguments.length) {\n            case 1:\n                len = mirage.parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = mirage.parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: mirage.GridUnitType.star,\n                };\n                break;\n        }\n        var actual = NaN;\n        return {\n            height: len,\n            minHeight: min,\n            maxHeight: max,\n            getActualHeight: function () {\n                return actual;\n            },\n            setActualHeight: function (value) {\n                actual = value;\n            },\n        };\n    }\n    mirage.NewRowDefinition = NewRowDefinition;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    function NewColumnDefinitions(defs) {\n        var coldefs = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            var token = tokens[i];\n            if (token === \" \")\n                continue;\n            coldefs.push(NewColumnDefinition(token));\n        }\n        return coldefs;\n    }\n    mirage.NewColumnDefinitions = NewColumnDefinitions;\n    function NewColumnDefinition() {\n        var len;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n        switch (arguments.length) {\n            case 1:\n                len = mirage.parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = mirage.parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: mirage.GridUnitType.star,\n                };\n                break;\n        }\n        var actual = NaN;\n        return {\n            width: len,\n            minWidth: min,\n            maxWidth: max,\n            getActualWidth: function () {\n                return actual;\n            },\n            setActualWidth: function (value) {\n                actual = value;\n            },\n        };\n    }\n    mirage.NewColumnDefinition = NewColumnDefinition;\n})(mirage || (mirage = {}));\n/// <reference path=\"Panel\" />\n/// <reference path=\"typeLookup\" />\n/// <reference path=\"convert/converters\" />\n/// <reference path=\"map/mappers\" />\n/// <reference path=\"IRowDefinition\" />\n/// <reference path=\"IColumnDefinition\" />\nvar mirage;\n(function (mirage) {\n    var Grid = (function (_super) {\n        __extends(Grid, _super);\n        function Grid() {\n            _super.apply(this, arguments);\n        }\n        Grid.getColumn = function (node) {\n            return node.getAttached(\"grid.column\");\n        };\n        Grid.setColumn = function (node, value) {\n            node.setAttached(\"grid.column\", value);\n            invalidateCell(node);\n        };\n        Grid.getColumnSpan = function (node) {\n            return node.getAttached(\"grid.column-span\");\n        };\n        Grid.setColumnSpan = function (node, value) {\n            node.setAttached(\"grid.column-span\", value);\n            invalidateCell(node);\n        };\n        Grid.getRow = function (node) {\n            return node.getAttached(\"grid.row\");\n        };\n        Grid.setRow = function (node, value) {\n            node.setAttached(\"grid.row\", value);\n            invalidateCell(node);\n        };\n        Grid.getRowSpan = function (node) {\n            return node.getAttached(\"grid.row-span\");\n        };\n        Grid.setRowSpan = function (node, value) {\n            node.setAttached(\"grid.row-span\", value);\n            invalidateCell(node);\n        };\n        Grid.prototype.init = function () {\n            _super.prototype.init.call(this);\n            this.$measureOverride = mirage.grid.NewGridMeasureOverride(this.inputs, this.state, this.tree);\n            this.$arrangeOverride = mirage.grid.NewGridArrangeOverride(this.inputs, this.state, this.tree);\n        };\n        Object.defineProperty(Grid.prototype, \"rowDefinitions\", {\n            get: function () {\n                return this.inputs.rowDefinitions;\n            },\n            set: function (value) {\n                if (!value)\n                    value = [];\n                this.inputs.rowDefinitions = value;\n                this.invalidateMeasure();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Grid.prototype, \"columnDefinitions\", {\n            get: function () {\n                return this.inputs.columnDefinitions;\n            },\n            set: function (value) {\n                if (!value)\n                    value = [];\n                this.inputs.columnDefinitions = value;\n                this.invalidateMeasure();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Grid.prototype.createInputs = function () {\n            var inputs = _super.prototype.createInputs.call(this);\n            inputs.rowDefinitions = [];\n            inputs.columnDefinitions = [];\n            return inputs;\n        };\n        Grid.prototype.createState = function () {\n            var state = _super.prototype.createState.call(this);\n            state.design = mirage.grid.design.NewGridDesign();\n            return state;\n        };\n        Grid.prototype.measureOverride = function (constraint) {\n            return this.$measureOverride(constraint);\n        };\n        Grid.prototype.arrangeOverride = function (arrangeSize) {\n            return this.$arrangeOverride(arrangeSize);\n        };\n        return Grid;\n    })(mirage.Panel);\n    mirage.Grid = Grid;\n    mirage.registerNodeType(\"grid\", Grid);\n    mirage.convert.register(\"row-definitions\", mirage.NewRowDefinitions);\n    mirage.convert.register(\"column-definitions\", mirage.NewColumnDefinitions);\n    mirage.convert.register(\"grid.row\", convertGridCell);\n    mirage.convert.register(\"grid.row-span\", convertGridCell);\n    mirage.convert.register(\"grid.column\", convertGridCell);\n    mirage.convert.register(\"grid.column-span\", convertGridCell);\n    mirage.map.registerNormal(\"row-definitions\", \"rowDefinitions\");\n    mirage.map.registerNormal(\"column-definitions\", \"columnDefinitions\");\n    mirage.map.registerCustom(\"grid.row\", Grid.setRow);\n    mirage.map.registerCustom(\"grid.row-span\", Grid.setRowSpan);\n    mirage.map.registerCustom(\"grid.column\", Grid.setColumn);\n    mirage.map.registerCustom(\"grid.column-span\", Grid.setColumnSpan);\n    function invalidateCell(node) {\n        var parent = node.tree.parent;\n        if (parent instanceof Grid)\n            parent.invalidateMeasure();\n        node.invalidateMeasure();\n    }\n    function convertGridCell(value) {\n        if (!value)\n            return 0;\n        return parseInt(value);\n    }\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    (function (GridUnitType) {\n        GridUnitType[GridUnitType[\"auto\"] = 0] = \"auto\";\n        GridUnitType[GridUnitType[\"pixel\"] = 1] = \"pixel\";\n        GridUnitType[GridUnitType[\"star\"] = 2] = \"star\";\n    })(mirage.GridUnitType || (mirage.GridUnitType = {}));\n    var GridUnitType = mirage.GridUnitType;\n    function parseGridLength(s) {\n        var auto = { value: 0, type: GridUnitType.auto };\n        if (s === \"auto\") {\n            return auto;\n        }\n        if (s[s.length - 1] === \"*\") {\n            if (s.length === 1)\n                return { value: 1, type: GridUnitType.star };\n            return {\n                value: parseInt(s.substr(0, s.length - 1)),\n                type: GridUnitType.star,\n            };\n        }\n        return {\n            value: parseInt(s),\n            type: GridUnitType.pixel,\n        };\n    }\n    mirage.parseGridLength = parseGridLength;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var adapters;\n    (function (adapters) {\n        var registered = [];\n        function register(adapter) {\n            if (registered.indexOf(adapter) < 0) {\n                registered.push(adapter);\n            }\n        }\n        adapters.register = register;\n        function unregister(adapter) {\n            var index = registered.indexOf(adapter);\n            if (index > -1)\n                registered.splice(index, 1);\n        }\n        adapters.unregister = unregister;\n        function updateSlots(updates) {\n            for (var i = 0; i < registered.length; i++) {\n                registered[i].updateSlots(updates);\n            }\n        }\n        adapters.updateSlots = updateSlots;\n    })(adapters = mirage.adapters || (mirage.adapters = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var Point = (function () {\n        function Point(x, y) {\n            this.x = x == null ? 0 : x;\n            this.y = y == null ? 0 : y;\n        }\n        Point.isEqual = function (p1, p2) {\n            return p1.x === p2.x\n                && p1.y === p2.y;\n        };\n        Point.copyTo = function (src, dest) {\n            dest.x = src.x;\n            dest.y = src.y;\n        };\n        Point.round = function (dest) {\n            dest.x = Math.round(dest.x);\n            dest.y = Math.round(dest.y);\n        };\n        return Point;\n    })();\n    mirage.Point = Point;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var Rect = (function () {\n        function Rect(x, y, width, height) {\n            this.x = x == null ? 0 : x;\n            this.y = y == null ? 0 : y;\n            this.width = width == null ? 0 : width;\n            this.height = height == null ? 0 : height;\n        }\n        Rect.clear = function (rect) {\n            rect.x = rect.y = rect.width = rect.height = 0;\n        };\n        Rect.isEqual = function (rect1, rect2) {\n            return rect1.x === rect2.x\n                && rect1.y === rect2.y\n                && rect1.width === rect2.width\n                && rect1.height === rect2.height;\n        };\n        Rect.isEmpty = function (src) {\n            return src.width === 0\n                || src.height === 0;\n        };\n        Rect.copyTo = function (src, dest) {\n            dest.x = src.x;\n            dest.y = src.y;\n            dest.width = src.width;\n            dest.height = src.height;\n        };\n        Rect.isUndef = function (rect) {\n            return isNaN(rect.x)\n                && isNaN(rect.y)\n                && isNaN(rect.width)\n                && isNaN(rect.height);\n        };\n        Rect.undef = function (rect) {\n            rect.x = NaN;\n            rect.y = NaN;\n            rect.width = NaN;\n            rect.height = NaN;\n        };\n        return Rect;\n    })();\n    mirage.Rect = Rect;\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var Size = (function () {\n        function Size(width, height) {\n            this.width = width == null ? 0 : width;\n            this.height = height == null ? 0 : height;\n        }\n        Size.copyTo = function (src, dest) {\n            dest.width = src.width;\n            dest.height = src.height;\n        };\n        Size.isEqual = function (size1, size2) {\n            return size1.width === size2.width\n                && size1.height === size2.height;\n        };\n        Size.isEmpty = function (size) {\n            return size.width === 0\n                || size.height === 0;\n        };\n        Size.max = function (dest, size2) {\n            dest.width = Math.max(dest.width, size2.width);\n            dest.height = Math.max(dest.height, size2.height);\n        };\n        Size.min = function (dest, size2) {\n            dest.width = Math.min(dest.width, size2.width);\n            dest.height = Math.min(dest.height, size2.height);\n        };\n        Size.round = function (size) {\n            size.width = Math.round(size.width);\n            size.height = Math.round(size.height);\n        };\n        Size.clear = function (size) {\n            size.width = 0;\n            size.height = 0;\n        };\n        Size.isUndef = function (size) {\n            return isNaN(size.width)\n                && isNaN(size.height);\n        };\n        Size.undef = function (size) {\n            size.width = NaN;\n            size.height = NaN;\n        };\n        return Size;\n    })();\n    mirage.Size = Size;\n})(mirage || (mirage = {}));\n/// <reference path=\"../convert/converters\" />\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function booleanDefaultTrue(value) {\n            return value !== \"0\"\n                && value !== \"false\";\n        }\n        function float(value) {\n            if (!value)\n                return 0;\n            return parseFloat(value) || 0;\n        }\n        function floatDefaultNaN(value) {\n            if (!value)\n                return NaN;\n            return parseFloat(value);\n        }\n        function floatDefaultInfinite(value) {\n            if (!value)\n                return Number.POSITIVE_INFINITY;\n            var val = parseFloat(value);\n            if (isNaN(val))\n                return Number.POSITIVE_INFINITY;\n            return val;\n        }\n        function thickness(value) {\n            var tokens = splitCommaList(value);\n            if (tokens.length === 1) {\n                var uniform = parseFloat(tokens[0]);\n                return new mirage.Thickness(uniform, uniform, uniform, uniform);\n            }\n            else if (tokens.length === 2) {\n                var x = parseFloat(tokens[0]);\n                var y = parseFloat(tokens[1]);\n                return new mirage.Thickness(x, y, x, y);\n            }\n            else if (tokens.length === 4) {\n                return new mirage.Thickness(parseFloat(tokens[0]), parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n            }\n            else {\n                console.warn(\"[mirage] Invalid thickness value\", value);\n            }\n        }\n        function enumConverter(src) {\n            return function (value) {\n                if (!value)\n                    return 0;\n                return src[value] || 0;\n            };\n        }\n        core.enumConverter = enumConverter;\n        function splitCommaList(str) {\n            var tokens = [];\n            for (var i = 0, arr = str.split(' ').join(',').split(','); i < arr.length; i++) {\n                var cur = arr[i];\n                if (cur)\n                    tokens.push(cur);\n            }\n            return tokens;\n        }\n        mirage.convert.register(\"visible\", booleanDefaultTrue);\n        mirage.convert.register(\"use-layout-rounding\", booleanDefaultTrue);\n        mirage.convert.register(\"margin\", thickness);\n        mirage.convert.register(\"width\", floatDefaultNaN);\n        mirage.convert.register(\"height\", floatDefaultNaN);\n        mirage.convert.register(\"min-width\", float);\n        mirage.convert.register(\"min-height\", float);\n        mirage.convert.register(\"max-width\", floatDefaultInfinite);\n        mirage.convert.register(\"max-height\", floatDefaultInfinite);\n        mirage.convert.register(\"horizontal-alignment\", enumConverter(mirage.HorizontalAlignment));\n        mirage.convert.register(\"vertical-alignment\", enumConverter(mirage.VerticalAlignment));\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"typeLookup\" />\n/// <reference path=\"convert/converters\" />\n/// <reference path=\"core/converters\" />\n/// <reference path=\"map/mappers\" />\nvar mirage;\n(function (mirage) {\n    var StackPanel = (function (_super) {\n        __extends(StackPanel, _super);\n        function StackPanel() {\n            _super.apply(this, arguments);\n        }\n        Object.defineProperty(StackPanel.prototype, \"orientation\", {\n            get: function () {\n                return this.inputs.orientation;\n            },\n            set: function (value) {\n                value = value || 0;\n                if (this.inputs.orientation === value)\n                    return;\n                this.inputs.orientation = value;\n                this.invalidateMeasure();\n                this.invalidateArrange();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        StackPanel.prototype.createInputs = function () {\n            var inputs = _super.prototype.createInputs.call(this);\n            inputs.orientation = mirage.Orientation.horizontal;\n            return inputs;\n        };\n        StackPanel.prototype.measureOverride = function (constraint) {\n            if (this.inputs.orientation === mirage.Orientation.vertical) {\n                return this.measureVertical(constraint);\n            }\n            else {\n                return this.measureHorizontal(constraint);\n            }\n        };\n        StackPanel.prototype.measureVertical = function (constraint) {\n            var ca = new mirage.Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new mirage.Size();\n            var inputs = this.inputs;\n            ca.width = constraint.width;\n            if (!isNaN(inputs.width))\n                ca.width = inputs.width;\n            ca.width = Math.min(ca.width, inputs.maxWidth);\n            ca.width = Math.max(ca.width, inputs.minWidth);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n                var childDesired = child.state.desiredSize;\n                measured.height += childDesired.height;\n                measured.width = Math.max(measured.width, childDesired.width);\n            }\n            return measured;\n        };\n        StackPanel.prototype.measureHorizontal = function (constraint) {\n            var ca = new mirage.Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new mirage.Size();\n            var inputs = this.inputs;\n            ca.height = constraint.height;\n            if (!isNaN(inputs.height))\n                ca.height = inputs.height;\n            ca.height = Math.min(ca.height, inputs.maxHeight);\n            ca.height = Math.max(ca.height, inputs.minHeight);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n                var childDesired = child.state.desiredSize;\n                measured.width += childDesired.width;\n                measured.height = Math.max(measured.height, childDesired.height);\n            }\n            return measured;\n        };\n        StackPanel.prototype.arrangeOverride = function (arrangeSize) {\n            if (this.inputs.orientation === mirage.Orientation.vertical) {\n                return this.arrangeVertical(arrangeSize);\n            }\n            else {\n                return this.arrangeHorizontal(arrangeSize);\n            }\n        };\n        StackPanel.prototype.arrangeVertical = function (arrangeSize) {\n            var arranged = new mirage.Size(arrangeSize.width, 0);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new mirage.Rect(0, arranged.height, arrangeSize.width, childDesired.height);\n                if (mirage.Rect.isEmpty(childFinal))\n                    mirage.Rect.clear(childFinal);\n                child.arrange(childFinal);\n                arranged.width = Math.max(arranged.width, arrangeSize.width);\n                arranged.height += childDesired.height;\n            }\n            arranged.height = Math.max(arranged.height, arrangeSize.height);\n            return arranged;\n        };\n        StackPanel.prototype.arrangeHorizontal = function (arrangeSize) {\n            var arranged = new mirage.Size(0, arrangeSize.height);\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new mirage.Rect(arranged.width, 0, childDesired.width, arrangeSize.height);\n                if (mirage.Rect.isEmpty(childFinal))\n                    mirage.Rect.clear(childFinal);\n                child.arrange(childFinal);\n                arranged.width += childDesired.width;\n                arranged.height = Math.max(arranged.height, arrangeSize.height);\n            }\n            arranged.width = Math.max(arranged.width, arrangeSize.width);\n            return arranged;\n        };\n        return StackPanel;\n    })(mirage.Panel);\n    mirage.StackPanel = StackPanel;\n    mirage.registerNodeType(\"stack-panel\", StackPanel);\n    mirage.convert.register(\"orientation\", mirage.core.enumConverter(mirage.Orientation));\n    mirage.map.registerNormal(\"orientation\", \"orientation\");\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function NewArranger(inputs, state, tree, override) {\n            function calcOffer(childRect) {\n                var stretched = new mirage.Size(childRect.width, childRect.height);\n                core.coerceSize(stretched, inputs);\n                var framework = new mirage.Size();\n                core.coerceSize(framework, inputs);\n                if (inputs.horizontalAlignment === mirage.HorizontalAlignment.stretch) {\n                    framework.width = Math.max(framework.width, stretched.width);\n                }\n                if (inputs.verticalAlignment === mirage.VerticalAlignment.stretch) {\n                    framework.height = Math.max(framework.height, stretched.height);\n                }\n                var offer = new mirage.Size(state.hiddenDesire.width, state.hiddenDesire.height);\n                mirage.Size.max(offer, framework);\n                return offer;\n            }\n            function calcVisualOffset(childRect, arranged) {\n                var constrained = new mirage.Size(arranged.width, arranged.height);\n                core.coerceSize(constrained, inputs);\n                mirage.Size.min(constrained, arranged);\n                var vo = new mirage.Point();\n                mirage.Point.copyTo(childRect, vo);\n                switch (inputs.horizontalAlignment) {\n                    case mirage.HorizontalAlignment.left:\n                        break;\n                    case mirage.HorizontalAlignment.right:\n                        vo.x += childRect.width - constrained.width;\n                        break;\n                    case mirage.HorizontalAlignment.center:\n                        vo.x += (childRect.width - constrained.width) * 0.5;\n                        break;\n                    default:\n                        vo.x += Math.max((childRect.width - constrained.width) * 0.5, 0);\n                        break;\n                }\n                switch (inputs.verticalAlignment) {\n                    case mirage.VerticalAlignment.top:\n                        break;\n                    case mirage.VerticalAlignment.bottom:\n                        vo.y += childRect.height - constrained.height;\n                        break;\n                    case mirage.VerticalAlignment.center:\n                        vo.y += (childRect.height - constrained.height) * 0.5;\n                        break;\n                    default:\n                        vo.y += Math.max((childRect.height - constrained.height) * 0.5, 0);\n                        break;\n                }\n                if (inputs.useLayoutRounding) {\n                    mirage.Point.round(vo);\n                }\n                return vo;\n            }\n            return function (finalRect) {\n                if (inputs.visible !== true) {\n                    return false;\n                }\n                var childRect = new mirage.Rect();\n                if (inputs.useLayoutRounding) {\n                    childRect.x = Math.round(finalRect.x);\n                    childRect.y = Math.round(finalRect.y);\n                    childRect.width = Math.round(finalRect.width);\n                    childRect.height = Math.round(finalRect.height);\n                }\n                else {\n                    mirage.Rect.copyTo(finalRect, childRect);\n                }\n                if (childRect.width < 0 || childRect.height < 0\n                    || !isFinite(childRect.width) || !isFinite(childRect.height)\n                    || isNaN(childRect.x) || isNaN(childRect.y)\n                    || isNaN(childRect.width) || isNaN(childRect.height)) {\n                    console.warn(\"[mirage] cannot call arrange using rect with NaN/infinite values.\");\n                    return false;\n                }\n                if ((state.flags & core.LayoutFlags.arrange) <= 0) {\n                    return false;\n                }\n                if (mirage.Rect.isEqual(state.layoutSlot, childRect)) {\n                    return false;\n                }\n                mirage.Rect.copyTo(childRect, state.layoutSlot);\n                mirage.Thickness.shrinkRect(inputs.margin, childRect);\n                var offer = calcOffer(childRect);\n                var arranged = override(offer);\n                state.flags &= ~core.LayoutFlags.arrange;\n                if (inputs.useLayoutRounding) {\n                    mirage.Size.round(arranged);\n                }\n                var vo = calcVisualOffset(childRect, arranged);\n                if (!mirage.Point.isEqual(vo, state.arrangedSlot) || !mirage.Size.isEqual(arranged, state.arrangedSlot)) {\n                    mirage.Rect.copyTo(state.arrangedSlot, state.lastArrangedSlot);\n                    state.flags |= core.LayoutFlags.slotHint;\n                    tree.propagateFlagUp(core.LayoutFlags.slotHint);\n                }\n                mirage.Size.copyTo(arranged, state.arrangedSlot);\n                mirage.Point.copyTo(vo, state.arrangedSlot);\n                return true;\n            };\n        }\n        core.NewArranger = NewArranger;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function DefaultLayoutTree() {\n            return {\n                parent: null,\n                applyTemplate: function () {\n                    return true;\n                },\n                propagateFlagUp: function (flag) {\n                    for (var cur = this.parent; !!cur && (cur.state.flags & flag) <= 0; cur = cur.tree.parent) {\n                        cur.state.flags |= flag;\n                    }\n                },\n                walk: function (reverse) {\n                    return {\n                        current: undefined,\n                        step: function () {\n                            return false;\n                        },\n                    };\n                },\n            };\n        }\n        core.DefaultLayoutTree = DefaultLayoutTree;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        (function (LayoutFlags) {\n            LayoutFlags[LayoutFlags[\"none\"] = 0] = \"none\";\n            LayoutFlags[LayoutFlags[\"measure\"] = 2] = \"measure\";\n            LayoutFlags[LayoutFlags[\"arrange\"] = 4] = \"arrange\";\n            LayoutFlags[LayoutFlags[\"measureHint\"] = 8] = \"measureHint\";\n            LayoutFlags[LayoutFlags[\"arrangeHint\"] = 16] = \"arrangeHint\";\n            LayoutFlags[LayoutFlags[\"slotHint\"] = 32] = \"slotHint\";\n            LayoutFlags[LayoutFlags[\"hints\"] = 56] = \"hints\";\n        })(core.LayoutFlags || (core.LayoutFlags = {}));\n        var LayoutFlags = core.LayoutFlags;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"converters\" />\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        mirage.map.registerNormal(\"visible\", \"visible\");\n        mirage.map.registerNormal(\"use-layout-rounding\", \"useLayoutRounding\");\n        mirage.map.registerNormal(\"margin\", \"margin\");\n        mirage.map.registerNormal(\"width\", \"width\");\n        mirage.map.registerNormal(\"height\", \"height\");\n        mirage.map.registerNormal(\"min-width\", \"minWidth\");\n        mirage.map.registerNormal(\"min-height\", \"minHeight\");\n        mirage.map.registerNormal(\"max-width\", \"maxWidth\");\n        mirage.map.registerNormal(\"max-height\", \"maxHeight\");\n        mirage.map.registerNormal(\"horizontal-alignment\", \"horizontalAlignment\");\n        mirage.map.registerNormal(\"vertical-alignment\", \"verticalAlignment\");\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function NewMeasurer(inputs, state, tree, override) {\n            return function (availableSize) {\n                if (isNaN(availableSize.width) || isNaN(availableSize.height)) {\n                    console.warn(\"[mirage] cannot call measure using a size with NaN values.\");\n                    return false;\n                }\n                if (inputs.visible !== true) {\n                    return false;\n                }\n                if ((state.flags & core.LayoutFlags.measure) <= 0) {\n                    return false;\n                }\n                var last = state.lastAvailable;\n                if (!mirage.Size.isUndef(last) && last.width === availableSize.width && last.height === availableSize.height) {\n                    return false;\n                }\n                mirage.Size.copyTo(availableSize, last);\n                tree.applyTemplate();\n                state.flags |= (core.LayoutFlags.arrange | core.LayoutFlags.arrangeHint);\n                var framedSize = new mirage.Size(availableSize.width, availableSize.height);\n                mirage.Thickness.shrinkSize(inputs.margin, framedSize);\n                core.coerceSize(framedSize, inputs);\n                var desired = override(framedSize);\n                state.flags &= ~core.LayoutFlags.measure;\n                mirage.Size.copyTo(desired, state.hiddenDesire);\n                core.coerceSize(desired, inputs);\n                mirage.Thickness.growSize(inputs.margin, desired);\n                desired.width = Math.min(desired.width, availableSize.width);\n                desired.height = Math.min(desired.height, availableSize.height);\n                if (inputs.useLayoutRounding) {\n                    mirage.Size.round(desired);\n                }\n                mirage.Size.copyTo(desired, state.desiredSize);\n                return true;\n            };\n        }\n        core.NewMeasurer = NewMeasurer;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var core;\n    (function (core) {\n        function coerceSize(size, inputs) {\n            var cw = Math.max(inputs.minWidth, size.width);\n            var ch = Math.max(inputs.minHeight, size.height);\n            if (!isNaN(inputs.width))\n                cw = inputs.width;\n            if (!isNaN(inputs.height))\n                ch = inputs.height;\n            cw = Math.max(Math.min(cw, inputs.maxWidth), inputs.minWidth);\n            ch = Math.max(Math.min(ch, inputs.maxHeight), inputs.minHeight);\n            if (inputs.useLayoutRounding) {\n                cw = Math.round(cw);\n                ch = Math.round(ch);\n            }\n            size.width = cw;\n            size.height = ch;\n        }\n        core.coerceSize = coerceSize;\n    })(core = mirage.core || (mirage.core = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        function NewArrangeDrafter(node) {\n            var arrangeList = [];\n            return {\n                flush: function () {\n                    var cur;\n                    while ((cur = arrangeList.shift()) != null) {\n                        cur.tree.propagateFlagUp(LayoutFlags.arrangeHint);\n                    }\n                },\n                prepare: function () {\n                    for (var walker = node.walkDeep(); walker.step();) {\n                        var cur = walker.current;\n                        if (!cur.inputs.visible) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        if ((cur.state.flags & LayoutFlags.arrangeHint) === 0) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        cur.state.flags &= ~LayoutFlags.arrangeHint;\n                        if ((cur.state.flags & LayoutFlags.arrange) > 0) {\n                            arrangeList.push(cur);\n                        }\n                    }\n                    return arrangeList.length > 0;\n                },\n                draft: function (rootSize) {\n                    var cur;\n                    while ((cur = arrangeList.shift()) != null) {\n                        cur.doArrange(rootSize);\n                    }\n                    return true;\n                },\n            };\n        }\n        draft.NewArrangeDrafter = NewArrangeDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        var MAX_COUNT = 255;\n        function NewDrafter(node) {\n            var measure = draft.NewMeasureDrafter(node);\n            var arrange = draft.NewArrangeDrafter(node);\n            var slot = draft.NewSlotDrafter(node);\n            function runDraft(updater, rootSize) {\n                if (!node.inputs.visible)\n                    return false;\n                arrange.flush();\n                slot.flush();\n                var flags = node.state.flags;\n                if ((flags & LayoutFlags.measureHint) > 0) {\n                    return measure.prepare()\n                        && measure.draft();\n                }\n                if ((flags & LayoutFlags.arrangeHint) > 0) {\n                    return arrange.prepare()\n                        && arrange.draft(rootSize);\n                }\n                if ((flags & LayoutFlags.slotHint) > 0) {\n                    return slot.prepare()\n                        && slot.draft()\n                        && slot.notify(updater);\n                }\n                return false;\n            }\n            return function (updater, rootSize) {\n                if ((node.state.flags & LayoutFlags.hints) === 0)\n                    return false;\n                var updated = false;\n                var count = 0;\n                for (; count < MAX_COUNT; count++) {\n                    if (!runDraft(updater, rootSize))\n                        break;\n                    updated = true;\n                }\n                if (count >= MAX_COUNT) {\n                    console.error(\"[mirage] aborting infinite draft\");\n                }\n                return updated;\n            };\n        }\n        draft.NewDrafter = NewDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        function NewMeasureDrafter(node) {\n            var measureList = [];\n            return {\n                prepare: function () {\n                    for (var walker = node.walkDeep(); walker.step();) {\n                        var cur = walker.current;\n                        if (!cur.inputs.visible) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        if ((cur.state.flags & LayoutFlags.measureHint) === 0) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        cur.state.flags &= ~LayoutFlags.measureHint;\n                        if ((cur.state.flags & LayoutFlags.measure) > 0) {\n                            measureList.push(cur);\n                        }\n                    }\n                    return measureList.length > 0;\n                },\n                draft: function () {\n                    var cur;\n                    while ((cur = measureList.shift()) != null) {\n                        cur.doMeasure();\n                    }\n                    return true;\n                },\n            };\n        }\n        draft.NewMeasureDrafter = NewMeasureDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\n/// <reference path=\"../core/LayoutFlags\" />\nvar mirage;\n(function (mirage) {\n    var draft;\n    (function (draft) {\n        var LayoutFlags = mirage.core.LayoutFlags;\n        function NewSlotDrafter(node) {\n            var slotList = [];\n            var slotUpdates = [];\n            return {\n                flush: function () {\n                    var cur;\n                    while ((cur = slotList.shift()) != null) {\n                        cur.tree.propagateFlagUp(LayoutFlags.slotHint);\n                    }\n                },\n                prepare: function () {\n                    for (var walker = node.walkDeep(); walker.step();) {\n                        var cur = walker.current;\n                        if (!cur.inputs.visible) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        if ((cur.state.flags & LayoutFlags.slotHint) === 0) {\n                            walker.skipBranch();\n                            continue;\n                        }\n                        cur.state.flags &= ~LayoutFlags.slotHint;\n                        if (!mirage.Rect.isUndef(cur.state.lastArrangedSlot)) {\n                            slotList.push(cur);\n                        }\n                    }\n                    return slotList.length > 0;\n                },\n                draft: function () {\n                    var oldRect = new mirage.Rect();\n                    var newRect = new mirage.Rect();\n                    var cur;\n                    while ((cur = slotList.pop()) != null) {\n                        cur.slot(oldRect, newRect);\n                        if (!mirage.Rect.isEqual(oldRect, newRect)) {\n                            slotUpdates.push({\n                                node: cur,\n                                oldRect: oldRect,\n                                newRect: newRect,\n                            });\n                            oldRect = new mirage.Rect();\n                            newRect = new mirage.Rect();\n                        }\n                    }\n                    return slotUpdates.length > 0;\n                },\n                notify: function (updater) {\n                    updater.updateSlots(slotUpdates);\n                    return true;\n                }\n            };\n        }\n        draft.NewSlotDrafter = NewSlotDrafter;\n    })(draft = mirage.draft || (mirage.draft = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        function NewGridArrangeOverride(inputs, state, tree) {\n            var des = state.design.arrange;\n            return function (arrangeSize) {\n                des.init(arrangeSize, inputs.columnDefinitions, inputs.rowDefinitions);\n                var cr = new mirage.Rect();\n                for (var walker = tree.walk(); walker.step();) {\n                    var child = walker.current;\n                    des.calcChildRect(cr, child);\n                    child.arrange(cr);\n                }\n                return new mirage.Size(arrangeSize.width, arrangeSize.height);\n            };\n        }\n        grid.NewGridArrangeOverride = NewGridArrangeOverride;\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        function NewGridMeasureOverride(inputs, state, tree) {\n            var des = state.design.measure;\n            var overrideAutoAuto = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.autoAuto, des, tree);\n            var overrideStarAuto = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.starAuto, des, tree);\n            var overrideAutoStar = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.autoStar, des, tree);\n            var overrideStarAuto2 = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.starAutoAgain, des, tree);\n            var overrideNonStar = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.nonStar, des, tree);\n            var overrideRemainingStar = grid.design.NewMeasureOverridePass(grid.design.MeasureOverridePass.remainingStar, des, tree);\n            return function (constraint) {\n                des.init(constraint, inputs.columnDefinitions, inputs.rowDefinitions, tree);\n                overrideAutoAuto();\n                overrideStarAuto();\n                overrideAutoStar();\n                overrideStarAuto2();\n                overrideNonStar();\n                overrideRemainingStar();\n                des.finish();\n                return des.getDesired();\n            };\n        }\n        grid.NewGridMeasureOverride = NewGridMeasureOverride;\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridArrangeDesign(cm, rm) {\n                return {\n                    init: function (arrangeSize, coldefs, rowdefs) {\n                        originalToOffered(cm);\n                        originalToOffered(rm);\n                        var consumed = new mirage.Size(design.helpers.calcDesiredToOffered(cm), design.helpers.calcDesiredToOffered(rm));\n                        if (consumed.width !== arrangeSize.width) {\n                            design.helpers.expand(arrangeSize.width, cm);\n                        }\n                        if (consumed.height !== arrangeSize.height) {\n                            design.helpers.expand(arrangeSize.height, rm);\n                        }\n                        if (!!coldefs) {\n                            for (var i = 0; i < coldefs.length; i++) {\n                                coldefs[i].setActualWidth(cm[i][i].offered);\n                            }\n                        }\n                        if (!!rowdefs) {\n                            for (var i = 0; i < rowdefs.length; i++) {\n                                rowdefs[i].setActualHeight(rm[i][i].offered);\n                            }\n                        }\n                    },\n                    calcChildRect: function (childRect, child) {\n                        mirage.Rect.clear(childRect);\n                        var col = mirage.Grid.getColumn(child) || 0;\n                        col = Math.min(col, cm.length - 1);\n                        var colspan = mirage.Grid.getColumnSpan(child);\n                        if (colspan !== 0)\n                            colspan = colspan || 1;\n                        colspan = Math.min(colspan, cm.length - col);\n                        var row = mirage.Grid.getRow(child) || 0;\n                        row = Math.min(row, rm.length - 1);\n                        var rowspan = mirage.Grid.getRowSpan(child);\n                        if (rowspan !== 0)\n                            rowspan = rowspan || 1;\n                        rowspan = Math.min(rowspan, rm.length - row);\n                        for (var i = 0; i < col; i++) {\n                            childRect.x += cm[i][i].offered;\n                        }\n                        for (var i = col; i < col + colspan; i++) {\n                            childRect.width += cm[i][i].offered;\n                        }\n                        for (var i = 0; i < row; i++) {\n                            childRect.y += rm[i][i].offered;\n                        }\n                        for (var i = row; i < row + rowspan; i++) {\n                            childRect.height += rm[i][i].offered;\n                        }\n                    },\n                };\n            }\n            design.NewGridArrangeDesign = NewGridArrangeDesign;\n            function originalToOffered(matrix) {\n                for (var i = 0; i < matrix.length; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        matrix[i][j].offered = matrix[i][j].original;\n                    }\n                }\n            }\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridPlacement(cm, rm) {\n                var unicells = [];\n                var multicells = [];\n                return {\n                    init: function () {\n                        unicells.length = 0;\n                        multicells.length = 0;\n                    },\n                    add: function (isRow, start, span, size) {\n                        var item = {\n                            matrix: isRow ? rm : cm,\n                            start: start,\n                            end: start + span - 1,\n                            size: size,\n                        };\n                        if (item.start === item.end) {\n                            unicells.unshift(item);\n                        }\n                        else {\n                            multicells.push(item);\n                        }\n                    },\n                    allocate: function (allocFunc) {\n                        var cell;\n                        while ((cell = unicells.pop()) != null) {\n                            var i = cell.start;\n                            var j = cell.end;\n                            cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                            allocFunc();\n                        }\n                        while ((cell = multicells.pop()) != null) {\n                            var i = cell.start;\n                            var j = cell.end;\n                            cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                            allocFunc();\n                        }\n                    },\n                };\n            }\n            design.NewGridPlacement = NewGridPlacement;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridShape(childShapes) {\n                var hasAutoAuto = false;\n                var hasStarAuto = false;\n                var hasAutoStar = false;\n                for (var i = 0; i < childShapes.length; i++) {\n                    var cs = childShapes[i];\n                    hasAutoAuto = hasAutoAuto || (cs.autoRow && cs.autoCol && !cs.starRow && !cs.starCol);\n                    hasStarAuto = hasStarAuto || (cs.starRow && cs.autoCol);\n                    hasAutoStar = hasAutoStar || (cs.autoRow && cs.starCol);\n                }\n                return {\n                    hasAutoAuto: hasAutoAuto,\n                    hasStarAuto: hasStarAuto,\n                    hasAutoStar: hasAutoStar,\n                };\n            }\n            design.NewGridShape = NewGridShape;\n            var GridChildShape = (function () {\n                function GridChildShape() {\n                }\n                GridChildShape.prototype.init = function (child, cm, rm) {\n                    var col = this.col = Math.min(mirage.Grid.getColumn(child), cm.length - 1);\n                    if (isNaN(col))\n                        this.col = col = 0;\n                    var row = this.row = Math.min(mirage.Grid.getRow(child), rm.length - 1);\n                    if (isNaN(row))\n                        this.row = row = 0;\n                    var colspan = this.colspan = Math.min(mirage.Grid.getColumnSpan(child), cm.length - col);\n                    if (isNaN(colspan))\n                        this.colspan = colspan = 1;\n                    var rowspan = this.rowspan = Math.min(mirage.Grid.getRowSpan(child), rm.length - row);\n                    if (isNaN(rowspan))\n                        this.rowspan = rowspan = 1;\n                    this.starRow = this.autoRow = this.starCol = this.autoCol = false;\n                    for (var i = row; i < row + rowspan; i++) {\n                        this.starRow = this.starRow || (rm[i][i].type === mirage.GridUnitType.star);\n                        this.autoRow = this.autoRow || (rm[i][i].type === mirage.GridUnitType.auto);\n                    }\n                    for (var i = col; i < col + colspan; i++) {\n                        this.starCol = this.starCol || (cm[i][i].type === mirage.GridUnitType.star);\n                        this.autoCol = this.autoCol || (cm[i][i].type === mirage.GridUnitType.auto);\n                    }\n                };\n                GridChildShape.prototype.shouldMeasurePass = function (gridShape, childSize, pass) {\n                    childSize.width = childSize.height = 0;\n                    if (this.autoRow && this.autoCol && !this.starRow && !this.starCol) {\n                        if (pass !== design.MeasureOverridePass.autoAuto)\n                            return false;\n                        childSize.width = Number.POSITIVE_INFINITY;\n                        childSize.height = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if (this.starRow && this.autoCol && !this.starCol) {\n                        if (pass !== design.MeasureOverridePass.starAuto && pass !== design.MeasureOverridePass.starAutoAgain)\n                            return false;\n                        if (pass === design.MeasureOverridePass.autoAuto && gridShape.hasAutoStar)\n                            childSize.height = Number.POSITIVE_INFINITY;\n                        childSize.width = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if (this.autoRow && this.starCol && !this.starRow) {\n                        if (pass !== design.MeasureOverridePass.autoStar)\n                            return false;\n                        childSize.height = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if ((this.autoRow || this.autoCol) && !(this.starRow || this.starCol)) {\n                        if (pass !== design.MeasureOverridePass.nonStar)\n                            return false;\n                        if (this.autoRow)\n                            childSize.height = Number.POSITIVE_INFINITY;\n                        if (this.autoCol)\n                            childSize.width = Number.POSITIVE_INFINITY;\n                        return true;\n                    }\n                    if (!(this.starRow || this.starCol))\n                        return pass === design.MeasureOverridePass.nonStar;\n                    return pass === design.MeasureOverridePass.remainingStar;\n                };\n                GridChildShape.prototype.calcConstraint = function (childSize, cm, rm) {\n                    for (var i = this.row; i < this.row + this.rowspan; i++) {\n                        childSize.height += rm[i][i].offered;\n                    }\n                    for (var i = this.col; i < this.col + this.colspan; i++) {\n                        childSize.width += cm[i][i].offered;\n                    }\n                };\n                return GridChildShape;\n            })();\n            design.GridChildShape = GridChildShape;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            var helpers;\n            (function (helpers) {\n                function expand(available, mat) {\n                    for (var i = 0; i < mat.length; i++) {\n                        var cur = mat[i][i];\n                        if (cur.type === mirage.GridUnitType.star)\n                            cur.offered = 0;\n                        else\n                            available = Math.max(available - cur.offered, 0);\n                    }\n                    assignSize(mat, 0, mat.length - 1, available, mirage.GridUnitType.star, false);\n                }\n                helpers.expand = expand;\n                function assignSize(mat, start, end, size, unitType, desiredSize) {\n                    var count = 0;\n                    var assigned = false;\n                    var segmentSize = 0;\n                    for (var i = start; i <= end; i++) {\n                        var cur = mat[i][i];\n                        segmentSize = desiredSize ? cur.desired : cur.offered;\n                        if (segmentSize < cur.max)\n                            count += (unitType === mirage.GridUnitType.star) ? cur.stars : 1;\n                    }\n                    do {\n                        assigned = false;\n                        var contribution = size / count;\n                        for (var i = start; i <= end; i++) {\n                            var cur = mat[i][i];\n                            segmentSize = desiredSize ? cur.desired : cur.offered;\n                            if (!(cur.type === unitType && segmentSize < cur.max))\n                                continue;\n                            var newSize = segmentSize;\n                            newSize += contribution * (unitType === mirage.GridUnitType.star ? cur.stars : 1);\n                            newSize = Math.min(newSize, cur.max);\n                            assigned = assigned || (newSize > segmentSize);\n                            size -= newSize - segmentSize;\n                            if (desiredSize)\n                                cur.desired = newSize;\n                            else\n                                cur.offered = newSize;\n                        }\n                    } while (assigned);\n                    return size;\n                }\n                helpers.assignSize = assignSize;\n                function calcDesiredToOffered(matrix) {\n                    var total = 0;\n                    for (var i = 0; i < matrix.length; i++) {\n                        total += (matrix[i][i].offered = matrix[i][i].desired);\n                    }\n                    return total;\n                }\n                helpers.calcDesiredToOffered = calcDesiredToOffered;\n            })(helpers = design.helpers || (design.helpers = {}));\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridDesign() {\n                var cm = [];\n                var rm = [];\n                return {\n                    measure: design.NewGridMeasureDesign(cm, rm),\n                    arrange: design.NewGridArrangeDesign(cm, rm),\n                };\n            }\n            design.NewGridDesign = NewGridDesign;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            function NewGridMeasureDesign(cm, rm) {\n                var shape;\n                var childShapes = [];\n                var placement = design.NewGridPlacement(cm, rm);\n                return {\n                    init: function (constraint, coldefs, rowdefs, tree) {\n                        ensureMatrix(cm, !coldefs ? 1 : coldefs.length || 1);\n                        ensureMatrix(rm, !rowdefs ? 1 : rowdefs.length || 1);\n                        prepareCols(cm, coldefs);\n                        prepareRows(rm, rowdefs);\n                        var i = 0;\n                        for (var walker = tree.walk(); walker.step(); i++) {\n                            var childShape;\n                            if (i < childShapes.length) {\n                                childShapes[i] = childShapes[i] || new design.GridChildShape();\n                            }\n                            else {\n                                childShapes.push(childShape = new design.GridChildShape());\n                            }\n                            childShape.init(walker.current, cm, rm);\n                        }\n                        if (i < childShapes.length)\n                            childShapes.slice(i, childShapes.length - i);\n                        shape = design.NewGridShape(childShapes);\n                        placement.init();\n                        if (tree.children.length > 0) {\n                            design.helpers.expand(constraint.width, cm);\n                            design.helpers.expand(constraint.height, rm);\n                        }\n                    },\n                    measureChild: function (pass, index, child) {\n                        var childShape = childShapes[index];\n                        var childSize = new mirage.Size();\n                        if (!childShape || !childShape.shouldMeasurePass(shape, childSize, pass))\n                            return;\n                        childShape.calcConstraint(childSize, cm, rm);\n                        child.measure(childSize);\n                        var desired = child.state.desiredSize;\n                        if (pass !== design.MeasureOverridePass.starAuto)\n                            placement.add(true, childShape.row, childShape.rowspan, desired.height);\n                        placement.add(false, childShape.col, childShape.colspan, desired.width);\n                    },\n                    finishPass: function () {\n                        placement.allocate(allocateDesiredSizeFunc(cm, rm));\n                    },\n                    finish: function () {\n                        for (var i = 0; i < cm.length; i++) {\n                            for (var j = 0; j <= i; j++) {\n                                cm[i][j].original = cm[i][j].offered;\n                            }\n                        }\n                        for (var i = 0; i < rm.length; i++) {\n                            for (var j = 0; j <= i; j++) {\n                                rm[i][j].original = rm[i][j].offered;\n                            }\n                        }\n                    },\n                    getDesired: function () {\n                        var desired = new mirage.Size();\n                        for (var i = 0; i < cm.length; i++) {\n                            desired.width += cm[i][i].desired;\n                        }\n                        for (var i = 0; i < rm.length; i++) {\n                            desired.height += rm[i][i].desired;\n                        }\n                        return desired;\n                    },\n                };\n            }\n            design.NewGridMeasureDesign = NewGridMeasureDesign;\n            var DEFAULT_GRID_LEN = {\n                value: 1.0,\n                type: mirage.GridUnitType.star\n            };\n            function ensureMatrix(matrix, defCount) {\n                if (matrix.length > defCount)\n                    matrix.splice(defCount, matrix.length - defCount);\n                for (var i = 0; i < defCount; i++) {\n                    if (matrix.length <= i)\n                        matrix.push([]);\n                    var mrow = matrix[i];\n                    if (mrow.length > (i + 1))\n                        mrow.splice(i, mrow.length - i - 1);\n                    for (var ii = 0; ii <= i; ii++) {\n                        if (mrow.length <= ii)\n                            mrow.push(new design.Segment());\n                        else\n                            design.Segment.init(mrow[ii]);\n                    }\n                }\n            }\n            function prepareCols(cm, coldefs) {\n                if (!coldefs || coldefs.length === 0) {\n                    var mcell = cm[0][0];\n                    mcell.type = mirage.GridUnitType.star;\n                    mcell.stars = 1.0;\n                    return;\n                }\n                for (var i = 0; i < coldefs.length; i++) {\n                    var colDef = coldefs[i];\n                    var width = colDef.width || DEFAULT_GRID_LEN;\n                    colDef.setActualWidth(Number.POSITIVE_INFINITY);\n                    var cell = design.Segment.init(cm[i][i], 0.0, colDef.minWidth, colDef.maxWidth, width.type);\n                    if (width.type === mirage.GridUnitType.pixel) {\n                        cell.desired = cell.offered = cell.clamp(width.value);\n                        colDef.setActualWidth(cell.desired);\n                    }\n                    else if (width.type === mirage.GridUnitType.star) {\n                        cell.stars = width.value;\n                    }\n                    else if (width.type === mirage.GridUnitType.auto) {\n                        cell.desired = cell.offered = cell.clamp(0);\n                    }\n                }\n            }\n            function prepareRows(rm, rowdefs) {\n                if (!rowdefs || rowdefs.length === 0) {\n                    var mcell = rm[0][0];\n                    mcell.type = mirage.GridUnitType.star;\n                    mcell.stars = 1.0;\n                    return;\n                }\n                for (var i = 0; i < rowdefs.length; i++) {\n                    var rowDef = rowdefs[i];\n                    var height = rowDef.height || DEFAULT_GRID_LEN;\n                    rowDef.setActualHeight(Number.POSITIVE_INFINITY);\n                    var cell = design.Segment.init(rm[i][i], 0.0, rowDef.minHeight, rowDef.maxHeight, height.type);\n                    if (height.type === mirage.GridUnitType.pixel) {\n                        cell.desired = cell.offered = cell.clamp(height.value);\n                        rowDef.setActualHeight(cell.desired);\n                    }\n                    else if (height.type === mirage.GridUnitType.star) {\n                        cell.stars = height.value;\n                    }\n                    else if (height.type === mirage.GridUnitType.auto) {\n                        cell.desired = cell.offered = cell.clamp(0);\n                    }\n                }\n            }\n            function allocateDesiredSizeFunc(cm, rm) {\n                function hasStarInSpan(mat, start, end) {\n                    var spansStar = false;\n                    for (var i = start; i >= end; i--) {\n                        spansStar = spansStar || mat[i][i].type === mirage.GridUnitType.star;\n                    }\n                    return spansStar;\n                }\n                function calcDesired(mat, start, end) {\n                    var total = 0;\n                    for (var i = start; i >= end; i--) {\n                        total += mat[i][i].desired;\n                    }\n                    return total;\n                }\n                function allocSegments(mat) {\n                    var count = mat.length;\n                    for (var start = count - 1; start >= 0; start--) {\n                        for (var end = start; end >= 0; end--) {\n                            var hasStar = hasStarInSpan(mat, start, end);\n                            var cur = mat[start][end].desired;\n                            var total = calcDesired(mat, start, end);\n                            var additional = cur - total;\n                            if (additional > 0) {\n                                if (hasStar) {\n                                    design.helpers.assignSize(mat, end, start, additional, mirage.GridUnitType.star, true);\n                                }\n                                else {\n                                    design.helpers.assignSize(mat, end, start, additional, mirage.GridUnitType.pixel, true);\n                                    design.helpers.assignSize(mat, end, start, additional, mirage.GridUnitType.auto, true);\n                                }\n                            }\n                        }\n                    }\n                }\n                return function () {\n                    allocSegments(rm);\n                    allocSegments(cm);\n                    design.helpers.calcDesiredToOffered(rm);\n                    design.helpers.calcDesiredToOffered(cm);\n                };\n            }\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            (function (MeasureOverridePass) {\n                MeasureOverridePass[MeasureOverridePass[\"autoAuto\"] = 0] = \"autoAuto\";\n                MeasureOverridePass[MeasureOverridePass[\"starAuto\"] = 1] = \"starAuto\";\n                MeasureOverridePass[MeasureOverridePass[\"autoStar\"] = 2] = \"autoStar\";\n                MeasureOverridePass[MeasureOverridePass[\"starAutoAgain\"] = 3] = \"starAutoAgain\";\n                MeasureOverridePass[MeasureOverridePass[\"nonStar\"] = 4] = \"nonStar\";\n                MeasureOverridePass[MeasureOverridePass[\"remainingStar\"] = 5] = \"remainingStar\";\n            })(design.MeasureOverridePass || (design.MeasureOverridePass = {}));\n            var MeasureOverridePass = design.MeasureOverridePass;\n            function NewMeasureOverridePass(pass, des, tree) {\n                return function () {\n                    for (var walker = tree.walk(), i = 0; walker.step(); i++) {\n                        des.measureChild(pass, i, walker.current);\n                    }\n                    des.finishPass();\n                };\n            }\n            design.NewMeasureOverridePass = NewMeasureOverridePass;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var grid;\n    (function (grid) {\n        var design;\n        (function (design) {\n            var Segment = (function () {\n                function Segment() {\n                    this.desired = 0.0;\n                    this.offered = 0.0;\n                    this.original = 0.0;\n                    this.min = 0.0;\n                    this.max = Number.POSITIVE_INFINITY;\n                    this.stars = 0;\n                    this.type = mirage.GridUnitType.pixel;\n                }\n                Segment.prototype.clamp = function (value) {\n                    if (value < this.min)\n                        return this.min;\n                    if (value > this.max)\n                        return this.max;\n                    return value;\n                };\n                Segment.init = function (segment, offered, min, max, unitType) {\n                    segment.desired = 0.0;\n                    segment.stars = 0;\n                    segment.offered = offered || 0.0;\n                    segment.min = min || 0.0;\n                    segment.max = max != null ? max : Number.POSITIVE_INFINITY;\n                    segment.type = unitType != null ? unitType : mirage.GridUnitType.pixel;\n                    if (segment.offered < min)\n                        segment.offered = min;\n                    else if (segment.offered > max)\n                        segment.offered = max;\n                    return segment;\n                };\n                return Segment;\n            })();\n            design.Segment = Segment;\n        })(design = grid.design || (grid.design = {}));\n    })(grid = mirage.grid || (mirage.grid = {}));\n})(mirage || (mirage = {}));\n","namespace mirage {\n    interface ITypeCreatorHash {\n        [type: string]: ITypeNodeCreator;\n    }\n    var typeCreators: ITypeCreatorHash = {};\n\n    export function createNodeByType(type: string): core.LayoutNode {\n        var creator = typeCreators[type];\n        if (!creator)\n            return new core.LayoutNode();\n        return new creator();\n    }\n\n    export interface ITypeNodeCreator {\n        new (): core.LayoutNode;\n    }\n    export function registerNodeType(type: string, creator: ITypeNodeCreator) {\n        if (typeCreators[type]) {\n            console.warn(\"[mirage] Overriding type registration for \" + type);\n        }\n        typeCreators[type] = creator;\n    }\n}","/// <reference path=\"core/LayoutNode\" />\n/// <reference path=\"typeLookup\" />\n\nnamespace mirage {\n    export class Panel extends core.LayoutNode {\n        tree: IPanelTree;\n\n        protected createTree(): core.ILayoutTree {\n            return NewPanelTree();\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            return new Size(constraint.width, constraint.height);\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            return new Size(arrangeSize.width, arrangeSize.height);\n        }\n\n        get childCount(): number {\n            return this.tree.children.length;\n        }\n\n        insertChild(child: core.LayoutNode, index: number) {\n            var children = this.tree.children;\n            if (index >= children.length) {\n                this.appendChild(child);\n            } else if (index <= 0) {\n                this.prependChild(child);\n            } else {\n                children.splice(index, 0, child);\n                child.setParent(this);\n            }\n        }\n\n        prependChild(child: core.LayoutNode) {\n            this.tree.children.unshift(child);\n            child.setParent(this);\n        }\n\n        appendChild(child: core.LayoutNode) {\n            this.tree.children.push(child);\n            child.setParent(this);\n        }\n\n        removeChild(child: core.LayoutNode): boolean {\n            var children = this.tree.children;\n            var index = children.indexOf(child);\n            if (index < 0)\n                return false;\n            this.tree.children.splice(index, 1);\n            child.setParent(null);\n            return true;\n        }\n\n        removeChildAt(index: number): core.LayoutNode {\n            var children = this.tree.children;\n            if (index < 0 || index >= children.length)\n                return null;\n            var removed = children.splice(index, 1)[0];\n            if (removed)\n                removed.setParent(null);\n            return removed;\n        }\n\n        getChildAt(index: number): core.LayoutNode {\n            return this.tree.children[index];\n        }\n    }\n    registerNodeType(\"panel\", Panel);\n\n    export interface IPanelTree extends core.ILayoutTree {\n        children: core.LayoutNode[];\n    }\n\n    export function NewPanelTree(): IPanelTree {\n        var tree = <IPanelTree>core.DefaultLayoutTree();\n        tree.children = [];\n        tree.walk = (reverse?: boolean): core.ILayoutTreeWalker => {\n            if (!reverse) {\n                var i = -1;\n                return {\n                    current: undefined,\n                    step(): boolean {\n                        i++;\n                        if (i >= tree.children.length) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                };\n            } else {\n                var i = tree.children.length;\n                return {\n                    current: undefined,\n                    step(): boolean {\n                        i--;\n                        if (i < 0) {\n                            this.current = undefined;\n                            return false;\n                        }\n                        this.current = tree.children[i];\n                        return true;\n                    },\n                }\n            }\n        };\n        return tree;\n    }\n}","namespace mirage {\r\n    export class Thickness {\r\n        left: number;\r\n        top: number;\r\n        right: number;\r\n        bottom: number;\r\n\r\n        constructor(left?: number, top?: number, right?: number, bottom?: number) {\r\n            this.left = left == null ? 0 : left;\r\n            this.top = top == null ? 0 : top;\r\n            this.right = right == null ? 0 : right;\r\n            this.bottom = bottom == null ? 0 : bottom;\r\n        }\r\n\r\n        static isEqual(t1: Thickness, t2: Thickness): boolean {\r\n            return t1.left === t2.left\r\n                && t1.top === t2.top\r\n                && t1.right === t2.right\r\n                && t1.bottom === t2.bottom;\r\n        }\r\n\r\n        static growSize(thickness: Thickness, dest: Size) {\r\n            var w = dest.width;\r\n            var h = dest.height;\r\n            if (w != Number.POSITIVE_INFINITY)\r\n                w += thickness.left + thickness.right;\r\n            if (h != Number.POSITIVE_INFINITY)\r\n                h += thickness.top + thickness.bottom;\r\n            dest.width = w > 0 ? w : 0;\r\n            dest.height = h > 0 ? h : 0;\r\n            return dest;\r\n        }\r\n\r\n        static shrinkSize(thickness: Thickness, dest: Size) {\r\n            var w = dest.width;\r\n            var h = dest.height;\r\n            if (w != Number.POSITIVE_INFINITY)\r\n                w -= thickness.left + thickness.right;\r\n            if (h != Number.POSITIVE_INFINITY)\r\n                h -= thickness.top + thickness.bottom;\r\n            dest.width = w > 0 ? w : 0;\r\n            dest.height = h > 0 ? h : 0;\r\n            return dest;\r\n        }\r\n\r\n        static shrinkRect(thickness: Thickness, dest: IRect) {\r\n            dest.x += thickness.left;\r\n            dest.y += thickness.top;\r\n            dest.width -= thickness.left + thickness.right;\r\n            dest.height -= thickness.top + thickness.bottom;\r\n            if (dest.width < 0)\r\n                dest.width = 0;\r\n            if (dest.height < 0)\r\n                dest.height = 0;\r\n        }\r\n    }\r\n}","/// <reference path=\"../Thickness\" />\n\nnamespace mirage.convert {\n    /*\n     Converters map values from a string to the data type registered to a property name\n     */\n\n    export interface IConverter {\n        (value: string): any;\n    }\n    let converters: {[property: string]: IConverter;} = {};\n\n    export function register(property: string, converter: IConverter) {\n        converters[property] = converter;\n    }\n\n    export function getConverter(property: string): IConverter {\n        return converters[property];\n    }\n}","/// <reference path=\"../convert/converters\" />\n\nnamespace mirage.map {\n    /*\n     Setters provide a consistent interface to set properties (normal and attached) on a LayoutNode\n     Mappers will map a string onto a node using a property's registered converter and setter\n     */\n    export interface IPropertySetter {\n        (node: core.LayoutNode, value: any): void;\n    }\n    export interface IPropertyMapper {\n        (node: core.LayoutNode, value: string): void;\n    }\n    let setters: {[property: string]: IPropertySetter;} = {};\n    let mappers: {[property: string]: IPropertyMapper;} = {};\n\n\n    export function getSetter(property: string): IPropertySetter {\n        return setters[property];\n    }\n\n    export function getMapper(property: string): IPropertyMapper {\n        return mappers[property];\n    }\n\n    export function registerNormal(property: string, key: string): void {\n        setters[property] = (node, value) => node[key] = value;\n        let converter = convert.getConverter(property);\n        mappers[property] = (node, value) => node[key] = converter(value);\n    }\n\n    export function registerCustom(property: string, setter: IPropertySetter): void {\n        setters[property] = setter;\n        let converter = convert.getConverter(property);\n        mappers[property] = (node, value) => setter(node, converter(value));\n    }\n}","/// <reference path=\"Panel\" />\n/// <reference path=\"typeLookup\" />\n/// <reference path=\"convert/converters\" />\n/// <reference path=\"map/mappers\" />\n\nnamespace mirage {\n    export class Canvas extends Panel {\n        static getLeft(node: core.LayoutNode): number {\n            return node.getAttached(\"canvas.left\");\n        }\n\n        static setLeft(node: core.LayoutNode, value: number) {\n            node.setAttached(\"canvas.left\", value);\n            node.invalidateArrange();\n        }\n\n        static getTop(node: core.LayoutNode): number {\n            return node.getAttached(\"canvas.top\");\n        }\n\n        static setTop(node: core.LayoutNode, value: number) {\n            node.setAttached(\"canvas.top\", value);\n            node.invalidateArrange();\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            var available = new Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            for (var walker = this.tree.walk(); walker.step();) {\n                walker.current.measure(available);\n            }\n            return new Size();\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            var cr = new Rect();\n            for (var walker = this.tree.walk(); walker.step();) {\n                let child = walker.current;\n                //NOTE: Coercing undefined, null, NaN, and 0 to 0\n                cr.x = Canvas.getLeft(child) || 0;\n                cr.y = Canvas.getTop(child) || 0;\n                Size.copyTo(child.state.desiredSize, cr);\n                child.arrange(cr);\n            }\n            return arrangeSize;\n        }\n    }\n    registerNodeType(\"canvas\", Canvas);\n    convert.register(\"canvas.left\", convertCanvasCoord);\n    convert.register(\"canvas.top\", convertCanvasCoord);\n    map.registerCustom(\"canvas.left\", Canvas.setLeft);\n    map.registerCustom(\"canvas.top\", Canvas.setTop);\n    function convertCanvasCoord(value: string): number {\n        if (!value)\n            return 0;\n        return parseFloat(value);\n    }\n}","namespace mirage {\n    export enum HorizontalAlignment {\n        stretch = 0,\n        left = 1,\n        center = 2,\n        right = 3,\n    }\n    export enum VerticalAlignment {\n        stretch = 0,\n        top = 1,\n        center = 2,\n        bottom = 3,\n    }\n    export enum Orientation {\n        horizontal = 0,\n        vertical = 1,\n    }\n}","namespace mirage {\n    export interface IRowDefinition {\n        height: IGridLength;\n        minHeight: number;\n        maxHeight: number;\n        getActualHeight(): number;\n\n        /// WARNING: This should only be used by engine\n        setActualHeight(value: number);\n    }\n\n    export function NewRowDefinitions(defs: string): IRowDefinition[] {\n        var rowdefs: IRowDefinition[] = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            let token = tokens[i];\n            if (token === \" \")\n                continue;\n            rowdefs.push(NewRowDefinition(token));\n        }\n        return rowdefs;\n    }\n\n    export function NewRowDefinition(): IRowDefinition;\n    export function NewRowDefinition(height: string): IRowDefinition;\n    export function NewRowDefinition(heightValue: number, heightType: GridUnitType): IRowDefinition;\n    export function NewRowDefinition(height: string, minHeight: number, maxHeight: number): IRowDefinition;\n    export function NewRowDefinition(heightValue: number, heightType: GridUnitType, minHeight: number, maxHeight: number): IRowDefinition;\n    export function NewRowDefinition(): IRowDefinition {\n        var len: IGridLength;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n\n        switch (arguments.length) {\n            case 1:\n                len = parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: GridUnitType.star,\n                };\n                break;\n        }\n\n        var actual = NaN;\n        return {\n            height: len,\n            minHeight: min,\n            maxHeight: max,\n            getActualHeight(): number {\n                return actual;\n            },\n            setActualHeight(value: number) {\n                actual = value;\n            },\n        };\n    }\n}","namespace mirage {\n    export interface IColumnDefinition {\n        width: IGridLength;\n        minWidth: number;\n        maxWidth: number;\n        getActualWidth(): number;\n\n        /// WARNING: This should only be used by engine\n        setActualWidth(value: number);\n    }\n\n    export function NewColumnDefinitions(defs: string): IColumnDefinition[] {\n        var coldefs: IColumnDefinition[] = [];\n        for (var i = 0, tokens = defs.split(\" \"); i < tokens.length; i++) {\n            let token = tokens[i];\n            if (token === \" \")\n                continue;\n            coldefs.push(NewColumnDefinition(token));\n        }\n        return coldefs;\n    }\n\n    export function NewColumnDefinition(): IColumnDefinition;\n    export function NewColumnDefinition(width: string): IColumnDefinition;\n    export function NewColumnDefinition(widthValue: number, widthType: GridUnitType): IColumnDefinition;\n    export function NewColumnDefinition(width: string, minWidth: number, maxWidth: number): IColumnDefinition;\n    export function NewColumnDefinition(widthValue: number, widthType: GridUnitType, minWidth: number, maxWidth: number): IColumnDefinition;\n    export function NewColumnDefinition(): IColumnDefinition {\n        var len: IGridLength;\n        var min = 0;\n        var max = Number.POSITIVE_INFINITY;\n\n        switch (arguments.length) {\n            case 1:\n                len = parseGridLength(arguments[0]);\n                break;\n            case 2:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                break;\n            case 3:\n                len = parseGridLength(arguments[0]);\n                min = arguments[1];\n                max = arguments[2];\n                break;\n            case 4:\n                len = {\n                    value: arguments[0],\n                    type: arguments[1],\n                };\n                min = arguments[2];\n                max = arguments[3];\n                break;\n            default:\n                len = {\n                    value: 1,\n                    type: GridUnitType.star,\n                };\n                break;\n        }\n\n        var actual = NaN;\n        return {\n            width: len,\n            minWidth: min,\n            maxWidth: max,\n            getActualWidth(): number {\n                return actual;\n            },\n            setActualWidth(value: number) {\n                actual = value;\n            },\n        };\n    }\n}","/// <reference path=\"Panel\" />\n/// <reference path=\"typeLookup\" />\n/// <reference path=\"convert/converters\" />\n/// <reference path=\"map/mappers\" />\n/// <reference path=\"IRowDefinition\" />\n/// <reference path=\"IColumnDefinition\" />\n\nnamespace mirage {\n    export interface IGridInputs extends core.ILayoutNodeInputs {\n        rowDefinitions: IRowDefinition[];\n        columnDefinitions: IColumnDefinition[];\n    }\n\n    export interface IGridState extends core.ILayoutNodeState {\n        design: grid.design.IGridDesign;\n    }\n\n    export class Grid extends Panel {\n        static getColumn(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.column\");\n        }\n\n        static setColumn(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.column\", value);\n            invalidateCell(node);\n        }\n\n        static getColumnSpan(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.column-span\");\n        }\n\n        static setColumnSpan(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.column-span\", value);\n            invalidateCell(node);\n        }\n\n        static getRow(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.row\");\n        }\n\n        static setRow(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.row\", value);\n            invalidateCell(node);\n        }\n\n        static getRowSpan(node: core.LayoutNode): number {\n            return node.getAttached(\"grid.row-span\");\n        }\n\n        static setRowSpan(node: core.LayoutNode, value: number) {\n            node.setAttached(\"grid.row-span\", value);\n            invalidateCell(node);\n        }\n\n        inputs: IGridInputs;\n        state: IGridState;\n\n        private $measureOverride: core.IMeasureOverride;\n        private $arrangeOverride: core.IArrangeOverride;\n\n        init() {\n            super.init();\n            this.$measureOverride = grid.NewGridMeasureOverride(this.inputs, this.state, this.tree);\n            this.$arrangeOverride = grid.NewGridArrangeOverride(this.inputs, this.state, this.tree);\n        }\n\n        get rowDefinitions(): IRowDefinition[] {\n            return this.inputs.rowDefinitions;\n        }\n\n        set rowDefinitions(value: IRowDefinition[]) {\n            if (!value)\n                value = [];\n            this.inputs.rowDefinitions = value;\n            this.invalidateMeasure();\n        }\n\n        get columnDefinitions(): IColumnDefinition[] {\n            return this.inputs.columnDefinitions;\n        }\n\n        set columnDefinitions(value: IColumnDefinition[]) {\n            if (!value)\n                value = [];\n            this.inputs.columnDefinitions = value;\n            this.invalidateMeasure();\n        }\n\n        protected createInputs(): IGridInputs {\n            var inputs = <IGridInputs>super.createInputs();\n            inputs.rowDefinitions = [];\n            inputs.columnDefinitions = [];\n            return inputs;\n        }\n\n        protected createState(): IGridState {\n            var state = <IGridState>super.createState();\n            state.design = grid.design.NewGridDesign();\n            return state;\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            return this.$measureOverride(constraint);\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            return this.$arrangeOverride(arrangeSize);\n        }\n    }\n    registerNodeType(\"grid\", Grid);\n    convert.register(\"row-definitions\", NewRowDefinitions);\n    convert.register(\"column-definitions\", NewColumnDefinitions);\n    convert.register(\"grid.row\", convertGridCell);\n    convert.register(\"grid.row-span\", convertGridCell);\n    convert.register(\"grid.column\", convertGridCell);\n    convert.register(\"grid.column-span\", convertGridCell);\n    map.registerNormal(\"row-definitions\", \"rowDefinitions\");\n    map.registerNormal(\"column-definitions\", \"columnDefinitions\");\n    map.registerCustom(\"grid.row\", Grid.setRow);\n    map.registerCustom(\"grid.row-span\", Grid.setRowSpan);\n    map.registerCustom(\"grid.column\", Grid.setColumn);\n    map.registerCustom(\"grid.column-span\", Grid.setColumnSpan);\n\n    function invalidateCell(node: core.LayoutNode) {\n        var parent = node.tree.parent;\n        if (parent instanceof Grid)\n            parent.invalidateMeasure();\n        node.invalidateMeasure();\n    }\n\n    function convertGridCell(value: string): number {\n        if (!value)\n            return 0;\n        return parseInt(value);\n    }\n}","namespace mirage {\n    export enum GridUnitType {\n        auto = 0,\n        pixel = 1,\n        star = 2,\n    }\n\n    export interface IGridLength {\n        value: number;\n        type: GridUnitType;\n    }\n\n    export function parseGridLength(s: string): IGridLength {\n        var auto = {value: 0, type: GridUnitType.auto};\n        if (s === \"auto\") {\n            return auto;\n        }\n        if (s[s.length - 1] === \"*\") {\n            if (s.length === 1)\n                return {value: 1, type: GridUnitType.star};\n            return {\n                value: parseInt(s.substr(0, s.length - 1)),\n                type: GridUnitType.star,\n            };\n        }\n        return {\n            value: parseInt(s),\n            type: GridUnitType.pixel,\n        };\n    }\n}","namespace mirage.adapters {\n    export interface IRenderAdapter {\n        updateSlots(updates: draft.ISlotUpdate[]);\n    }\n\n    var registered: IRenderAdapter[] = [];\n\n    export function register(adapter: IRenderAdapter) {\n        if (registered.indexOf(adapter) < 0) {\n            registered.push(adapter);\n        }\n    }\n\n    export function unregister(adapter: IRenderAdapter) {\n        var index = registered.indexOf(adapter);\n        if (index > -1)\n            registered.splice(index, 1);\n    }\n\n    export function updateSlots(updates: draft.ISlotUpdate[]) {\n        for (var i = 0; i < registered.length; i++) {\n            registered[i].updateSlots(updates);\n        }\n    }\n}","namespace mirage {\r\n    export interface IPoint {\r\n        x: number;\r\n        y: number;\r\n    }\r\n\r\n    export class Point implements IPoint {\r\n        x: number;\r\n        y: number;\r\n\r\n        constructor(x?: number, y?: number) {\r\n            this.x = x == null ? 0 : x;\r\n            this.y = y == null ? 0 : y;\r\n        }\r\n\r\n        static isEqual(p1: IPoint, p2: IPoint): boolean {\r\n            return p1.x === p2.x\r\n                && p1.y === p2.y;\r\n        }\r\n\r\n        static copyTo(src: IPoint, dest: IPoint) {\r\n            dest.x = src.x;\r\n            dest.y = src.y;\r\n        }\r\n\r\n        static round(dest: IPoint) {\r\n            dest.x = Math.round(dest.x);\r\n            dest.y = Math.round(dest.y);\r\n        }\r\n    }\r\n}","namespace mirage {\r\n    export interface IRect extends IPoint, ISize {\r\n    }\r\n\r\n    export class Rect implements IRect {\r\n        x: number;\r\n        y: number;\r\n        width: number;\r\n        height: number;\r\n\r\n        constructor(x?: number, y?: number, width?: number, height?: number) {\r\n            this.x = x == null ? 0 : x;\r\n            this.y = y == null ? 0 : y;\r\n            this.width = width == null ? 0 : width;\r\n            this.height = height == null ? 0 : height;\r\n        }\r\n\r\n        static clear(rect: IRect) {\r\n            rect.x = rect.y = rect.width = rect.height = 0;\r\n        }\r\n\r\n        static isEqual(rect1: IRect, rect2: IRect): boolean {\r\n            return rect1.x === rect2.x\r\n                && rect1.y === rect2.y\r\n                && rect1.width === rect2.width\r\n                && rect1.height === rect2.height;\r\n        }\r\n\r\n        static isEmpty(src: IRect): boolean {\r\n            return src.width === 0\r\n                || src.height === 0;\r\n        }\r\n\r\n        static copyTo(src: IRect, dest: IRect) {\r\n            dest.x = src.x;\r\n            dest.y = src.y;\r\n            dest.width = src.width;\r\n            dest.height = src.height;\r\n        }\r\n\r\n        static isUndef(rect: IRect): boolean {\r\n            return isNaN(rect.x)\r\n                && isNaN(rect.y)\r\n                && isNaN(rect.width)\r\n                && isNaN(rect.height);\r\n        }\r\n\r\n        static undef(rect: IRect) {\r\n            rect.x = NaN;\r\n            rect.y = NaN;\r\n            rect.width = NaN;\r\n            rect.height = NaN;\r\n        }\r\n    }\r\n}","namespace mirage {\r\n    export interface ISize {\r\n        width: number;\r\n        height: number;\r\n    }\r\n\r\n    export class Size implements ISize {\r\n        width: number;\r\n        height: number;\r\n\r\n        constructor(width?: number, height?: number) {\r\n            this.width = width == null ? 0 : width;\r\n            this.height = height == null ? 0 : height;\r\n        }\r\n\r\n        static copyTo(src: ISize, dest: ISize) {\r\n            dest.width = src.width;\r\n            dest.height = src.height;\r\n        }\r\n\r\n        static isEqual(size1: ISize, size2: ISize): boolean {\r\n            return size1.width === size2.width\r\n                && size1.height === size2.height;\r\n        }\r\n\r\n        static isEmpty(size: Size): boolean {\r\n            return size.width === 0\r\n                || size.height === 0;\r\n        }\r\n\r\n        static max(dest: ISize, size2: ISize) {\r\n            dest.width = Math.max(dest.width, size2.width);\r\n            dest.height = Math.max(dest.height, size2.height);\r\n        }\r\n\r\n        static min(dest: ISize, size2: ISize) {\r\n            dest.width = Math.min(dest.width, size2.width);\r\n            dest.height = Math.min(dest.height, size2.height);\r\n        }\r\n\r\n        static round(size: ISize) {\r\n            size.width = Math.round(size.width);\r\n            size.height = Math.round(size.height);\r\n        }\r\n\r\n        static clear(size: ISize) {\r\n            size.width = 0;\r\n            size.height = 0;\r\n        }\r\n\r\n        static isUndef(size: ISize): boolean {\r\n            return isNaN(size.width)\r\n                && isNaN(size.height);\r\n        }\r\n\r\n        static undef(size: ISize) {\r\n            size.width = NaN;\r\n            size.height = NaN;\r\n        }\r\n    }\r\n}","/// <reference path=\"../convert/converters\" />\n\nnamespace mirage.core {\n    function booleanDefaultTrue(value: string): boolean {\n        return value !== \"0\"\n            && value !== \"false\";\n    }\n\n    function float(value: string): number {\n        if (!value)\n            return 0;\n        return parseFloat(value) || 0;\n    }\n\n    function floatDefaultNaN(value: string): number {\n        if (!value)\n            return NaN;\n        return parseFloat(value);\n    }\n\n    function floatDefaultInfinite(value: string): number {\n        if (!value)\n            return Number.POSITIVE_INFINITY;\n        let val = parseFloat(value);\n        if (isNaN(val))\n            return Number.POSITIVE_INFINITY;\n        return val;\n    }\n\n    function thickness(value: string): Thickness {\n        let tokens = splitCommaList(value);\n        if (tokens.length === 1) {\n            let uniform = parseFloat(tokens[0]);\n            return new Thickness(uniform, uniform, uniform, uniform);\n        } else if (tokens.length === 2) {\n            let x = parseFloat(tokens[0]);\n            let y = parseFloat(tokens[1]);\n            return new Thickness(x, y, x, y);\n        } else if (tokens.length === 4) {\n            return new Thickness(\n                parseFloat(tokens[0]),\n                parseFloat(tokens[1]),\n                parseFloat(tokens[2]),\n                parseFloat(tokens[3])\n            );\n        } else {\n            console.warn(\"[mirage] Invalid thickness value\", value);\n        }\n    }\n\n    export function enumConverter(src: any): (value: string) => any {\n        return (value: string): any => {\n            if (!value)\n                return 0;\n            return src[value] || 0;\n        };\n    }\n\n    function splitCommaList(str: string): string[] {\n        var tokens: string[] = [];\n        for (var i = 0, arr = str.split(' ').join(',').split(','); i < arr.length; i++) {\n            var cur = arr[i];\n            if (cur)\n                tokens.push(cur);\n        }\n        return tokens;\n    }\n\n    convert.register(\"visible\", booleanDefaultTrue);\n    convert.register(\"use-layout-rounding\", booleanDefaultTrue);\n    convert.register(\"margin\", thickness);\n    convert.register(\"width\", floatDefaultNaN);\n    convert.register(\"height\", floatDefaultNaN);\n    convert.register(\"min-width\", float);\n    convert.register(\"min-height\", float);\n    convert.register(\"max-width\", floatDefaultInfinite);\n    convert.register(\"max-height\", floatDefaultInfinite);\n    convert.register(\"horizontal-alignment\", enumConverter(HorizontalAlignment));\n    convert.register(\"vertical-alignment\", enumConverter(VerticalAlignment));\n}","/// <reference path=\"typeLookup\" />\n/// <reference path=\"convert/converters\" />\n/// <reference path=\"core/converters\" />\n/// <reference path=\"map/mappers\" />\n\nnamespace mirage {\n    export interface IStackPanelInputs extends core.ILayoutNodeInputs {\n        orientation: Orientation;\n    }\n\n    export class StackPanel extends Panel {\n        inputs: IStackPanelInputs;\n\n        get orientation(): Orientation {\n            return this.inputs.orientation;\n        }\n\n        set orientation(value: Orientation) {\n            value = value || 0; // coerce null, undefined, 0 => 0\n            if (this.inputs.orientation === value)\n                return;\n            this.inputs.orientation = value;\n            this.invalidateMeasure();\n            this.invalidateArrange();\n        }\n\n        protected createInputs(): IStackPanelInputs {\n            var inputs = <IStackPanelInputs>super.createInputs();\n            inputs.orientation = Orientation.horizontal;\n            return inputs;\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            if (this.inputs.orientation === Orientation.vertical) {\n                return this.measureVertical(constraint);\n            } else {\n                return this.measureHorizontal(constraint);\n            }\n        }\n\n        private measureVertical(constraint: ISize): ISize {\n            var ca = new Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new Size();\n            var inputs = this.inputs;\n\n            ca.width = constraint.width;\n            if (!isNaN(inputs.width))\n                ca.width = inputs.width;\n            ca.width = Math.min(ca.width, inputs.maxWidth);\n            ca.width = Math.max(ca.width, inputs.minWidth);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n\n                var childDesired = child.state.desiredSize;\n                measured.height += childDesired.height;\n                measured.width = Math.max(measured.width, childDesired.width);\n            }\n\n            return measured;\n        }\n\n        private measureHorizontal(constraint: ISize): ISize {\n            var ca = new Size(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n            var measured = new Size();\n            var inputs = this.inputs;\n\n            ca.height = constraint.height;\n            if (!isNaN(inputs.height))\n                ca.height = inputs.height;\n            ca.height = Math.min(ca.height, inputs.maxHeight);\n            ca.height = Math.max(ca.height, inputs.minHeight);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                child.measure(ca);\n\n                var childDesired = child.state.desiredSize;\n                measured.width += childDesired.width;\n                measured.height = Math.max(measured.height, childDesired.height);\n            }\n\n            return measured;\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            if (this.inputs.orientation === Orientation.vertical) {\n                return this.arrangeVertical(arrangeSize);\n            } else {\n                return this.arrangeHorizontal(arrangeSize);\n            }\n        }\n\n        private arrangeVertical(arrangeSize: ISize): ISize {\n            var arranged = new Size(arrangeSize.width, 0);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new Rect(0, arranged.height, arrangeSize.width, childDesired.height);\n                if (Rect.isEmpty(childFinal))\n                    Rect.clear(childFinal);\n\n                child.arrange(childFinal);\n\n                arranged.width = Math.max(arranged.width, arrangeSize.width);\n                arranged.height += childDesired.height;\n            }\n\n            arranged.height = Math.max(arranged.height, arrangeSize.height);\n\n            return arranged;\n        }\n\n        private arrangeHorizontal(arrangeSize: ISize): ISize {\n            var arranged = new Size(0, arrangeSize.height);\n\n            for (var walker = this.tree.walk(); walker.step();) {\n                var child = walker.current;\n                var childDesired = child.state.desiredSize;\n                var childFinal = new Rect(arranged.width, 0, childDesired.width, arrangeSize.height);\n                if (Rect.isEmpty(childFinal))\n                    Rect.clear(childFinal);\n\n                child.arrange(childFinal);\n\n                arranged.width += childDesired.width;\n                arranged.height = Math.max(arranged.height, arrangeSize.height);\n            }\n\n            arranged.width = Math.max(arranged.width, arrangeSize.width);\n\n            return arranged;\n        }\n    }\n    registerNodeType(\"stack-panel\", StackPanel);\n    convert.register(\"orientation\", core.enumConverter(Orientation));\n    map.registerNormal(\"orientation\", \"orientation\");\n}","namespace mirage.core {\n    export interface IArranger {\n        (finalRect: Rect): boolean;\n    }\n    export interface IArrangeOverride {\n        (finalSize: ISize): ISize;\n    }\n\n    export function NewArranger(inputs: ILayoutNodeInputs, state: ILayoutNodeState, tree: ILayoutTree, override: IArrangeOverride): IArranger {\n        function calcOffer(childRect: IRect): ISize {\n            var stretched = new Size(childRect.width, childRect.height);\n            coerceSize(stretched, inputs);\n\n            var framework = new Size();\n            coerceSize(framework, inputs);\n            if (inputs.horizontalAlignment === HorizontalAlignment.stretch) {\n                framework.width = Math.max(framework.width, stretched.width);\n            }\n            if (inputs.verticalAlignment === VerticalAlignment.stretch) {\n                framework.height = Math.max(framework.height, stretched.height);\n            }\n            var offer = new Size(state.hiddenDesire.width, state.hiddenDesire.height);\n            Size.max(offer, framework);\n            return offer;\n        }\n\n        function calcVisualOffset(childRect: IRect, arranged: ISize): IPoint {\n            var constrained = new Size(arranged.width, arranged.height);\n            coerceSize(constrained, inputs);\n            Size.min(constrained, arranged);\n\n            var vo = new Point();\n            Point.copyTo(childRect, vo);\n            switch (inputs.horizontalAlignment) {\n                case HorizontalAlignment.left:\n                    break;\n                case HorizontalAlignment.right:\n                    vo.x += childRect.width - constrained.width;\n                    break;\n                case HorizontalAlignment.center:\n                    vo.x += (childRect.width - constrained.width) * 0.5;\n                    break;\n                default:\n                    vo.x += Math.max((childRect.width - constrained.width) * 0.5, 0);\n                    break;\n            }\n            switch (inputs.verticalAlignment) {\n                case VerticalAlignment.top:\n                    break;\n                case VerticalAlignment.bottom:\n                    vo.y += childRect.height - constrained.height;\n                    break;\n                case VerticalAlignment.center:\n                    vo.y += (childRect.height - constrained.height) * 0.5;\n                    break;\n                default:\n                    vo.y += Math.max((childRect.height - constrained.height) * 0.5, 0);\n                    break;\n            }\n            if (inputs.useLayoutRounding) {\n                Point.round(vo);\n            }\n            return vo;\n        }\n\n        return function (finalRect: Rect): boolean {\n            if (inputs.visible !== true) {\n                return false;\n            }\n\n            // Apply rounding\n            var childRect = new Rect();\n            if (inputs.useLayoutRounding) {\n                childRect.x = Math.round(finalRect.x);\n                childRect.y = Math.round(finalRect.y);\n                childRect.width = Math.round(finalRect.width);\n                childRect.height = Math.round(finalRect.height);\n            } else {\n                Rect.copyTo(finalRect, childRect);\n            }\n\n            // Validate\n            if (childRect.width < 0 || childRect.height < 0\n                || !isFinite(childRect.width) || !isFinite(childRect.height)\n                || isNaN(childRect.x) || isNaN(childRect.y)\n                || isNaN(childRect.width) || isNaN(childRect.height)) {\n                console.warn(\"[mirage] cannot call arrange using rect with NaN/infinite values.\");\n                return false;\n            }\n\n            // Check need to arrange\n            if ((state.flags & LayoutFlags.arrange) <= 0) {\n                return false;\n            }\n            if (Rect.isEqual(state.layoutSlot, childRect)) {\n                return false;\n            }\n            Rect.copyTo(childRect, state.layoutSlot);\n\n            // Prepare offer\n            Thickness.shrinkRect(inputs.margin, childRect);\n            var offer = calcOffer(childRect);\n\n            // Do override\n            var arranged = override(offer);\n\n            // Complete override\n            state.flags &= ~LayoutFlags.arrange;\n            if (inputs.useLayoutRounding) {\n                Size.round(arranged);\n            }\n\n            // Calculate visual offset\n            var vo = calcVisualOffset(childRect, arranged);\n\n            // If arranged slot moved, invalidate slotting\n            if (!Point.isEqual(vo, state.arrangedSlot) || !Size.isEqual(arranged, state.arrangedSlot)) {\n                Rect.copyTo(state.arrangedSlot, state.lastArrangedSlot);\n                state.flags |= LayoutFlags.slotHint;\n                tree.propagateFlagUp(LayoutFlags.slotHint);\n            }\n\n            // Finalize arrangedSlot\n            Size.copyTo(arranged, state.arrangedSlot);\n            Point.copyTo(vo, state.arrangedSlot);\n\n            return true;\n        }\n    }\n}","namespace mirage.core {\n    export function DefaultLayoutTree(): ILayoutTree {\n        return {\n            parent: null,\n            applyTemplate(): boolean {\n                return true;\n            },\n            propagateFlagUp(flag: LayoutFlags) {\n                for (var cur: LayoutNode = this.parent; !!cur && (cur.state.flags & flag) <= 0; cur = cur.tree.parent) {\n                    cur.state.flags |= flag;\n                }\n            },\n            walk(reverse?: boolean): ILayoutTreeWalker {\n                return {\n                    current: undefined,\n                    step(): boolean {\n                        return false;\n                    },\n                }\n            },\n        };\n    }\n}","namespace mirage.core {\n    export enum LayoutFlags {\n        none = 0,\n\n        measure = 1 << 1,\n        arrange = 1 << 2,\n\n        measureHint = 1 << 3,\n        arrangeHint = 1 << 4,\n        slotHint    = 1 << 5,\n        hints       = measureHint | arrangeHint | slotHint,\n    }\n}\n","/// <reference path=\"converters\" />\n\nnamespace mirage.core {\n    map.registerNormal(\"visible\", \"visible\");\n    map.registerNormal(\"use-layout-rounding\", \"useLayoutRounding\");\n    map.registerNormal(\"margin\", \"margin\");\n    map.registerNormal(\"width\", \"width\");\n    map.registerNormal(\"height\", \"height\");\n    map.registerNormal(\"min-width\", \"minWidth\");\n    map.registerNormal(\"min-height\", \"minHeight\");\n    map.registerNormal(\"max-width\", \"maxWidth\");\n    map.registerNormal(\"max-height\", \"maxHeight\");\n    map.registerNormal(\"horizontal-alignment\", \"horizontalAlignment\");\n    map.registerNormal(\"vertical-alignment\", \"verticalAlignment\");\n}","namespace mirage.core {\n    export interface IMeasurer {\n        (availableSize: ISize): boolean;\n    }\n    export interface IMeasureOverride {\n        (coreSize: ISize): Size;\n    }\n\n    export function NewMeasurer(inputs: ILayoutNodeInputs, state: ILayoutNodeState, tree: ILayoutTree, override: IMeasureOverride): IMeasurer {\n        return function (availableSize: ISize): boolean {\n            // Validate\n            if (isNaN(availableSize.width) || isNaN(availableSize.height)) {\n                console.warn(\"[mirage] cannot call measure using a size with NaN values.\");\n                return false;\n            }\n            if (inputs.visible !== true) {\n                return false;\n            }\n\n            // Check need to measure\n            if ((state.flags & LayoutFlags.measure) <= 0) {\n                return false;\n            }\n            var last = state.lastAvailable;\n            if (!Size.isUndef(last) && last.width === availableSize.width && last.height === availableSize.height) {\n                return false;\n            }\n            Size.copyTo(availableSize, last);\n\n            // Apply Template\n            tree.applyTemplate();\n\n            // Invalidate downstream\n            state.flags |= (LayoutFlags.arrange | LayoutFlags.arrangeHint);\n\n            // Prepare for override\n            var framedSize = new Size(availableSize.width, availableSize.height);\n            Thickness.shrinkSize(inputs.margin, framedSize);\n            coerceSize(framedSize, inputs);\n\n            // Do override\n            var desired = override(framedSize);\n\n            // Complete override\n            state.flags &= ~LayoutFlags.measure;\n            Size.copyTo(desired, state.hiddenDesire);\n\n            // Finish desired\n            coerceSize(desired, inputs);\n            Thickness.growSize(inputs.margin, desired);\n\n            desired.width = Math.min(desired.width, availableSize.width);\n            desired.height = Math.min(desired.height, availableSize.height);\n            if (inputs.useLayoutRounding) {\n                Size.round(desired);\n            }\n            Size.copyTo(desired, state.desiredSize);\n\n            return true;\n        };\n    }\n}","namespace mirage.core {\n    export interface ISized {\n        width: number;\n        height: number;\n        minWidth: number;\n        minHeight: number;\n        maxWidth: number;\n        maxHeight: number;\n        useLayoutRounding: boolean;\n    }\n\n    export function coerceSize(size: ISize, inputs: ISized) {\n        var cw = Math.max(inputs.minWidth, size.width);\n        var ch = Math.max(inputs.minHeight, size.height);\n\n        if (!isNaN(inputs.width))\n            cw = inputs.width;\n\n        if (!isNaN(inputs.height))\n            ch = inputs.height;\n\n        cw = Math.max(Math.min(cw, inputs.maxWidth), inputs.minWidth);\n        ch = Math.max(Math.min(ch, inputs.maxHeight), inputs.minHeight);\n\n        if (inputs.useLayoutRounding) {\n            cw = Math.round(cw);\n            ch = Math.round(ch);\n        }\n\n        size.width = cw;\n        size.height = ch;\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    export interface IArrangeDrafter {\n        flush();\n        prepare(): boolean;\n        draft(rootSize: ISize): boolean;\n    }\n\n    export function NewArrangeDrafter(node: core.LayoutNode): IArrangeDrafter {\n        var arrangeList: core.LayoutNode[] = [];\n\n        return {\n            flush() {\n                var cur: core.LayoutNode;\n                while ((cur = arrangeList.shift()) != null) {\n                    cur.tree.propagateFlagUp(LayoutFlags.arrangeHint);\n                }\n            },\n            prepare(): boolean {\n                for (var walker = node.walkDeep(); walker.step();) {\n                    var cur = walker.current;\n                    if (!cur.inputs.visible) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    if ((cur.state.flags & LayoutFlags.arrangeHint) === 0) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    cur.state.flags &= ~LayoutFlags.arrangeHint;\n                    if ((cur.state.flags & LayoutFlags.arrange) > 0) {\n                        arrangeList.push(cur);\n                    }\n                }\n                return arrangeList.length > 0;\n            },\n            draft(rootSize: ISize): boolean {\n                var cur: core.LayoutNode;\n                while ((cur = arrangeList.shift()) != null) {\n                    cur.doArrange(rootSize);\n                }\n                return true;\n            },\n        }\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    var MAX_COUNT = 255;\n\n    export interface IDrafter {\n        (updater: IDraftUpdater, rootSize: ISize): boolean;\n    }\n\n    export interface IDraftUpdater {\n        updateSlots(updates: draft.ISlotUpdate[]);\n    }\n\n    export function NewDrafter(node: core.LayoutNode): IDrafter {\n        var measure = NewMeasureDrafter(node);\n        var arrange = NewArrangeDrafter(node);\n        var slot = NewSlotDrafter(node);\n\n        /// Every pass at runDraft will exclusively run measure, arrange, or size\n        /// true should be returned if any updates were made\n        function runDraft(updater: IDraftUpdater, rootSize: ISize): boolean {\n            if (!node.inputs.visible)\n                return false;\n\n            arrange.flush();\n            slot.flush();\n\n            var flags = node.state.flags;\n            if ((flags & LayoutFlags.measureHint) > 0) {\n                return measure.prepare()\n                    && measure.draft();\n            }\n            if ((flags & LayoutFlags.arrangeHint) > 0) {\n                return arrange.prepare()\n                    && arrange.draft(rootSize);\n            }\n            if ((flags & LayoutFlags.slotHint) > 0) {\n                return slot.prepare()\n                    && slot.draft()\n                    && slot.notify(updater);\n            }\n\n            return false;\n        }\n\n        return function (updater: IDraftUpdater, rootSize: ISize): boolean {\n            if ((node.state.flags & LayoutFlags.hints) === 0)\n                return false;\n            var updated = false;\n            var count = 0;\n            for (; count < MAX_COUNT; count++) {\n                if (!runDraft(updater, rootSize))\n                    break;\n                updated = true;\n            }\n            if (count >= MAX_COUNT) {\n                console.error(\"[mirage] aborting infinite draft\");\n            }\n            return updated;\n        };\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    export interface IMeasureDrafter {\n        prepare(): boolean;\n        draft(): boolean;\n    }\n\n    export function NewMeasureDrafter(node: core.LayoutNode): IMeasureDrafter {\n        var measureList: core.LayoutNode[] = [];\n\n        return {\n            prepare(): boolean {\n                for (var walker = node.walkDeep(); walker.step();) {\n                    var cur = walker.current;\n                    if (!cur.inputs.visible) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    if ((cur.state.flags & LayoutFlags.measureHint) === 0) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    cur.state.flags &= ~LayoutFlags.measureHint;\n                    if ((cur.state.flags & LayoutFlags.measure) > 0) {\n                        measureList.push(cur);\n                    }\n                }\n\n                return measureList.length > 0;\n            },\n            draft(): boolean {\n                var cur: core.LayoutNode;\n                while ((cur = measureList.shift()) != null) {\n                    cur.doMeasure();\n                }\n                return true;\n            },\n        };\n    }\n}","/// <reference path=\"../core/LayoutFlags\" />\n\nnamespace mirage.draft {\n    import LayoutFlags = mirage.core.LayoutFlags;\n\n    export interface ISlotDrafter {\n        flush();\n        prepare(): boolean;\n        draft(): boolean;\n        notify(updater: IDraftUpdater): boolean;\n    }\n\n    export interface ISlotUpdate {\n        node: core.LayoutNode;\n        oldRect: IRect;\n        newRect: IRect;\n    }\n\n    export function NewSlotDrafter(node: core.LayoutNode): ISlotDrafter {\n        var slotList: core.LayoutNode[] = [];\n        var slotUpdates: ISlotUpdate[] = [];\n\n        return {\n            flush() {\n                var cur: core.LayoutNode;\n                while ((cur = slotList.shift()) != null) {\n                    cur.tree.propagateFlagUp(LayoutFlags.slotHint);\n                }\n            },\n            prepare(): boolean {\n                for (var walker = node.walkDeep(); walker.step();) {\n                    var cur = walker.current;\n                    if (!cur.inputs.visible) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    if ((cur.state.flags & LayoutFlags.slotHint) === 0) {\n                        walker.skipBranch();\n                        continue;\n                    }\n\n                    cur.state.flags &= ~LayoutFlags.slotHint;\n                    if (!Rect.isUndef(cur.state.lastArrangedSlot)) {\n                        slotList.push(cur);\n                    }\n                }\n                return slotList.length > 0;\n            },\n            draft(): boolean {\n                var oldRect = new Rect();\n                var newRect = new Rect();\n                var cur: core.LayoutNode;\n                while ((cur = slotList.pop()) != null) {\n                    cur.slot(oldRect, newRect);\n                    if (!Rect.isEqual(oldRect, newRect)) {\n                        slotUpdates.push({\n                            node: cur,\n                            oldRect: oldRect,\n                            newRect: newRect,\n                        });\n                        oldRect = new Rect();\n                        newRect = new Rect();\n                    }\n                }\n                return slotUpdates.length > 0;\n            },\n            notify(updater: IDraftUpdater): boolean {\n                updater.updateSlots(slotUpdates);\n                return true;\n            }\n        };\n    }\n}","namespace mirage.grid {\n    export function NewGridArrangeOverride(inputs: IGridInputs, state: IGridState, tree: IPanelTree): core.IArrangeOverride {\n        var des = state.design.arrange;\n\n        return function (arrangeSize: ISize): ISize {\n            des.init(arrangeSize, inputs.columnDefinitions, inputs.rowDefinitions);\n\n            var cr = new Rect();\n            for (var walker = tree.walk(); walker.step();) {\n                var child = walker.current;\n                des.calcChildRect(cr, child);\n                child.arrange(cr);\n            }\n\n            return new Size(arrangeSize.width, arrangeSize.height);\n        };\n    }\n}","namespace mirage.grid {\n    export function NewGridMeasureOverride(inputs: IGridInputs, state: IGridState, tree: IPanelTree): core.IMeasureOverride {\n        var des = state.design.measure;\n\n        var overrideAutoAuto = design.NewMeasureOverridePass(design.MeasureOverridePass.autoAuto, des, tree);\n        var overrideStarAuto = design.NewMeasureOverridePass(design.MeasureOverridePass.starAuto, des, tree);\n        var overrideAutoStar = design.NewMeasureOverridePass(design.MeasureOverridePass.autoStar, des, tree);\n        var overrideStarAuto2 = design.NewMeasureOverridePass(design.MeasureOverridePass.starAutoAgain, des, tree);\n        var overrideNonStar = design.NewMeasureOverridePass(design.MeasureOverridePass.nonStar, des, tree);\n        var overrideRemainingStar = design.NewMeasureOverridePass(design.MeasureOverridePass.remainingStar, des, tree);\n\n        return function (constraint: ISize): ISize {\n            des.init(constraint, inputs.columnDefinitions, inputs.rowDefinitions, tree);\n            overrideAutoAuto();\n            overrideStarAuto();\n            overrideAutoStar();\n            overrideStarAuto2();\n            overrideNonStar();\n            overrideRemainingStar();\n            des.finish();\n            return des.getDesired();\n        };\n    }\n}","namespace mirage.grid.design {\n    export interface IGridArrangeDesign {\n        init(arrangeSize: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[]);\n        calcChildRect(childRect: IRect, child: core.LayoutNode);\n    }\n\n    export function NewGridArrangeDesign(cm: Segment[][], rm: Segment[][]): IGridArrangeDesign {\n        return {\n            init(arrangeSize: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[]) {\n                originalToOffered(cm);\n                originalToOffered(rm);\n\n                var consumed = new Size(helpers.calcDesiredToOffered(cm), helpers.calcDesiredToOffered(rm));\n\n                if (consumed.width !== arrangeSize.width) {\n                    helpers.expand(arrangeSize.width, cm);\n                }\n                if (consumed.height !== arrangeSize.height) {\n                    helpers.expand(arrangeSize.height, rm);\n                }\n\n                if (!!coldefs) {\n                    for (var i = 0; i < coldefs.length; i++) {\n                        coldefs[i].setActualWidth(cm[i][i].offered);\n                    }\n                }\n                if (!!rowdefs) {\n                    for (var i = 0; i < rowdefs.length; i++) {\n                        rowdefs[i].setActualHeight(rm[i][i].offered);\n                    }\n                }\n            },\n            calcChildRect(childRect: IRect, child: core.LayoutNode) {\n                Rect.clear(childRect);\n\n                var col = Grid.getColumn(child) || 0; //coerce NaN, undefined, null, 0 => 0\n                col = Math.min(col, cm.length - 1);\n\n                var colspan = Grid.getColumnSpan(child);\n                if (colspan !== 0)\n                    colspan = colspan || 1; //coerce NaN, undefined, null => 1\n                colspan = Math.min(colspan, cm.length - col);\n\n                var row = Grid.getRow(child) || 0; //coerce NaN, undefined, null, 0 => 0\n                row = Math.min(row, rm.length - 1);\n\n                var rowspan = Grid.getRowSpan(child);\n                if (rowspan !== 0)\n                    rowspan = rowspan || 1; //coerce NaN, undefined, null => 1\n                rowspan = Math.min(rowspan, rm.length - row);\n\n                for (var i = 0; i < col; i++) {\n                    childRect.x += cm[i][i].offered;\n                }\n                for (var i = col; i < col + colspan; i++) {\n                    childRect.width += cm[i][i].offered;\n                }\n\n                for (var i = 0; i < row; i++) {\n                    childRect.y += rm[i][i].offered;\n                }\n                for (var i = row; i < row + rowspan; i++) {\n                    childRect.height += rm[i][i].offered;\n                }\n            },\n        };\n    }\n\n    function originalToOffered(matrix: Segment[][]) {\n        for (var i = 0; i < matrix.length; i++) {\n            for (var j = 0; j <= i; j++) {\n                matrix[i][j].offered = matrix[i][j].original;\n            }\n        }\n    }\n}","namespace mirage.grid.design {\n    export interface IGridPlacement {\n        init();\n        add(isRow: boolean, start: number, span: number, size: number);\n        allocate(allocFunc: () => void);\n    }\n\n    interface IGridPlacementCell {\n        matrix: Segment[][];\n        start: number;\n        end: number;\n        size: number;\n    }\n\n    export function NewGridPlacement(cm: Segment[][], rm: Segment[][]): IGridPlacement {\n        var unicells: IGridPlacementCell[] = [];\n        var multicells: IGridPlacementCell[] = [];\n\n        return {\n            init() {\n                unicells.length = 0;\n                multicells.length = 0;\n            },\n            add(isRow: boolean, start: number, span: number, size: number) {\n                var item: IGridPlacementCell = {\n                    matrix: isRow ? rm : cm,\n                    start: start,\n                    end: start + span - 1,\n                    size: size,\n                };\n                if (item.start === item.end) {\n                    unicells.unshift(item);\n                } else {\n                    multicells.push(item);\n                }\n            },\n            allocate(allocFunc: () => void) {\n                var cell: IGridPlacementCell;\n                while ((cell = unicells.pop()) != null) {\n                    var i = cell.start;\n                    var j = cell.end;\n                    cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                    allocFunc();\n                }\n                while ((cell = multicells.pop()) != null) {\n                    var i = cell.start;\n                    var j = cell.end;\n                    cell.matrix[i][j].desired = Math.max(cell.matrix[i][j].desired, cell.size);\n                    allocFunc();\n                }\n            },\n        }\n    }\n}","namespace mirage.grid.design {\n    export interface IGridShape {\n        hasAutoAuto: boolean;\n        hasStarAuto: boolean;\n        hasAutoStar: boolean;\n    }\n\n    export function NewGridShape(childShapes: IGridChildShape[]): IGridShape {\n        var hasAutoAuto = false;\n        var hasStarAuto = false;\n        var hasAutoStar = false;\n\n        for (var i = 0; i < childShapes.length; i++) {\n            let cs = childShapes[i];\n            hasAutoAuto = hasAutoAuto || (cs.autoRow && cs.autoCol && !cs.starRow && !cs.starCol);\n            hasStarAuto = hasStarAuto || (cs.starRow && cs.autoCol);\n            hasAutoStar = hasAutoStar || (cs.autoRow && cs.starCol);\n        }\n\n        return {\n            hasAutoAuto: hasAutoAuto,\n            hasStarAuto: hasStarAuto,\n            hasAutoStar: hasAutoStar,\n        };\n    }\n\n    export interface IGridChildShape {\n        starRow: boolean;\n        autoRow: boolean;\n        starCol: boolean;\n        autoCol: boolean;\n\n        col: number;\n        row: number;\n        colspan: number;\n        rowspan: number;\n\n        init (child: core.LayoutNode, rm: Segment[][], cm: Segment[][]);\n        shouldMeasurePass (gridShape: IGridShape, childSize: ISize, pass: MeasureOverridePass): boolean;\n        calcConstraint (childSize: ISize, cm: Segment[][], rm: Segment[][]);\n    }\n\n    export class GridChildShape implements IGridChildShape {\n        starRow: boolean;\n        autoRow: boolean;\n        starCol: boolean;\n        autoCol: boolean;\n\n        col: number;\n        row: number;\n        colspan: number;\n        rowspan: number;\n\n        init(child: core.LayoutNode, cm: Segment[][], rm: Segment[][]) {\n            var col = this.col = Math.min(Grid.getColumn(child), cm.length - 1);\n            if (isNaN(col))\n                this.col = col = 0;\n            var row = this.row = Math.min(Grid.getRow(child), rm.length - 1);\n            if (isNaN(row))\n                this.row = row = 0;\n            var colspan = this.colspan = Math.min(Grid.getColumnSpan(child), cm.length - col);\n            if (isNaN(colspan))\n                this.colspan = colspan = 1;\n            var rowspan = this.rowspan = Math.min(Grid.getRowSpan(child), rm.length - row);\n            if (isNaN(rowspan))\n                this.rowspan = rowspan = 1;\n\n            this.starRow = this.autoRow = this.starCol = this.autoCol = false;\n\n            for (var i = row; i < row + rowspan; i++) {\n                this.starRow = this.starRow || (rm[i][i].type === GridUnitType.star);\n                this.autoRow = this.autoRow || (rm[i][i].type === GridUnitType.auto);\n            }\n            for (var i = col; i < col + colspan; i++) {\n                this.starCol = this.starCol || (cm[i][i].type === GridUnitType.star);\n                this.autoCol = this.autoCol || (cm[i][i].type === GridUnitType.auto);\n            }\n        }\n\n        shouldMeasurePass(gridShape: IGridShape, childSize: ISize, pass: MeasureOverridePass): boolean {\n            childSize.width = childSize.height = 0;\n\n            if (this.autoRow && this.autoCol && !this.starRow && !this.starCol) {\n                if (pass !== MeasureOverridePass.autoAuto)\n                    return false;\n                childSize.width = Number.POSITIVE_INFINITY;\n                childSize.height = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if (this.starRow && this.autoCol && !this.starCol) {\n                if (pass !== MeasureOverridePass.starAuto && pass !== MeasureOverridePass.starAutoAgain)\n                    return false;\n                if (pass === MeasureOverridePass.autoAuto && gridShape.hasAutoStar)\n                    childSize.height = Number.POSITIVE_INFINITY;\n                childSize.width = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if (this.autoRow && this.starCol && !this.starRow) {\n                if (pass !== MeasureOverridePass.autoStar)\n                    return false;\n                childSize.height = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if ((this.autoRow || this.autoCol) && !(this.starRow || this.starCol)) {\n                if (pass !== MeasureOverridePass.nonStar)\n                    return false;\n                if (this.autoRow)\n                    childSize.height = Number.POSITIVE_INFINITY;\n                if (this.autoCol)\n                    childSize.width = Number.POSITIVE_INFINITY;\n                return true;\n            }\n\n            if (!(this.starRow || this.starCol))\n                return pass === MeasureOverridePass.nonStar;\n\n            return pass === MeasureOverridePass.remainingStar;\n        }\n\n        calcConstraint(childSize: ISize, cm: Segment[][], rm: Segment[][]) {\n            for (var i = this.row; i < this.row + this.rowspan; i++) {\n                childSize.height += rm[i][i].offered;\n            }\n            for (var i = this.col; i < this.col + this.colspan; i++) {\n                childSize.width += cm[i][i].offered;\n            }\n        }\n    }\n}","namespace mirage.grid.design.helpers {\n    export function expand(available: number, mat: Segment[][]) {\n        for (var i = 0; i < mat.length; i++) {\n            var cur = mat[i][i];\n            if (cur.type === GridUnitType.star)\n                cur.offered = 0;\n            else\n                available = Math.max(available - cur.offered, 0);\n        }\n        assignSize(mat, 0, mat.length - 1, available, GridUnitType.star, false);\n\n        //TODO: setActualWidth, setActualHeight if star?\n    }\n\n    export function assignSize(mat: Segment[][], start: number, end: number, size: number, unitType: GridUnitType, desiredSize: boolean): number {\n        var count = 0;\n        var assigned = false;\n        var segmentSize = 0;\n        for (var i = start; i <= end; i++) {\n            let cur = mat[i][i];\n            segmentSize = desiredSize ? cur.desired : cur.offered;\n            if (segmentSize < cur.max)\n                count += (unitType === GridUnitType.star) ? cur.stars : 1;\n        }\n\n        do {\n            assigned = false;\n            let contribution = size / count;\n            for (var i = start; i <= end; i++) {\n                let cur = mat[i][i];\n                segmentSize = desiredSize ? cur.desired : cur.offered;\n                if (!(cur.type === unitType && segmentSize < cur.max))\n                    continue;\n                let newSize = segmentSize;\n                newSize += contribution * (unitType === GridUnitType.star ? cur.stars : 1);\n                newSize = Math.min(newSize, cur.max);\n                assigned = assigned || (newSize > segmentSize);\n                size -= newSize - segmentSize;\n                if (desiredSize)\n                    cur.desired = newSize;\n                else\n                    cur.offered = newSize;\n            }\n        } while (assigned);\n        return size;\n    }\n\n    export function calcDesiredToOffered(matrix: Segment[][]): number {\n        var total = 0;\n        for (var i = 0; i < matrix.length; i++) {\n            total += (matrix[i][i].offered = matrix[i][i].desired);\n        }\n        return total;\n    }\n}","namespace mirage.grid.design {\n    export interface IGridDesign {\n        measure: IGridMeasureDesign;\n        arrange: IGridArrangeDesign;\n    }\n\n    export function NewGridDesign(): IGridDesign {\n        var cm: Segment[][] = [];\n        var rm: Segment[][] = [];\n\n        return {\n            measure: NewGridMeasureDesign(cm, rm),\n            arrange: NewGridArrangeDesign(cm, rm),\n        };\n    }\n}","namespace mirage.grid.design {\n    export interface IGridMeasureDesign {\n        init(constraint: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[], tree: IPanelTree);\n        measureChild(pass: MeasureOverridePass, index: number, child: core.LayoutNode);\n        finishPass();\n        finish();\n        getDesired(): ISize;\n    }\n\n    export function NewGridMeasureDesign(cm: Segment[][], rm: Segment[][]): IGridMeasureDesign {\n        var shape: IGridShape;\n        var childShapes: IGridChildShape[] = [];\n        var placement = NewGridPlacement(cm, rm);\n\n        return {\n            init(constraint: ISize, coldefs: IColumnDefinition[], rowdefs: IRowDefinition[], tree: IPanelTree) {\n                ensureMatrix(cm, !coldefs ? 1 : coldefs.length || 1);\n                ensureMatrix(rm, !rowdefs ? 1 : rowdefs.length || 1);\n                prepareCols(cm, coldefs);\n                prepareRows(rm, rowdefs);\n\n                var i = 0;\n                for (var walker = tree.walk(); walker.step(); i++) {\n                    var childShape: IGridChildShape;\n                    if (i < childShapes.length) {\n                        childShapes[i] = childShapes[i] || new GridChildShape();\n                    } else {\n                        childShapes.push(childShape = new GridChildShape());\n                    }\n                    childShape.init(walker.current, cm, rm);\n                }\n                if (i < childShapes.length)\n                    childShapes.slice(i, childShapes.length - i);\n                shape = NewGridShape(childShapes);\n\n                placement.init();\n\n                if (tree.children.length > 0) {\n                    helpers.expand(constraint.width, cm);\n                    helpers.expand(constraint.height, rm);\n                }\n\n            },\n            measureChild(pass: MeasureOverridePass, index: number, child: core.LayoutNode) {\n                var childShape = childShapes[index];\n\n                var childSize = new Size();\n                if (!childShape || !childShape.shouldMeasurePass(shape, childSize, pass))\n                    return;\n                childShape.calcConstraint(childSize, cm, rm);\n\n                child.measure(childSize);\n\n                var desired = child.state.desiredSize;\n                if (pass !== MeasureOverridePass.starAuto)\n                    placement.add(true, childShape.row, childShape.rowspan, desired.height);\n                placement.add(false, childShape.col, childShape.colspan, desired.width);\n            },\n            finishPass() {\n                placement.allocate(allocateDesiredSizeFunc(cm, rm));\n            },\n            finish() {\n                for (var i = 0; i < cm.length; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        cm[i][j].original = cm[i][j].offered;\n                    }\n                }\n                for (var i = 0; i < rm.length; i++) {\n                    for (var j = 0; j <= i; j++) {\n                        rm[i][j].original = rm[i][j].offered;\n                    }\n                }\n            },\n            getDesired(): ISize {\n                var desired = new Size();\n                for (var i = 0; i < cm.length; i++) {\n                    desired.width += cm[i][i].desired;\n                }\n                for (var i = 0; i < rm.length; i++) {\n                    desired.height += rm[i][i].desired;\n                }\n                return desired;\n            },\n        }\n    }\n\n    var DEFAULT_GRID_LEN: IGridLength = {\n        value: 1.0,\n        type: GridUnitType.star\n    };\n\n    function ensureMatrix(matrix: Segment[][], defCount: number) {\n        if (matrix.length > defCount)\n            matrix.splice(defCount, matrix.length - defCount);\n        for (var i = 0; i < defCount; i++) {\n            if (matrix.length <= i)\n                matrix.push([]);\n            var mrow = matrix[i];\n            if (mrow.length > (i + 1))\n                mrow.splice(i, mrow.length - i - 1);\n            for (var ii = 0; ii <= i; ii++) {\n                if (mrow.length <= ii)\n                    mrow.push(new Segment());\n                else\n                    Segment.init(mrow[ii]);\n            }\n        }\n    }\n\n    function prepareCols(cm: Segment[][], coldefs: IColumnDefinition[]) {\n        if (!coldefs || coldefs.length === 0) {\n            var mcell = cm[0][0];\n            mcell.type = GridUnitType.star;\n            mcell.stars = 1.0;\n            return;\n        }\n\n        for (var i = 0; i < coldefs.length; i++) {\n            var colDef = coldefs[i];\n            var width = colDef.width || DEFAULT_GRID_LEN;\n            colDef.setActualWidth(Number.POSITIVE_INFINITY);\n\n            var cell = Segment.init(cm[i][i], 0.0, colDef.minWidth, colDef.maxWidth, width.type);\n            if (width.type === GridUnitType.pixel) {\n                cell.desired = cell.offered = cell.clamp(width.value);\n                colDef.setActualWidth(cell.desired);\n            } else if (width.type === GridUnitType.star) {\n                cell.stars = width.value;\n            } else if (width.type === GridUnitType.auto) {\n                cell.desired = cell.offered = cell.clamp(0);\n            }\n        }\n    }\n\n    function prepareRows(rm: Segment[][], rowdefs: IRowDefinition[]) {\n        if (!rowdefs || rowdefs.length === 0) {\n            var mcell = rm[0][0];\n            mcell.type = GridUnitType.star;\n            mcell.stars = 1.0;\n            return;\n        }\n\n        for (var i = 0; i < rowdefs.length; i++) {\n            var rowDef = rowdefs[i];\n            var height = rowDef.height || DEFAULT_GRID_LEN;\n            rowDef.setActualHeight(Number.POSITIVE_INFINITY);\n\n            var cell = Segment.init(rm[i][i], 0.0, rowDef.minHeight, rowDef.maxHeight, height.type);\n            if (height.type === GridUnitType.pixel) {\n                cell.desired = cell.offered = cell.clamp(height.value);\n                rowDef.setActualHeight(cell.desired);\n            } else if (height.type === GridUnitType.star) {\n                cell.stars = height.value;\n            } else if (height.type === GridUnitType.auto) {\n                cell.desired = cell.offered = cell.clamp(0);\n            }\n        }\n    }\n\n    function allocateDesiredSizeFunc(cm: Segment[][], rm: Segment[][]): () => void {\n        function hasStarInSpan(mat: Segment[][], start: number, end: number): boolean {\n            var spansStar = false;\n            for (var i = start; i >= end; i--) {\n                spansStar = spansStar || mat[i][i].type === GridUnitType.star;\n            }\n            return spansStar;\n        }\n\n        function calcDesired(mat: Segment[][], start: number, end: number): number {\n            var total = 0;\n            for (var i = start; i >= end; i--) {\n                total += mat[i][i].desired;\n            }\n            return total;\n        }\n\n        function allocSegments(mat: Segment[][]) {\n            var count = mat.length;\n            for (var start = count - 1; start >= 0; start--) {\n                for (var end = start; end >= 0; end--) {\n                    let hasStar = hasStarInSpan(mat, start, end);\n                    let cur = mat[start][end].desired;\n                    let total = calcDesired(mat, start, end);\n                    let additional = cur - total;\n                    if (additional > 0) {\n                        if (hasStar) {\n                            helpers.assignSize(mat, end, start, additional, GridUnitType.star, true);\n                        } else {\n                            helpers.assignSize(mat, end, start, additional, GridUnitType.pixel, true);\n                            helpers.assignSize(mat, end, start, additional, GridUnitType.auto, true);\n                        }\n                    }\n                }\n            }\n        }\n\n        return function () {\n            // Allocate heights then widths\n            allocSegments(rm);\n            allocSegments(cm);\n\n            helpers.calcDesiredToOffered(rm);\n            helpers.calcDesiredToOffered(cm);\n        };\n    }\n}","namespace mirage.grid.design {\n    export enum MeasureOverridePass {\n        autoAuto, //Child in auto row, auto col\n        starAuto, //Child in star row, auto col\n        autoStar, //Child in auto row, star col\n        starAutoAgain, //star row, auto col repeated\n        nonStar, //Child in auto/pixel row, auto/pixel col\n        remainingStar, //Child in ?\n    }\n\n    export function NewMeasureOverridePass(pass: MeasureOverridePass, des: IGridMeasureDesign, tree: IPanelTree) {\n        return function() {\n            for (var walker = tree.walk(), i = 0; walker.step(); i++) {\n                des.measureChild(pass, i, walker.current);\n            }\n            des.finishPass();\n        };\n    }\n}","module mirage.grid.design {\r\n    export class Segment {\r\n        desired: number = 0.0;\r\n        offered: number = 0.0;\r\n        original: number = 0.0;\r\n        min: number = 0.0;\r\n        max: number = Number.POSITIVE_INFINITY;\r\n        stars: number = 0;\r\n        type = GridUnitType.pixel;\r\n\r\n        clamp(value: number): number {\r\n            if (value < this.min)\r\n                return this.min;\r\n            if (value > this.max)\r\n                return this.max;\r\n            return value;\r\n        }\r\n\r\n        static init(segment: Segment, offered?: number, min?: number, max?: number, unitType?: GridUnitType): Segment {\r\n            segment.desired = 0.0;\r\n            segment.stars = 0;\r\n            segment.offered = offered || 0.0;\r\n            segment.min = min || 0.0;\r\n            segment.max = max != null ? max : Number.POSITIVE_INFINITY;\r\n            segment.type = unitType != null ? unitType : GridUnitType.pixel;\r\n\r\n            if (segment.offered < min)\r\n                segment.offered = min;\r\n            else if (segment.offered > max)\r\n                segment.offered = max;\r\n\r\n            return segment;\r\n        }\r\n    }\r\n}"],"sourceRoot":"/mirage"}